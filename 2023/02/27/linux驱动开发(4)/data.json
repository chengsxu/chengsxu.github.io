{"title":"linux驱动开发(4)","date":"2023-02-27T07:02:13.404Z","source":"_posts/linux驱动开发(4).md","raw":"---\ntitle: linux驱动开发(4)\ndate: 2023-02-27 15:02:13.404\nupdated: 2025-03-09 21:14:13.404\ncategories: \ntags: \n- linux驱动开发\n- linux\n---\n设备树基础\n<!-- more -->\n\n# DTB DTS DTC\nDTB：编译的最终设备树文件\n\nDTS：设备树描述文件，类似于C源码\n\nDTC：设备树的编译器，类似于GCC\n\nDTSI: 设备树的头文件，类似于.H头文件\n\n设备树编写文档推荐：\n\n《Devicetree SpecificationV0.2.pdf》\n\n《Power_ePAPR_APPROVED_v1.12.pdf》\n\n*正常情况不需要开发人员从零开始写一个设备树文件，大多数都是在处理器厂商提供的信息上进行增删即可，因此这方面不需要特地学习的非常精通*\n\n# DTS语法规则\n\n- **文件包含**\n\n![image-20250309212811979](linux驱动开发(4)/image-20250309212811979.png)\n\n- 节点命名格式为node-name@unit-address，unit-address可以省略\n\n- 节点标签，label: node-name@unit-address\n\n- DTS的信息以键值对的新式组织，值分为以下几类\n  - **字符串、字符串列表**\n\n    ![image-20250309213218618](linux驱动开发(4)/image-20250309213218618-1741527146970-1.png)\n\n    ![image-20250309213519974](linux驱动开发(4)/image-20250309213519974.png)\n  \n  - **32 位无符号整数、整数列表**\n  \n    ![image-20250309213417880](linux驱动开发(4)/image-20250309213417880.png)\n  \n    ![image-20250309213459954](linux驱动开发(4)/image-20250309213459954.png)\n\n## **标准属性**\n\n- **compatible属性**，描述设备的匹配信息\n\n  ![image-20250309213519974](linux驱动开发(4)/image-20250309213519974.png)\n\n- **model属性**，描述设备模块信息，比如名称\n\n![image-20250309214122712](linux驱动开发(4)/image-20250309214122712.png)\n\n- **status属性**\n\n| **值**   | **描述**                                                     |\n| -------- | ------------------------------------------------------------ |\n| okay     | 表明设备是可操作的。                                         |\n| disabled | 表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。至于 disabled 的具体含义还要看设备的绑定文档。 |\n| fail     | 表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。 |\n| fail-sss | 含义和“fail”相同，后面的 sss 部分是检测到的错误内容。        |\n\n- **#address-cells 和#size-cells属性**，#address-cells用于描述reg子节点的“地址”的长度（32位），#size-cells用于描述reg子节点中“长度”的长度；\n\n![image-20250309214915150](linux驱动开发(4)/image-20250309214915150.png)\n\n- **reg属性**，描述地址信息，数据形式为整数列表，一般是(address，length)对\n\n- **ranges** **属性**，属性值可以为空（子地址空间和父地址空间完全相同）或者按照(child-bus-address,parent-bus-address,length)格式编写的数字列表，其中长度同样由**#address-cells 和#size-cells属性**决定\n\n  ![image-20250309215401882](linux驱动开发(4)/image-20250309215401882.png)\n\n  ![image-20250309215709974](linux驱动开发(4)/image-20250309215709974.png)\n\n- **name** **属性**(已弃用)，用于记录节点名字\n- **device_type** **属性**，用于记录节点FCode，只能用于 cpu 节点或者 memory 节点\n\n## 向节点追加或修改内容\n\n- 直接在特定节点中添加/修改新的子节点\n- 使用&引用特定节点进行追加/修改\n\n![image-20250309220902267](linux驱动开发(4)/image-20250309220902267.png)\n\n\n# 将节点信息记录到设备树中\n- 原理很简单，本质就是抽取驱动中的关键信息，放在设备树中，驱动利用特定的函数访问设备树中的地址信息，从而达到驱动代码的复用\n\n- 可在/proc/device_tree 中观察驱动中的信息\n- **特殊节点** **aliases** **子节点**，定义别名\n- **chosen** **子节点**，主要是为了 uboot 向 Linux 内核传递数据（uboot do_bootz调用函数 fdt_chosen 向 chosen 节点添加 bootargs 属性）\n\n![image-20250309221931301](linux驱动开发(4)/image-20250309221931301.png)\n\n- Linux 源码目录/Documentation/devicetree/bindings中查询绑定信息的文档\n\n# 常用of函数获取dts中的信息\n*只列举常用的，全部的在of.h头文件中，使用方法不难，类似于cJson库*\n\n```c\nstruct device_node* of_find_node_by_name(struct device_node *from\n                                         const char *name)\n\ninline struct device_node *of_find_node_by_path(const char *path)\n\nstatic inline struct property *of_find_property(const struct device_node *np,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tint *lenp)\n\nstatic inline int of_property_read_string(struct device_node *np,\n\t\t\t\t\t  const char *propname,\n\t\t\t\t\t  const char **out_string)\n\nstatic inline int of_property_read_u32_array(const struct device_node *np,\n\t\t\t\t\t     const char *propname,\n\t\t\t\t\t     u32 *out_values, size_t sz)                   \n```\n\n## of_iomap 函数\n功能类似于ioremap函数，但是兼容了设备树，可直接通过设备树节点访问其出错的地址信息，并进行一次内存映射\n```c\n# linux/of_address.h\nvoid __iomem *of_iomap(struct device_node *device, int index);\n\n```\n","slug":"linux驱动开发(4)","published":true,"updated":"2025-03-09T13:14:13.404Z","_id":"cm833960x001di0q6atnvg4ef","comments":true,"layout":"post","photos":[],"html":"<p>设备树基础</p>\n<span id=\"more\"></span>\n\n<h1 id=\"DTB-DTS-DTC\"><a href=\"#DTB-DTS-DTC\" class=\"headerlink\" title=\"DTB DTS DTC\"></a>DTB DTS DTC</h1><p>DTB：编译的最终设备树文件</p>\n<p>DTS：设备树描述文件，类似于C源码</p>\n<p>DTC：设备树的编译器，类似于GCC</p>\n<p>DTSI: 设备树的头文件，类似于.H头文件</p>\n<p>设备树编写文档推荐：</p>\n<p>《Devicetree SpecificationV0.2.pdf》</p>\n<p>《Power_ePAPR_APPROVED_v1.12.pdf》</p>\n<p><em>正常情况不需要开发人员从零开始写一个设备树文件，大多数都是在处理器厂商提供的信息上进行增删即可，因此这方面不需要特地学习的非常精通</em></p>\n<h1 id=\"DTS语法规则\"><a href=\"#DTS语法规则\" class=\"headerlink\" title=\"DTS语法规则\"></a>DTS语法规则</h1><ul>\n<li><strong>文件包含</strong></li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309212811979.png\" alt=\"image-20250309212811979\"></p>\n<ul>\n<li><p>节点命名格式为node-name@unit-address，unit-address可以省略</p>\n</li>\n<li><p>节点标签，label: node-name@unit-address</p>\n</li>\n<li><p>DTS的信息以键值对的新式组织，值分为以下几类</p>\n<ul>\n<li><p><strong>字符串、字符串列表</strong></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213218618-1741527146970-1.png\" alt=\"image-20250309213218618\"></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213519974.png\" alt=\"image-20250309213519974\"></p>\n</li>\n<li><p><strong>32 位无符号整数、整数列表</strong></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213417880.png\" alt=\"image-20250309213417880\"></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213459954.png\" alt=\"image-20250309213459954\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"标准属性\"><a href=\"#标准属性\" class=\"headerlink\" title=\"标准属性\"></a><strong>标准属性</strong></h2><ul>\n<li><p><strong>compatible属性</strong>，描述设备的匹配信息</p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213519974.png\" alt=\"image-20250309213519974\"></p>\n</li>\n<li><p><strong>model属性</strong>，描述设备模块信息，比如名称</p>\n</li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309214122712.png\" alt=\"image-20250309214122712\"></p>\n<ul>\n<li><strong>status属性</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>值</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>okay</td>\n<td>表明设备是可操作的。</td>\n</tr>\n<tr>\n<td>disabled</td>\n<td>表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。至于 disabled 的具体含义还要看设备的绑定文档。</td>\n</tr>\n<tr>\n<td>fail</td>\n<td>表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。</td>\n</tr>\n<tr>\n<td>fail-sss</td>\n<td>含义和“fail”相同，后面的 sss 部分是检测到的错误内容。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>#address-cells 和#size-cells属性</strong>，#address-cells用于描述reg子节点的“地址”的长度（32位），#size-cells用于描述reg子节点中“长度”的长度；</li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309214915150.png\" alt=\"image-20250309214915150\"></p>\n<ul>\n<li><p><strong>reg属性</strong>，描述地址信息，数据形式为整数列表，一般是(address，length)对</p>\n</li>\n<li><p><strong>ranges</strong> <strong>属性</strong>，属性值可以为空（子地址空间和父地址空间完全相同）或者按照(child-bus-address,parent-bus-address,length)格式编写的数字列表，其中长度同样由**#address-cells 和#size-cells属性**决定</p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309215401882.png\" alt=\"image-20250309215401882\"></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309215709974.png\" alt=\"image-20250309215709974\"></p>\n</li>\n<li><p><strong>name</strong> <strong>属性</strong>(已弃用)，用于记录节点名字</p>\n</li>\n<li><p><strong>device_type</strong> <strong>属性</strong>，用于记录节点FCode，只能用于 cpu 节点或者 memory 节点</p>\n</li>\n</ul>\n<h2 id=\"向节点追加或修改内容\"><a href=\"#向节点追加或修改内容\" class=\"headerlink\" title=\"向节点追加或修改内容\"></a>向节点追加或修改内容</h2><ul>\n<li>直接在特定节点中添加&#x2F;修改新的子节点</li>\n<li>使用&amp;引用特定节点进行追加&#x2F;修改</li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309220902267.png\" alt=\"image-20250309220902267\"></p>\n<h1 id=\"将节点信息记录到设备树中\"><a href=\"#将节点信息记录到设备树中\" class=\"headerlink\" title=\"将节点信息记录到设备树中\"></a>将节点信息记录到设备树中</h1><ul>\n<li><p>原理很简单，本质就是抽取驱动中的关键信息，放在设备树中，驱动利用特定的函数访问设备树中的地址信息，从而达到驱动代码的复用</p>\n</li>\n<li><p>可在&#x2F;proc&#x2F;device_tree 中观察驱动中的信息</p>\n</li>\n<li><p><strong>特殊节点</strong> <strong>aliases</strong> <strong>子节点</strong>，定义别名</p>\n</li>\n<li><p><strong>chosen</strong> <strong>子节点</strong>，主要是为了 uboot 向 Linux 内核传递数据（uboot do_bootz调用函数 fdt_chosen 向 chosen 节点添加 bootargs 属性）</p>\n</li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309221931301.png\" alt=\"image-20250309221931301\"></p>\n<ul>\n<li>Linux 源码目录&#x2F;Documentation&#x2F;devicetree&#x2F;bindings中查询绑定信息的文档</li>\n</ul>\n<h1 id=\"常用of函数获取dts中的信息\"><a href=\"#常用of函数获取dts中的信息\" class=\"headerlink\" title=\"常用of函数获取dts中的信息\"></a>常用of函数获取dts中的信息</h1><p><em>只列举常用的，全部的在of.h头文件中，使用方法不难，类似于cJson库</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> device_node* <span class=\"title function_\">of_find_node_by_name</span><span class=\"params\">(<span class=\"keyword\">struct</span> device_node *from</span></span><br><span class=\"line\"><span class=\"params\">                                         <span class=\"type\">const</span> <span class=\"type\">char</span> *name)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> device_node *<span class=\"title function_\">of_find_node_by_path</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *path)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> property *<span class=\"title function_\">of_find_property</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> device_node *np,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t<span class=\"type\">const</span> <span class=\"type\">char</span> *name,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t<span class=\"type\">int</span> *lenp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">of_property_read_string</span><span class=\"params\">(<span class=\"keyword\">struct</span> device_node *np,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t  <span class=\"type\">const</span> <span class=\"type\">char</span> *propname,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t  <span class=\"type\">const</span> <span class=\"type\">char</span> **out_string)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">of_property_read_u32_array</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> device_node *np,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t     <span class=\"type\">const</span> <span class=\"type\">char</span> *propname,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t     u32 *out_values, <span class=\"type\">size_t</span> sz)</span>                   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"of-iomap-函数\"><a href=\"#of-iomap-函数\" class=\"headerlink\" title=\"of_iomap 函数\"></a>of_iomap 函数</h2><p>功能类似于ioremap函数，但是兼容了设备树，可直接通过设备树节点访问其出错的地址信息，并进行一次内存映射</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># linux/of_address.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> __iomem *<span class=\"title function_\">of_iomap</span><span class=\"params\">(<span class=\"keyword\">struct</span> device_node *device, <span class=\"type\">int</span> index)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","excerpt":"<p>设备树基础</p>","more":"<h1 id=\"DTB-DTS-DTC\"><a href=\"#DTB-DTS-DTC\" class=\"headerlink\" title=\"DTB DTS DTC\"></a>DTB DTS DTC</h1><p>DTB：编译的最终设备树文件</p>\n<p>DTS：设备树描述文件，类似于C源码</p>\n<p>DTC：设备树的编译器，类似于GCC</p>\n<p>DTSI: 设备树的头文件，类似于.H头文件</p>\n<p>设备树编写文档推荐：</p>\n<p>《Devicetree SpecificationV0.2.pdf》</p>\n<p>《Power_ePAPR_APPROVED_v1.12.pdf》</p>\n<p><em>正常情况不需要开发人员从零开始写一个设备树文件，大多数都是在处理器厂商提供的信息上进行增删即可，因此这方面不需要特地学习的非常精通</em></p>\n<h1 id=\"DTS语法规则\"><a href=\"#DTS语法规则\" class=\"headerlink\" title=\"DTS语法规则\"></a>DTS语法规则</h1><ul>\n<li><strong>文件包含</strong></li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309212811979.png\" alt=\"image-20250309212811979\"></p>\n<ul>\n<li><p>节点命名格式为node-name@unit-address，unit-address可以省略</p>\n</li>\n<li><p>节点标签，label: node-name@unit-address</p>\n</li>\n<li><p>DTS的信息以键值对的新式组织，值分为以下几类</p>\n<ul>\n<li><p><strong>字符串、字符串列表</strong></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213218618-1741527146970-1.png\" alt=\"image-20250309213218618\"></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213519974.png\" alt=\"image-20250309213519974\"></p>\n</li>\n<li><p><strong>32 位无符号整数、整数列表</strong></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213417880.png\" alt=\"image-20250309213417880\"></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213459954.png\" alt=\"image-20250309213459954\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"标准属性\"><a href=\"#标准属性\" class=\"headerlink\" title=\"标准属性\"></a><strong>标准属性</strong></h2><ul>\n<li><p><strong>compatible属性</strong>，描述设备的匹配信息</p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309213519974.png\" alt=\"image-20250309213519974\"></p>\n</li>\n<li><p><strong>model属性</strong>，描述设备模块信息，比如名称</p>\n</li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309214122712.png\" alt=\"image-20250309214122712\"></p>\n<ul>\n<li><strong>status属性</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>值</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>okay</td>\n<td>表明设备是可操作的。</td>\n</tr>\n<tr>\n<td>disabled</td>\n<td>表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。至于 disabled 的具体含义还要看设备的绑定文档。</td>\n</tr>\n<tr>\n<td>fail</td>\n<td>表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。</td>\n</tr>\n<tr>\n<td>fail-sss</td>\n<td>含义和“fail”相同，后面的 sss 部分是检测到的错误内容。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>#address-cells 和#size-cells属性</strong>，#address-cells用于描述reg子节点的“地址”的长度（32位），#size-cells用于描述reg子节点中“长度”的长度；</li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309214915150.png\" alt=\"image-20250309214915150\"></p>\n<ul>\n<li><p><strong>reg属性</strong>，描述地址信息，数据形式为整数列表，一般是(address，length)对</p>\n</li>\n<li><p><strong>ranges</strong> <strong>属性</strong>，属性值可以为空（子地址空间和父地址空间完全相同）或者按照(child-bus-address,parent-bus-address,length)格式编写的数字列表，其中长度同样由**#address-cells 和#size-cells属性**决定</p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309215401882.png\" alt=\"image-20250309215401882\"></p>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309215709974.png\" alt=\"image-20250309215709974\"></p>\n</li>\n<li><p><strong>name</strong> <strong>属性</strong>(已弃用)，用于记录节点名字</p>\n</li>\n<li><p><strong>device_type</strong> <strong>属性</strong>，用于记录节点FCode，只能用于 cpu 节点或者 memory 节点</p>\n</li>\n</ul>\n<h2 id=\"向节点追加或修改内容\"><a href=\"#向节点追加或修改内容\" class=\"headerlink\" title=\"向节点追加或修改内容\"></a>向节点追加或修改内容</h2><ul>\n<li>直接在特定节点中添加&#x2F;修改新的子节点</li>\n<li>使用&amp;引用特定节点进行追加&#x2F;修改</li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309220902267.png\" alt=\"image-20250309220902267\"></p>\n<h1 id=\"将节点信息记录到设备树中\"><a href=\"#将节点信息记录到设备树中\" class=\"headerlink\" title=\"将节点信息记录到设备树中\"></a>将节点信息记录到设备树中</h1><ul>\n<li><p>原理很简单，本质就是抽取驱动中的关键信息，放在设备树中，驱动利用特定的函数访问设备树中的地址信息，从而达到驱动代码的复用</p>\n</li>\n<li><p>可在&#x2F;proc&#x2F;device_tree 中观察驱动中的信息</p>\n</li>\n<li><p><strong>特殊节点</strong> <strong>aliases</strong> <strong>子节点</strong>，定义别名</p>\n</li>\n<li><p><strong>chosen</strong> <strong>子节点</strong>，主要是为了 uboot 向 Linux 内核传递数据（uboot do_bootz调用函数 fdt_chosen 向 chosen 节点添加 bootargs 属性）</p>\n</li>\n</ul>\n<p><img src=\"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/image-20250309221931301.png\" alt=\"image-20250309221931301\"></p>\n<ul>\n<li>Linux 源码目录&#x2F;Documentation&#x2F;devicetree&#x2F;bindings中查询绑定信息的文档</li>\n</ul>\n<h1 id=\"常用of函数获取dts中的信息\"><a href=\"#常用of函数获取dts中的信息\" class=\"headerlink\" title=\"常用of函数获取dts中的信息\"></a>常用of函数获取dts中的信息</h1><p><em>只列举常用的，全部的在of.h头文件中，使用方法不难，类似于cJson库</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> device_node* <span class=\"title function_\">of_find_node_by_name</span><span class=\"params\">(<span class=\"keyword\">struct</span> device_node *from</span></span><br><span class=\"line\"><span class=\"params\">                                         <span class=\"type\">const</span> <span class=\"type\">char</span> *name)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> device_node *<span class=\"title function_\">of_find_node_by_path</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *path)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> property *<span class=\"title function_\">of_find_property</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> device_node *np,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t<span class=\"type\">const</span> <span class=\"type\">char</span> *name,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t<span class=\"type\">int</span> *lenp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">of_property_read_string</span><span class=\"params\">(<span class=\"keyword\">struct</span> device_node *np,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t  <span class=\"type\">const</span> <span class=\"type\">char</span> *propname,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t  <span class=\"type\">const</span> <span class=\"type\">char</span> **out_string)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">of_property_read_u32_array</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> device_node *np,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t     <span class=\"type\">const</span> <span class=\"type\">char</span> *propname,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t     u32 *out_values, <span class=\"type\">size_t</span> sz)</span>                   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"of-iomap-函数\"><a href=\"#of-iomap-函数\" class=\"headerlink\" title=\"of_iomap 函数\"></a>of_iomap 函数</h2><p>功能类似于ioremap函数，但是兼容了设备树，可直接通过设备树节点访问其出错的地址信息，并进行一次内存映射</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># linux/of_address.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> __iomem *<span class=\"title function_\">of_iomap</span><span class=\"params\">(<span class=\"keyword\">struct</span> device_node *device, <span class=\"type\">int</span> index)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","path":"2023/02/27/linux驱动开发(4)/","permalink":"http://chengs.run/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/","tags":[{"name":"linux","_id":"cm833960c0002i0q66dwgd8wg","slug":"linux","path":"tags/linux/","permalink":"http://chengs.run/tags/linux/","length":13},{"name":"linux驱动开发","_id":"cm833960x001ci0q69qnhfuvg","slug":"linux驱动开发","path":"tags/linux驱动开发/","permalink":"http://chengs.run/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/","length":4}],"categories":[],"prev":{"title":"DDR SDRAM","date":"2023-07-02T05:06:32.692Z","slug":"DDR_SDRAM","published":true,"updated":"2023-07-02T05:10:50.232Z","_id":"cm833960b0001i0q640glfn6o","layout":"post","photos":[],"excerpt":"<p>DDR SDRAM</p>","path":"2023/07/02/DDR_SDRAM/","permalink":"http://chengs.run/2023/07/02/DDR_SDRAM/","__post":true},"next":{"title":"linux驱动开发(3)","date":"2023-02-25T17:30:11.506Z","slug":"linux驱动开发(3)","published":true,"updated":"2023-02-25T17:31:03.345Z","_id":"cm833960w001ai0q6e5x18ch1","layout":"post","photos":[],"excerpt":"<p>新字符设备驱动</p>","path":"2023/02/25/linux驱动开发(3)/","permalink":"http://chengs.run/2023/02/25/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(3)/","__post":true},"__post":true}