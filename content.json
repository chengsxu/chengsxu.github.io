{"pages":[{"title":"","text":"html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:\"Lucida Console\",Consolas,\"Courier\",monospace; --title-bar-height:20px; } .mac-os-11 { --title-bar-height:28px; } html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; } iframe { margin: auto; } a.url { word-break: break-all; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; } #write.first-line-indent p { text-indent: 2em; } #write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; } #write.first-line-indent li { margin-left: 2em; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } .typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; } .typora-export .task-list-item input { pointer-events: none; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } #write { padding-left: 20px; padding-right: 20px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } #write li > figure:last-child { margin-bottom: 0.5rem; } #write ol, #write ul { position: relative; } img { max-width: 100%; vertical-align: middle; image-orientation: from-image; } button, input, select, textarea { color: inherit; font: inherit; } input[type=\"checkbox\"], input[type=\"radio\"] { line-height: normal; padding: 0px; } *, ::after, ::before { box-sizing: border-box; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; } p { line-height: inherit; } h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; } p { orphans: 4; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } .md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; } sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; } #write input[type=\"checkbox\"] { cursor: pointer; width: inherit; height: inherit; } figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; } figure > table { margin: 0px; } tr { break-inside: avoid; break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; } table.md-table td { min-width: 32px; } .CodeMirror-gutters { border-right: 0px; background-color: inherit; } .CodeMirror-linenumber { user-select: none; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } #write pre { white-space: pre-wrap; } #write.fences-no-line-wrapping pre { white-space: pre; } #write pre.ty-contain-cm { white-space: normal; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; } .md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } #write .md-fences.mock-cm { white-space: pre-wrap; } .md-fences.md-fences-with-lineno { padding-left: 0px; } #write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; } .md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; } .CodeMirror-line, twitterwidget { break-inside: avoid; } .footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; } .footnotes + .footnotes { margin-top: 0px; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li .mathjax-block, li p { margin: 0.5rem 0px; } li blockquote { margin: 1rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child, li > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; } #write .footnote-line { white-space: pre-wrap; } @media print { body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; } #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; } .typora-export * { -webkit-print-color-adjust: exact; } .typora-export #write { break-after: avoid; } .typora-export #write::after { height: 0px; } .is-mac table { break-inside: avoid; } .typora-export-show-outline .typora-export-sidebar { display: none; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; } p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; } #write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; } p > .md-image:only-child { display: inline-block; width: 100%; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .md-math-block { width: 100%; } .md-math-block:not(:empty)::after { display: none; } .MathJax_ref { fill: currentcolor; } [contenteditable=\"true\"]:active, [contenteditable=\"true\"]:focus, [contenteditable=\"false\"]:active, [contenteditable=\"false\"]:focus { outline: 0px; box-shadow: none; } .md-task-list-item { position: relative; list-style-type: none; } .task-list-item.md-task-list-item { padding-left: 0px; } .md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc-content::after, .md-toc::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); } .md-toc-item a { text-decoration: none; } .md-toc-inner:hover { text-decoration: underline; } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: \".\"; } code, pre, samp, tt { font-family: var(--monospace); } kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; } .md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); } code { text-align: left; vertical-align: initial; } a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; } .os-windows.monocolor-emoji .md-emoji { font-family: \"Segoe UI Symbol\", sans-serif; } .md-diagram-panel > svg { max-width: 100%; } [lang=\"flow\"] svg, [lang=\"mermaid\"] svg { max-width: 100%; height: auto; } [lang=\"mermaid\"] .node text { font-size: 1rem; } table tr th { border-bottom: 0px; } video { max-width: 100%; display: block; margin: 0px auto; } iframe { max-width: 100%; width: 100%; border: none; } .highlight td, .highlight tr { border: 0px; } mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); } .md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; } .md-expand mark .md-meta { opacity: 0.3 !important; } mark .md-meta { color: rgb(0, 0, 0); } @media print { .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; } } .md-diagram-panel .messageText { stroke: none !important; } .md-diagram-panel .start-state { fill: var(--node-fill); } .md-diagram-panel .edgeLabel rect { opacity: 1 !important; } .md-fences.md-fences-math { font-size: 1em; } .md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; } .md-fences-advanced:not(.md-focus) { background: inherit; } .typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; } .typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; } .typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; } .typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; } @media screen and (max-width: 1024px) { .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; } } @media screen and (max-width: 800px) { .typora-export-sidebar { display: none; } } .outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; } .outline-content ul { margin-top: 0px; margin-bottom: 0px; } .outline-content strong { font-weight: 400; } .outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; } .outline-expander::before { content: \"\"; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; } .outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; } .outline-expander:hover::before { content: \"\"; } .outline-h1 > .outline-item { padding-left: 0px; } .outline-h2 > .outline-item { padding-left: 1em; } .outline-h3 > .outline-item { padding-left: 2em; } .outline-h4 > .outline-item { padding-left: 3em; } .outline-h5 > .outline-item { padding-left: 4em; } .outline-h6 > .outline-item { padding-left: 5em; } .outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; } .outline-label:hover { text-decoration: underline; } .outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); } .outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; } .outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; } .outline-item-open > .outline-item > .outline-expander::before { content: \"\"; } .outline-children { display: none; } .info-panel-tab-wrapper { display: none; } .outline-item-open > .outline-children { display: block; } .typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; } .typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; } .typora-export .outline-expander::before { content: \"+\"; font-family: inherit; top: -1px; } .typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: \"−\"; } .typora-export-collapse-outline .outline-children { display: none; } .typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; } .typora-export-no-collapse-outline .outline-expander::before { content: \"\" !important; } .typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; } .md-inline-math-container mjx-container { zoom: 0.95; } .CodeMirror { height: auto; } .CodeMirror.cm-s-inner { background: inherit; } .CodeMirror-scroll { overflow: auto hidden; z-index: 3; } .CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); } .CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; } .CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); } .cm-s-inner .cm-keyword { color: rgb(119, 0, 136); } .cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); } .cm-s-inner .cm-number { color: rgb(17, 102, 68); } .cm-s-inner .cm-def { color: rgb(0, 0, 255); } .cm-s-inner .cm-variable { color: rgb(0, 0, 0); } .cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); } .cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); } .cm-s-inner .cm-string { color: rgb(170, 17, 17); } .cm-s-inner .cm-property { color: rgb(0, 0, 0); } .cm-s-inner .cm-operator { color: rgb(152, 26, 26); } .cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); } .cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); } .cm-s-inner .cm-meta { color: rgb(85, 85, 85); } .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); } .cm-s-inner .cm-builtin { color: rgb(51, 0, 170); } .cm-s-inner .cm-bracket { color: rgb(153, 153, 119); } .cm-s-inner .cm-tag { color: rgb(17, 119, 0); } .cm-s-inner .cm-attribute { color: rgb(0, 0, 204); } .cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); } .cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); } .cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); } .cm-negative { color: rgb(221, 68, 68); } .cm-positive { color: rgb(34, 153, 34); } .cm-header, .cm-strong { font-weight: 700; } .cm-del { text-decoration: line-through; } .cm-em { font-style: italic; } .cm-link { text-decoration: underline; } .cm-error { color: red; } .cm-invalidchar { color: red; } .cm-constant { color: rgb(38, 139, 210); } .cm-defined { color: rgb(181, 137, 0); } div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); } div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); } .cm-s-inner .CodeMirror-activeline-background { background: inherit; } .CodeMirror { position: relative; overflow: hidden; } .CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; } .CodeMirror-sizer { position: relative; } .CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; } .CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; } .CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; } .CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; } .CodeMirror-gutter-filler { left: 0px; bottom: 0px; } .CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; } .CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; } .CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; } .CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; } .CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; } .CodeMirror-lines { cursor: text; } .CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; } .CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; } .CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; } .CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; } .CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; } .CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; } .CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; } .CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; } .CodeMirror-measure pre { position: static; } .CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; } .CodeMirror div.CodeMirror-cursor { visibility: hidden; } .CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; } .cm-searching { background: rgba(255, 255, 0, 0.4); } span.cm-underlined { text-decoration: underline; } span.cm-strikethrough { text-decoration: line-through; } .cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); } .cm-tw-deleted { text-decoration: line-through; } .cm-tw-header5 { font-weight: 700; } .cm-tw-listitem:first-child { padding-left: 10px; } .cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; } .cm-tw-underline { text-decoration: underline; } @media print { .CodeMirror div.CodeMirror-cursor { visibility: hidden; } } :root { --side-bar-bg-color: #fafafa; --control-text-color: #777; } @include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext); /* open-sans-regular - latin-ext_latin */ /* open-sans-italic - latin-ext_latin */ /* open-sans-700 - latin-ext_latin */ /* open-sans-700italic - latin-ext_latin */ html { font-size: 16px; -webkit-font-smoothing: antialiased; } body { font-family: \"Open Sans\",\"Clear Sans\", \"Helvetica Neue\", Helvetica, Arial, 'Segoe UI Emoji', sans-serif; color: rgb(51, 51, 51); line-height: 1.6; } #write { max-width: 860px; margin: 0 auto; padding: 30px; padding-bottom: 100px; } @media only screen and (min-width: 1400px) { #write { max-width: 1024px; } } @media only screen and (min-width: 1800px) { #write { max-width: 1200px; } } #write > ul:first-child, #write > ol:first-child{ margin-top: 30px; } a { color: #4183C4; } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } h2 { font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } /*@media print { .typora-export h1, .typora-export h2 { border-bottom: none; padding-bottom: initial; } .typora-export h1::after, .typora-export h2::after { content: \"\"; display: block; height: 100px; margin-top: -96px; border-top: 1px solid #eee; } }*/ h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: #777; } p, blockquote, ul, ol, dl, table{ margin: 0.8em 0; } li>ol, li>ul { margin: 0 0; } hr { height: 2px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; overflow: hidden; box-sizing: content-box; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0; } ul:last-child, ol:last-child { margin-bottom: 0; } blockquote { border-left: 4px solid #dfe2e5; padding: 0 15px; color: #777777; } blockquote blockquote { padding-right: 0; } table { padding: 0; word-break: initial; } table tr { border: 1px solid #dfe2e5; margin: 0; padding: 0; } table tr:nth-child(2n), thead { background-color: #f8f8f8; } table th { font-weight: bold; border: 1px solid #dfe2e5; border-bottom: 0; margin: 0; padding: 6px 13px; } table td { border: 1px solid #dfe2e5; margin: 0; padding: 6px 13px; } table th:first-child, table td:first-child { margin-top: 0; } table th:last-child, table td:last-child { margin-bottom: 0; } .CodeMirror-lines { padding-left: 4px; } .code-tooltip { box-shadow: 0 1px 1px 0 rgba(0,28,36,.3); border-top: 1px solid #eef2f2; } .md-fences, code, tt { border: 1px solid #e7eaed; background-color: #f8f8f8; border-radius: 3px; padding: 0; padding: 2px 4px 0px 4px; font-size: 0.9em; } code { background-color: #f3f4f4; padding: 0 2px 0 2px; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; } .md-task-list-item > input { margin-left: -1.3em; } @media print { html { font-size: 13px; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: #f8f8f8; } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border: 0; border-radius: 3px; color: #777777; margin-top: 0 !important; } .mathjax-block>.code-tooltip { bottom: .375rem; } .md-mathjax-midline { background: #fafafa; } #write>h3.md-focus:before{ left: -1.5625rem; top: .375rem; } #write>h4.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h5.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h6.md-focus:before{ left: -1.5625rem; top: .285714286rem; } .md-image>.md-meta { /*border: 1px solid #ddd;*/ border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; } .md-tag { color: #a7a7a7; opacity: 1; } .md-toc { margin-top:20px; padding-bottom:20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid #ddd; background-color: #f8f8f8; } #typora-quick-open-item { background-color: #FAFAFA; border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee; border-style: solid; border-width: 1px; } /** focus mode */ .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer{ font-family: \"Segoe UI\", \"Arial\", sans-serif; } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state{ visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: #fafafa; background-color: var(--side-bar-bg-color); } .md-lang { color: #b4654d; } /*.html-for-mac { --item-hover-bg-color: #E6F0FE; }*/ #md-notification .btn { border: 0; } .dropdown-menu .divider { border-color: #e5e5e5; opacity: 0.4; } .ty-preferences .window-content { background-color: #fafafa; } .ty-preferences .nav-group-item.active { color: white; background: #999; } .menu-item-container a.menu-style-btn { background-color: #f5f8fa; background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); } C++核心编程base64 C++核心编程1 内存分区模型1.1 程序运行前1.2 程序运行后1.3 new操作符2 引用2.1 引用的基本使用2.2 引用注意事项2.3 引用做函数参数2.4 引用做函数返回值2.5 引用的本质2.6 常量引用3 函数提高3.1 函数默认参数3.2 函数占位参数3.3 函数重载3.3.1 函数重载概述3.3.2 函数重载注意事项4 类和对象4.1 封装4.1.1 封装的意义4.1.2 struct和class区别4.1.3 成员属性设置为私有4.2 对象的初始化和清理4.2.1 构造函数和析构函数4.2.2 构造函数的分类及调用4.2.3 拷贝构造函数调用时机4.2.4 构造函数调用规则4.2.5 深拷贝与浅拷贝4.2.6 初始化列表4.2.7 类对象作为类成员4.2.8 静态成员4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储4.3.2 this指针概念4.3.3 空指针访问成员函数4.3.4 const修饰成员函数4.4 友元4.4.1 全局函数做友元4.4.2 类做友元4.4.3 成员函数做友元4.5 运算符重载4.5.1 加号运算符重载4.5.2 左移运算符重载4.5.3 递增运算符重载4.5.4 赋值运算符重载4.5.5 关系运算符重载4.5.6 函数调用运算符重载4.6 继承4.6.1 继承的基本语法4.6.2 继承方式4.6.3 继承中的对象模型4.6.4 继承中构造和析构顺序4.6.5 继承同名成员处理方式4.6.6 继承同名静态成员处理方式4.6.7 多继承语法4.6.8 菱形继承4.7 多态4.7.1 多态的基本概念4.7.2 多态案例一-计算器类4.7.3 纯虚函数和抽象类4.7.4 多态案例二-制作饮品4.7.5 虚析构和纯虚析构4.7.6 多态案例三-电脑组装5 文件操作5.1文本文件5.1.1写文件5.1.2读文件5.2 二进制文件5.2.1 写文件5.2.2 读文件C++核心编程本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。&nbsp;1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域代码区：存放函数体的二进制代码，由操作系统进行管理的全局区：存放全局变量和静态变量以及常量栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收&nbsp;&nbsp;&nbsp;内存四区意义：不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程&nbsp;&nbsp;1.1 程序运行前 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 代码区： 存放 CPU 执行的机器指令 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 全局区： 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：​x//全局变量int g_a = 10;int g_b = 10; //全局常量const int c_g_a = 10;const int c_g_b = 10; int main() { //局部变量 int a = 10; int b = 10; //打印地址 cout &lt;&lt; \"局部变量a地址为： \" &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; \"局部变量b地址为： \" &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; \"全局变量g_a地址为： \" &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; \"全局变量g_b地址为： \" &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 static int s_a = 10; static int s_b = 10; cout &lt;&lt; \"静态变量s_a地址为： \" &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; \"静态变量s_b地址为： \" &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; \"字符串常量地址为： \" &lt;&lt; (int)&amp;\"hello world\" &lt;&lt; endl; cout &lt;&lt; \"字符串常量地址为： \" &lt;&lt; (int)&amp;\"hello world1\" &lt;&lt; endl; cout &lt;&lt; \"全局常量c_g_a地址为： \" &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; \"全局常量c_g_b地址为： \" &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; \"局部常量c_l_a地址为： \" &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; \"局部常量c_l_b地址为： \" &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(\"pause\"); return 0;}打印结果：&nbsp;总结：C++中在程序运行前分为全局区和代码区代码区特点是共享和只读全局区中存放全局变量、静态变量、常量常量区中存放 const修饰的全局常量 和 字符串常量&nbsp;&nbsp;1.2 程序运行后&nbsp; 栈区： 由编译器自动分配释放, 存放函数的参数值,局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放&nbsp;示例：xxxxxxxxxxint * func(){ int a = 10; return &amp;a;} int main() { int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp; 堆区： 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存示例：xxxxxxxxxxint* func(){ int* a = new int(10); return a;} int main() { int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; &nbsp; &nbsp; system(\"pause\"); return 0;}&nbsp;总结：堆区数据由程序员管理开辟和释放堆区数据利用new关键字进行开辟内存&nbsp;&nbsp;&nbsp;&nbsp;1.3 new操作符&nbsp; C++中利用 ** new ** 操作符在堆区开辟数据 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete== 语法：new 数据类型 利用new创建的数据，会返回该数据对应的类型的指针&nbsp;示例1： 基本语法xxxxxxxxxxint* func(){ int* a = new int(10); return a;} int main() { int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; //利用delete释放堆区数据 delete p; //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问 system(\"pause\"); return 0;}&nbsp;示例2：开辟数组xxxxxxxxxx//堆区开辟数组int main() { int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) { arr[i] = i + 100; } for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } //释放数组 delete 后加 [] delete[] arr; system(\"pause\"); return 0;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 引用2.1 引用的基本使用作用： 给变量起别名语法： 数据类型 &amp;别名 = 原名&nbsp;示例：xxxxxxxxxxint main() { int a = 10; int &amp;b = a; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;2.2 引用注意事项引用必须初始化引用在初始化后，不可以改变示例：xxxxxxxxxxint main() { int a = 10; int b = 20; //int &amp;c; //错误，引用必须初始化 int &amp;c = a; //一旦初始化后，就不可以更改 c = b; //这是赋值操作，不是更改引用 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参优点：可以简化指针修改实参&nbsp;示例：xxxxxxxxxx//1. 值传递void mySwap01(int a, int b) { int temp = a; a = b; b = temp;} //2. 地址传递void mySwap02(int* a, int* b) { int temp = *a; *a = *b; *b = temp;} //3. 引用传递void mySwap03(int&amp; a, int&amp; b) { int temp = a; a = b; b = temp;} int main() { int a = 10; int b = 20; mySwap01(a, b); cout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; \" b:\" &lt;&lt; b &lt;&lt; endl; mySwap02(&amp;a, &amp;b); cout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; \" b:\" &lt;&lt; b &lt;&lt; endl; mySwap03(a, b); cout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; \" b:\" &lt;&lt; b &lt;&lt; endl; system(\"pause\"); return 0;} &nbsp;总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4 引用做函数返回值&nbsp;作用：引用是可以作为函数的返回值存在的&nbsp;注意：不要返回局部变量引用用法：函数调用作为左值&nbsp;示例：xxxxxxxxxx//返回局部变量引用int&amp; test01() { int a = 10; //局部变量 return a;} //返回静态变量引用int&amp; test02() { static int a = 20; return a;} int main() { //不能返回局部变量的引用 int&amp; ref = test01(); cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; //如果函数做左值，那么必须返回引用 int&amp; ref2 = test02(); cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; test02() = 1000; cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; system(\"pause\"); return 0;}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量.讲解示例：xxxxxxxxxx//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref){ ref = 100; // ref是引用，转换为*ref = 100}int main(){ int a = 10; &nbsp; &nbsp; &nbsp; &nbsp;//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; &nbsp; &nbsp; cout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"ref:\" &lt;&lt; ref &lt;&lt; endl; &nbsp; &nbsp; func(a); return 0;}结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.6 常量引用&nbsp;作用：常量引用主要用来修饰形参，防止误操作&nbsp;在函数形参列表中，可以加==const修饰形参==，防止形参改变实参&nbsp;示例：&nbsp;xxxxxxxxxx//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) { //v += 10; cout &lt;&lt; v &lt;&lt; endl;} int main() { //int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp; const int&amp; ref = 10; //ref = 100; //加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;3 函数提高3.1 函数默认参数&nbsp;在C++中，函数的形参列表中的形参是可以有默认值的。语法：返回值类型 函数名 （参数= 默认值）{}&nbsp;示例：xxxxxxxxxxint func(int a, int b = 10, int c = 10) { return a + b + c;} //1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) { return a + b;} int main() { cout &lt;&lt; \"ret = \" &lt;&lt; func(20, 20) &lt;&lt; endl; cout &lt;&lt; \"ret = \" &lt;&lt; func(100) &lt;&lt; endl; system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;3.2 函数占位参数&nbsp;C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置&nbsp;语法： 返回值类型 函数名 (数据类型){}&nbsp;在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术&nbsp;示例：xxxxxxxxxx//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) { cout &lt;&lt; \"this is func\" &lt;&lt; endl;} int main() { func(10,10); //占位参数必须填补 system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;3.3 函数重载3.3.1 函数重载概述&nbsp;作用：函数名可以相同，提高复用性&nbsp;函数重载满足条件：同一个作用域下函数名称相同函数参数类型不同 或者 个数不同 或者 顺序不同&nbsp;注意: 函数的返回值不可以作为函数重载的条件&nbsp;示例：xxxxxxxxxx//函数重载需要函数都在同一个作用域下void func(){ cout &lt;&lt; \"func 的调用！\" &lt;&lt; endl;}void func(int a){ cout &lt;&lt; \"func (int a) 的调用！\" &lt;&lt; endl;}void func(double a){ cout &lt;&lt; \"func (double a)的调用！\" &lt;&lt; endl;}void func(int a ,double b){ cout &lt;&lt; \"func (int a ,double b) 的调用！\" &lt;&lt; endl;}void func(double a ,int b){ cout &lt;&lt; \"func (double a ,int b)的调用！\" &lt;&lt; endl;} //函数返回值不可以作为函数重载条件//int func(double a, int b)//{// cout &lt;&lt; \"func (double a ,int b)的调用！\" &lt;&lt; endl;//} int main() { func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.2 函数重载注意事项&nbsp;引用作为重载条件函数重载碰到函数默认参数&nbsp;&nbsp;示例：xxxxxxxxxx//函数重载注意事项//1、引用作为重载条件 void func(int &amp;a){ cout &lt;&lt; \"func (int &amp;a) 调用 \" &lt;&lt; endl;} void func(const int &amp;a){ cout &lt;&lt; \"func (const int &amp;a) 调用 \" &lt;&lt; endl;} //2、函数重载碰到函数默认参数 void func2(int a, int b = 10){ cout &lt;&lt; \"func2(int a, int b = 10) 调用\" &lt;&lt; endl;} void func2(int a){ cout &lt;&lt; \"func2(int a) 调用\" &lt;&lt; endl;} int main() { int a = 10; func(a); //调用无const func(10);//调用有const //func2(10); //碰到默认参数产生歧义，需要避免 system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;4 类和对象&nbsp;C++面向对象的三大特性为：==封装、继承、多态==&nbsp;C++认为==万事万物都皆为对象==，对象上有其属性和行为&nbsp;例如： 人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌... 车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调... 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一封装的意义：将属性和行为作为一个整体，表现生活中的事物将属性和行为加以权限控制&nbsp;封装意义一： 在设计类的时候，属性和行为写在一起，表现事物语法： class 类名{ 访问权限： 属性 / 行为 };&nbsp;示例1：设计一个圆类，求圆的周长示例代码：xxxxxxxxxx//圆周率const double PI = 3.14; //1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物 //封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle{public: &nbsp;//访问权限 公共的权限 //属性 int m_r;//半径 //行为 //获取到圆的周长 double calculateZC() { //2 * pi * r //获取圆的周长 return &nbsp;2 * PI * m_r; }}; int main() { //通过圆类，创建圆的对象 // c1就是一个具体的圆 Circle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作 //2 * pi * 10 = = 62.8 cout &lt;&lt; \"圆的周长为： \" &lt;&lt; c1.calculateZC() &lt;&lt; endl; system(\"pause\"); return 0;}&nbsp;&nbsp;示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号&nbsp;&nbsp;示例2代码：xxxxxxxxxx//学生类class Student {public: void setName(string name) { m_name = name; } void setID(int id) { m_id = id; } void showStudent() { cout &lt;&lt; \"name:\" &lt;&lt; m_name &lt;&lt; \" ID:\" &lt;&lt; m_id &lt;&lt; endl; }public: string m_name; int m_id;}; int main() { Student stu; stu.setName(\"德玛西亚\"); stu.setID(250); stu.showStudent(); system(\"pause\"); return 0;} &nbsp;&nbsp;&nbsp;&nbsp;封装意义二：类在设计时，可以把属性和行为放在不同的权限下，加以控制访问权限有三种：&nbsp;public 公共权限 protected 保护权限private 私有权限&nbsp;&nbsp;&nbsp;示例：xxxxxxxxxx//三种权限//公共权限 public &nbsp; &nbsp; 类内可以访问 类外可以访问//保护权限 protected 类内可以访问 类外不可以访问//私有权限 private &nbsp; 类内可以访问 类外不可以访问 class Person{ //姓名 公共权限public: string m_Name; //汽车 保护权限protected: string m_Car; //银行卡密码 私有权限private: int m_Password; public: void func() { m_Name = \"张三\"; m_Car = \"拖拉机\"; m_Password = 123456; }}; int main() { Person p; p.m_Name = \"李四\"; //p.m_Car = \"奔驰\"; //保护权限类外访问不到 //p.m_Password = 123; //私有权限类外访问不到 system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;4.1.2 struct和class区别&nbsp;在C++中 struct和class唯一的区别就在于 默认的访问权限不同区别：struct 默认权限为公共class 默认权限为私有&nbsp;xxxxxxxxxxclass C1{ int &nbsp;m_A; //默认是私有权限}; struct C2{ int m_A; &nbsp;//默认是公共权限}; int main() { C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.3 成员属性设置为私有&nbsp;优点1：将所有成员属性设置为私有，可以自己控制读写权限优点2：对于写权限，我们可以检测数据的有效性&nbsp;示例：xxxxxxxxxxclass Person {public: //姓名设置可读可写 void setName(string name) { m_Name = name; } string getName() { return m_Name; } //获取年龄 int getAge() { return m_Age; } //设置年龄 void setAge(int age) { if (age &lt; 0 || age &gt; 150) { cout &lt;&lt; \"你个老妖精!\" &lt;&lt; endl; return; } m_Age = age; } //情人设置为只写 void setLover(string lover) { m_Lover = lover; } private: string m_Name; //可读可写 姓名 int m_Age; //只读 年龄 string m_Lover; //只写 情人}; int main() { Person p; //姓名设置 p.setName(\"张三\"); cout &lt;&lt; \"姓名： \" &lt;&lt; p.getName() &lt;&lt; endl; //年龄设置 p.setAge(50); cout &lt;&lt; \"年龄： \" &lt;&lt; p.getAge() &lt;&lt; endl; //情人设置 p.setLover(\"苍井\"); //cout &lt;&lt; \"情人： \" &lt;&lt; p.m_Lover &lt;&lt; endl; //只写属性，不可以读取 system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;练习案例1：设计立方体类设计立方体类(Cube)求出立方体的面积和体积分别用全局函数和成员函数判断两个立方体是否相等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;练习案例2：点和圆的关系设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。&nbsp;&nbsp;&nbsp;&nbsp;4.2 对象的初始化和清理&nbsp;生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。&nbsp;&nbsp;4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 一个对象或者变量没有初始状态，对其使用后果是未知 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题&nbsp;c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。&nbsp;构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。&nbsp;&nbsp;构造函数语法：类名(){}构造函数，没有返回值也不写void函数名称与类名相同构造函数可以有参数，因此可以发生重载程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次&nbsp;&nbsp;析构函数语法： ~类名(){}析构函数，没有返回值也不写void函数名称与类名相同,在名称前加上符号 ~析构函数不可以有参数，因此不可以发生重载程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次&nbsp;&nbsp;xxxxxxxxxxclass Person{public: //构造函数 Person() { cout &lt;&lt; \"Person的构造函数调用\" &lt;&lt; endl; } //析构函数 ~Person() { cout &lt;&lt; \"Person的析构函数调用\" &lt;&lt; endl; } }; void test01(){ Person p;} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.2 构造函数的分类及调用两种分类方式： 按参数分为： 有参构造和无参构造 按类型分为： 普通构造和拷贝构造三种调用方式： 括号法 显示法 隐式转换法&nbsp;示例：xxxxxxxxxx//1、构造函数分类// 按照参数分类分为 有参和无参构造 &nbsp; 无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造 class Person {public: //无参（默认）构造函数 Person() { cout &lt;&lt; \"无参构造函数!\" &lt;&lt; endl; } //有参构造函数 Person(int a) { age = a; cout &lt;&lt; \"有参构造函数!\" &lt;&lt; endl; } //拷贝构造函数 Person(const Person&amp; p) { age = p.age; cout &lt;&lt; \"拷贝构造函数!\" &lt;&lt; endl; } //析构函数 ~Person() { cout &lt;&lt; \"析构函数!\" &lt;&lt; endl; }public: int age;}; //2、构造函数的调用//调用无参构造函数void test01() { Person p; //调用无参构造函数} //调用有参的构造函数void test02() { //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4);} int main() { test01(); //test02(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;4.2.3 拷贝构造函数调用时机&nbsp;C++中拷贝构造函数调用时机通常有三种情况使用一个已经创建完毕的对象来初始化一个新对象值传递的方式给函数参数传值以值方式返回局部对象&nbsp;示例：xxxxxxxxxxclass Person {public: Person() { cout &lt;&lt; \"无参构造函数!\" &lt;&lt; endl; mAge = 0; } Person(int age) { cout &lt;&lt; \"有参构造函数!\" &lt;&lt; endl; mAge = age; } Person(const Person&amp; p) { cout &lt;&lt; \"拷贝构造函数!\" &lt;&lt; endl; mAge = p.mAge; } //析构函数在释放内存之前调用 ~Person() { cout &lt;&lt; \"析构函数!\" &lt;&lt; endl; }public: int mAge;}; //1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() { Person man(100); //p对象已经创建完毕 Person newman(man); //调用拷贝构造函数 Person newman2 = man; //拷贝构造 //Person newman3; //newman3 = man; //不是调用拷贝构造函数，赋值操作} //2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) {}void test02() { Person p; //无参构造函数 doWork(p);} //3. 以值方式返回局部对象Person doWork2(){ Person p1; cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1;} void test03(){ Person p = doWork2(); cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;} int main() { //test01(); //test02(); test03(); system(\"pause\"); return 0;}&nbsp;&nbsp;4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数1．默认构造函数(无参，函数体为空)2．默认析构函数(无参，函数体为空)3．默认拷贝构造函数，对属性进行值拷贝&nbsp;构造函数调用规则如下：如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造如果用户定义拷贝构造函数，c++不会再提供其他构造函数&nbsp;示例：xxxxxxxxxxclass Person {public: //无参（默认）构造函数 Person() { cout &lt;&lt; \"无参构造函数!\" &lt;&lt; endl; } //有参构造函数 Person(int a) { age = a; cout &lt;&lt; \"有参构造函数!\" &lt;&lt; endl; } //拷贝构造函数 Person(const Person&amp; p) { age = p.age; cout &lt;&lt; \"拷贝构造函数!\" &lt;&lt; endl; } //析构函数 ~Person() { cout &lt;&lt; \"析构函数!\" &lt;&lt; endl; }public: int age;}; void test01(){ Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout &lt;&lt; \"p2的年龄为： \" &lt;&lt; p2.age &lt;&lt; endl;} void test02(){ //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; //此时如果用户自己没有提供默认构造，会出错 Person p2(10); //用户提供的有参 Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 //如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; //此时如果用户自己没有提供默认构造，会出错 Person p5(10); //此时如果用户自己没有提供有参，会出错 Person p6(p5); //用户自己提供拷贝构造} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;4.2.5 深拷贝与浅拷贝&nbsp;深浅拷贝是面试经典问题，也是常见的一个坑&nbsp;浅拷贝：简单的赋值拷贝操作&nbsp;深拷贝：在堆区重新申请空间，进行拷贝操作&nbsp;示例：xxxxxxxxxxclass Person {public: //无参（默认）构造函数 Person() { cout &lt;&lt; \"无参构造函数!\" &lt;&lt; endl; } //有参构造函数 Person(int age ,int height) { cout &lt;&lt; \"有参构造函数!\" &lt;&lt; endl; m_age = age; m_height = new int(height); } //拷贝构造函数 &nbsp; Person(const Person&amp; p) { cout &lt;&lt; \"拷贝构造函数!\" &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); } //析构函数 ~Person() { cout &lt;&lt; \"析构函数!\" &lt;&lt; endl; if (m_height != NULL) { delete m_height; } }public: int m_age; int* m_height;}; void test01(){ Person p1(18, 180); Person p2(p1); cout &lt;&lt; \"p1的年龄： \" &lt;&lt; p1.m_age &lt;&lt; \" 身高： \" &lt;&lt; *p1.m_height &lt;&lt; endl; cout &lt;&lt; \"p2的年龄： \" &lt;&lt; p2.m_age &lt;&lt; \" 身高： \" &lt;&lt; *p2.m_height &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题&nbsp;&nbsp;&nbsp;&nbsp;4.2.6 初始化列表&nbsp;作用：C++提供了初始化列表语法，用来初始化属性&nbsp;语法：构造函数()：属性1(值1),属性2（值2）... {}&nbsp;示例：xxxxxxxxxxclass Person {public: ////传统方式初始化 //Person(int a, int b, int c) { // m_A = a; // m_B = b; // m_C = c; //} //初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {} void PrintPerson() { cout &lt;&lt; \"mA:\" &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; \"mB:\" &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; \"mC:\" &lt;&lt; m_C &lt;&lt; endl; }private: int m_A; int m_B; int m_C;}; int main() { Person p(1, 2, 3); p.PrintPerson(); system(\"pause\"); return 0;}&nbsp;&nbsp;4.2.7 类对象作为类成员&nbsp;C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员&nbsp;例如：xxxxxxxxxxclass A {}class B{ &nbsp; &nbsp;A a；}&nbsp;B类中有对象A作为成员，A为对象成员&nbsp;那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？&nbsp;示例：xxxxxxxxxxclass Phone{public: Phone(string name) { m_PhoneName = name; cout &lt;&lt; \"Phone构造\" &lt;&lt; endl; } ~Phone() { cout &lt;&lt; \"Phone析构\" &lt;&lt; endl; } string m_PhoneName; }; class Person{public: //初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) { cout &lt;&lt; \"Person构造\" &lt;&lt; endl; } ~Person() { cout &lt;&lt; \"Person析构\" &lt;&lt; endl; } void playGame() { cout &lt;&lt; m_Name &lt;&lt; \" 使用\" &lt;&lt; m_Phone.m_PhoneName &lt;&lt; \" 牌手机! \" &lt;&lt; endl; } string m_Name; Phone m_Phone; };void test01(){ //当类中成员是其他类对象时，我们称该成员为 对象成员 //构造的顺序是 ：先调用对象成员的构造，再调用本类构造 //析构顺序与构造相反 Person p(\"张三\" , \"苹果X\"); p.playGame(); } int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员静态成员分为：&nbsp;静态成员变量所有对象共享同一份数据在编译阶段分配内存类内声明，类外初始化静态成员函数所有对象共享同一个函数静态成员函数只能访问静态成员变量&nbsp;&nbsp;&nbsp;示例1 ：静态成员变量xxxxxxxxxxclass Person{ public: static int m_A; //静态成员变量 //静态成员变量特点： //1 在编译阶段分配内存 //2 类内声明，类外初始化 //3 所有对象共享同一份数据 private: static int m_B; //静态成员变量也是有访问权限的};int Person::m_A = 10;int Person::m_B = 10; void test01(){ //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.m_A = 100; cout &lt;&lt; \"p1.m_A = \" &lt;&lt; p1.m_A &lt;&lt; endl; Person p2; p2.m_A = 200; cout &lt;&lt; \"p1.m_A = \" &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据 cout &lt;&lt; \"p2.m_A = \" &lt;&lt; p2.m_A &lt;&lt; endl; //2、通过类名 cout &lt;&lt; \"m_A = \" &lt;&lt; Person::m_A &lt;&lt; endl; //cout &lt;&lt; \"m_B = \" &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到} int main() { test01(); system(\"pause\"); return 0;}&nbsp;示例2：静态成员函数xxxxxxxxxxclass Person{ public: //静态成员函数特点： //1 程序共享一个函数 //2 静态成员函数只能访问静态成员变量 static void func() { cout &lt;&lt; \"func调用\" &lt;&lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 } static int m_A; //静态成员变量 int m_B; // private: //静态成员函数也是有访问权限的 static void func2() { cout &lt;&lt; \"func2调用\" &lt;&lt; endl; }};int Person::m_A = 10; void test01(){ //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.func(); //2、通过类名 Person::func(); //Person::func2(); //私有权限访问不到} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;4.3 C++对象模型和this指针&nbsp;4.3.1 成员变量和成员函数分开存储&nbsp;在C++中，类内的成员变量和成员函数分开存储只有非静态成员变量才属于类的对象上&nbsp;xxxxxxxxxxclass Person {public: Person() { mA = 0; } //非静态成员变量占对象空间 int mA; //静态成员变量不占对象空间 static int mB; //函数也不占对象空间，所有函数共享一个函数实例 void func() { cout &lt;&lt; \"mA:\" &lt;&lt; this-&gt;mA &lt;&lt; endl; } //静态成员函数也不占对象空间 static void sfunc() { }}; int main() { cout &lt;&lt; sizeof(Person) &lt;&lt; endl; system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码那么问题是：这一块代码是如何区分那个对象调用自己的呢？&nbsp;c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象&nbsp;this指针是隐含每一个非静态成员函数内的一种指针this指针不需要定义，直接使用即可&nbsp;this指针的用途：当形参和成员变量同名时，可用this指针来区分在类的非静态成员函数中返回对象本身，可使用return *thisxxxxxxxxxxclass Person{public: Person(int age) { //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age; } Person&amp; PersonAddPerson(Person p) { this-&gt;age += p.age; //返回对象本身 return *this; } int age;}; void test01(){ Person p1(10); cout &lt;&lt; \"p1.age = \" &lt;&lt; p1.age &lt;&lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout &lt;&lt; \"p2.age = \" &lt;&lt; p2.age &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;4.3.3 空指针访问成员函数&nbsp;C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针&nbsp;如果用到this指针，需要加以判断保证代码的健壮性&nbsp;示例：xxxxxxxxxx//空指针访问成员函数class Person {public: void ShowClassName() { cout &lt;&lt; \"我是Person类!\" &lt;&lt; endl; } void ShowPerson() { if (this == NULL) { return; } cout &lt;&lt; mAge &lt;&lt; endl; } public: int mAge;}; void test01(){ Person * p = NULL; p-&gt;ShowClassName(); //空指针，可以调用成员函数 p-&gt;ShowPerson(); &nbsp;//但是如果成员函数中用到了this指针，就不可以了} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;4.3.4 const修饰成员函数&nbsp;常函数：成员函数后加const后我们称为这个函数为常函数常函数内不可以修改成员属性成员属性声明时加关键字mutable后，在常函数中依然可以修改&nbsp;常对象：声明对象前加const称该对象为常对象常对象只能调用常函数&nbsp;&nbsp;&nbsp;示例：xxxxxxxxxxclass Person {public: Person() { m_A = 0; m_B = 0; } //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const { //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100; } void MyFunc() const { //mA = 10000; } public: int m_A; mutable int m_B; //可修改 可变的}; //const修饰对象 常对象void test01() { const Person person; //常量对象 &nbsp; cout &lt;&lt; person.m_A &lt;&lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 person.m_B = 100; //但是常对象可以修改mutable修饰成员变量 //常对象访问成员函数 person.MyFunc(); //常对象不能调用const的函数 } int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;4.4 友元&nbsp;生活中你的家有客厅(Public)，有你的卧室(Private)客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去但是呢，你也可以允许你的好闺蜜好基友进去。&nbsp;在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术&nbsp;友元的目的就是让一个函数或者类 访问另一个类中私有成员&nbsp;友元的关键字为 ==friend==&nbsp;友元的三种实现全局函数做友元类做友元成员函数做友元&nbsp;&nbsp;4.4.1 全局函数做友元xxxxxxxxxxclass Building{ //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building); public: Building() { this-&gt;m_SittingRoom = \"客厅\"; this-&gt;m_BedRoom = \"卧室\"; } public: string m_SittingRoom; //客厅 private: string m_BedRoom; //卧室}; void goodGay(Building * building){ cout &lt;&lt; \"好基友正在访问： \" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; \"好基友正在访问： \" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;} void test01(){ Building b; goodGay(&amp;b);} int main(){ test01(); system(\"pause\"); return 0;}&nbsp;4.4.2 类做友元&nbsp;xxxxxxxxxxclass Building;class goodGay{public: goodGay(); void visit(); private: Building *building;}; class Building{ //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay; public: Building(); public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室}; Building::Building(){ this-&gt;m_SittingRoom = \"客厅\"; this-&gt;m_BedRoom = \"卧室\";} goodGay::goodGay(){ building = new Building;} void goodGay::visit(){ cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;} void test01(){ goodGay gg; gg.visit(); } int main(){ test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;4.4.3 成员函数做友元&nbsp;xxxxxxxxxx class Building;class goodGay{public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 void visit2(); private: Building *building;}; class Building{ //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit(); public: Building(); public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室}; Building::Building(){ this-&gt;m_SittingRoom = \"客厅\"; this-&gt;m_BedRoom = \"卧室\";} goodGay::goodGay(){ building = new Building;} void goodGay::visit(){ cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;} void goodGay::visit2(){ cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;} void test01(){ goodGay &nbsp;gg; gg.visit(); } int main(){ &nbsp; &nbsp; test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;4.5 运算符重载&nbsp;运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型&nbsp;4.5.1 加号运算符重载&nbsp;作用：实现两个自定义数据类型相加的运算&nbsp;xxxxxxxxxxclass Person {public: Person() {}; Person(int a, int b) { this-&gt;m_A = a; this-&gt;m_B = b; } //成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) { Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; } public: int m_A; int m_B;}; //全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) {// Person temp(0, 0);// temp.m_A = p1.m_A + p2.m_A;// temp.m_B = p1.m_B + p2.m_B;// return temp;//} //运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) &nbsp;{ Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp;} void test() { Person p1(10, 10); Person p2(20, 20); //成员函数方式 Person p3 = p2 + p1; &nbsp;//相当于 p2.operaor+(p1) cout &lt;&lt; \"mA:\" &lt;&lt; p3.m_A &lt;&lt; \" mB:\" &lt;&lt; p3.m_B &lt;&lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) cout &lt;&lt; \"mA:\" &lt;&lt; p4.m_A &lt;&lt; \" mB:\" &lt;&lt; p4.m_B &lt;&lt; endl; } int main() { test(); system(\"pause\"); return 0;}&nbsp;总结1：对于内置的数据类型的表达式的的运算符是不可能改变的总结2：不要滥用运算符重载&nbsp;&nbsp;&nbsp;4.5.2 左移运算符重载&nbsp;作用：可以输出自定义数据类型&nbsp;xxxxxxxxxxclass Person { friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p); public: Person(int a, int b) { this-&gt;m_A = a; this-&gt;m_B = b; } //成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p){ //} private: int m_A; int m_B;}; //全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) { out &lt;&lt; \"a:\" &lt;&lt; p.m_A &lt;&lt; \" b:\" &lt;&lt; p.m_B; return out;} void test() { Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; \"hello world\" &lt;&lt; endl; //链式编程} int main() { test(); system(\"pause\"); return 0;}&nbsp;总结：重载左移运算符配合友元可以实现输出自定义数据类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.3 递增运算符重载&nbsp;作用： 通过重载递增运算符，实现自己的整型数据&nbsp;xxxxxxxxxx class MyInteger { friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint); public: MyInteger() { m_Num = 0; } //前置++ MyInteger&amp; operator++() { //先++ m_Num++; //再返回 return *this; } //后置++ MyInteger operator++(int) { //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp; } private: int m_Num;}; ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) { out &lt;&lt; myint.m_Num; return out;} //前置++ 先++ 再返回void test01() { MyInteger myInt; cout &lt;&lt; ++myInt &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;} //后置++ 先返回 再++void test02() { MyInteger myInt; cout &lt;&lt; myInt++ &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;} int main() { test01(); //test02(); system(\"pause\"); return 0;}&nbsp;总结： 前置递增返回引用，后置递增返回值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5.4 赋值运算符重载&nbsp;c++编译器至少给一个类添加4个函数默认构造函数(无参，函数体为空)默认析构函数(无参，函数体为空)默认拷贝构造函数，对属性进行值拷贝赋值运算符 operator=, 对属性进行值拷贝&nbsp;&nbsp;如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题&nbsp;&nbsp;示例：xxxxxxxxxxclass Person{public: Person(int age) { //将年龄数据开辟到堆区 m_Age = new int(age); } //重载赋值运算符 Person&amp; operator=(Person &amp;p) { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this; } ~Person() { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } } //年龄的指针 int *m_Age; }; void test01(){ Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作 cout &lt;&lt; \"p1的年龄为：\" &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; \"p2的年龄为：\" &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; \"p3的年龄为：\" &lt;&lt; *p3.m_Age &lt;&lt; endl;} int main() { test01(); //int a = 10; //int b = 20; //int c = 30; //c = b = a; //cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; //cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;4.5.5 关系运算符重载&nbsp;作用：重载关系运算符，可以让两个自定义类型对象进行对比操作&nbsp;示例：xxxxxxxxxxclass Person{public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; }; bool operator==(Person &amp; p) { if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return true; } else { return false; } } bool operator!=(Person &amp; p) { if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return false; } else { return true; } } string m_Name; int m_Age;}; void test01(){ //int a = 0; //int b = 0; Person a(\"孙悟空\", 18); Person b(\"孙悟空\", 18); if (a == b) { cout &lt;&lt; \"a和b相等\" &lt;&lt; endl; } else { cout &lt;&lt; \"a和b不相等\" &lt;&lt; endl; } if (a != b) { cout &lt;&lt; \"a和b不相等\" &lt;&lt; endl; } else { cout &lt;&lt; \"a和b相等\" &lt;&lt; endl; }} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;4.5.6 函数调用运算符重载&nbsp;函数调用运算符 () 也可以重载由于重载后使用的方式非常像函数的调用，因此称为仿函数仿函数没有固定写法，非常灵活&nbsp;示例：xxxxxxxxxxclass MyPrint{public: void operator()(string text) { cout &lt;&lt; text &lt;&lt; endl; } };void test01(){ //重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(\"hello world\");} class MyAdd{public: int operator()(int v1, int v2) { return v1 + v2; }}; void test02(){ MyAdd add; int ret = add(10, 10); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; //匿名对象调用 &nbsp; cout &lt;&lt; \"MyAdd()(100,100) = \" &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;} int main() { test01(); test02(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;4.6 继承继承是面向对象三大特性之一有些类与类之间存在特殊的关系，例如下图中：我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。这个时候我们就可以考虑利用继承的技术，减少重复代码&nbsp;4.6.1 继承的基本语法&nbsp;例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处&nbsp;普通实现：xxxxxxxxxx//Java页面class Java {public: void header() { cout &lt;&lt; \"首页、公开课、登录、注册...（公共头部）\" &lt;&lt; endl; } void footer() { cout &lt;&lt; \"帮助中心、交流合作、站内地图...(公共底部)\" &lt;&lt; endl; } void left() { cout &lt;&lt; \"Java,Python,C++...(公共分类列表)\" &lt;&lt; endl; } void content() { cout &lt;&lt; \"JAVA学科视频\" &lt;&lt; endl; }};//Python页面class Python{public: void header() { cout &lt;&lt; \"首页、公开课、登录、注册...（公共头部）\" &lt;&lt; endl; } void footer() { cout &lt;&lt; \"帮助中心、交流合作、站内地图...(公共底部)\" &lt;&lt; endl; } void left() { cout &lt;&lt; \"Java,Python,C++...(公共分类列表)\" &lt;&lt; endl; } void content() { cout &lt;&lt; \"Python学科视频\" &lt;&lt; endl; }};//C++页面class CPP {public: void header() { cout &lt;&lt; \"首页、公开课、登录、注册...（公共头部）\" &lt;&lt; endl; } void footer() { cout &lt;&lt; \"帮助中心、交流合作、站内地图...(公共底部)\" &lt;&lt; endl; } void left() { cout &lt;&lt; \"Java,Python,C++...(公共分类列表)\" &lt;&lt; endl; } void content() { cout &lt;&lt; \"C++学科视频\" &lt;&lt; endl; }}; void test01(){ //Java页面 cout &lt;&lt; \"Java下载视频页面如下： \" &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; //Python页面 cout &lt;&lt; \"Python下载视频页面如下： \" &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; //C++页面 cout &lt;&lt; \"C++下载视频页面如下： \" &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(\"pause\"); return 0;}&nbsp;继承实现：xxxxxxxxxx//公共页面class BasePage{public: void header() { cout &lt;&lt; \"首页、公开课、登录、注册...（公共头部）\" &lt;&lt; endl; } void footer() { cout &lt;&lt; \"帮助中心、交流合作、站内地图...(公共底部)\" &lt;&lt; endl; } void left() { cout &lt;&lt; \"Java,Python,C++...(公共分类列表)\" &lt;&lt; endl; } }; //Java页面class Java : public BasePage{public: void content() { cout &lt;&lt; \"JAVA学科视频\" &lt;&lt; endl; }};//Python页面class Python : public BasePage{public: void content() { cout &lt;&lt; \"Python学科视频\" &lt;&lt; endl; }};//C++页面class CPP : public BasePage{public: void content() { cout &lt;&lt; \"C++学科视频\" &lt;&lt; endl; }}; void test01(){ //Java页面 cout &lt;&lt; \"Java下载视频页面如下： \" &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; //Python页面 cout &lt;&lt; \"Python下载视频页面如下： \" &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; //C++页面 cout &lt;&lt; \"C++下载视频页面如下： \" &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(\"pause\"); return 0;}&nbsp;总结：继承的好处：==可以减少重复的代码==class A : public B; A 类称为子类 或 派生类B 类称为父类 或 基类&nbsp;派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员。从基类继承过过来的表现其共性，而新增的成员体现了其个性。&nbsp;&nbsp;&nbsp;&nbsp;4.6.2 继承方式&nbsp;继承的语法：class 子类 : 继承方式 父类&nbsp;继承方式一共有三种：公共继承保护继承私有继承&nbsp;&nbsp;&nbsp;&nbsp;示例：xxxxxxxxxxclass Base1{public: int m_A;protected: int m_B;private: int m_C;}; //公共继承class Son1 :public Base1{public: void func() { m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问 }}; void myClass(){ Son1 s1; s1.m_A; //其他类只能访问到公共权限} //保护继承class Base2{public: int m_A;protected: int m_B;private: int m_C;};class Son2:protected Base2{public: void func() { m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问 }};void myClass2(){ Son2 s; //s.m_A; //不可访问} //私有继承class Base3{public: int m_A;protected: int m_B;private: int m_C;};class Son3:private Base3{public: void func() { m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问 }};class GrandSon3 :public Son3{public: void func() { //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C; }};&nbsp;&nbsp;&nbsp;&nbsp;4.6.3 继承中的对象模型&nbsp;问题：从父类继承过来的成员，哪些属于子类对象中？&nbsp;示例：xxxxxxxxxxclass Base{public: int m_A;protected: int m_B;private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去}; //公共继承class Son :public Base{public: int m_D;}; void test01(){ cout &lt;&lt; \"sizeof Son = \" &lt;&lt; sizeof(Son) &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;利用工具查看：&nbsp;&nbsp;打开工具窗口后，定位到当前CPP文件的盘符然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名&nbsp;效果如下图：&nbsp;&nbsp;结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.6.4 继承中构造和析构顺序&nbsp;子类继承父类后，当创建子类对象，也会调用父类的构造函数&nbsp;问题：父类和子类的构造和析构顺序是谁先谁后？&nbsp;示例：xxxxxxxxxxclass Base {public: Base() { cout &lt;&lt; \"Base构造函数!\" &lt;&lt; endl; } ~Base() { cout &lt;&lt; \"Base析构函数!\" &lt;&lt; endl; }}; class Son : public Base{public: Son() { cout &lt;&lt; \"Son构造函数!\" &lt;&lt; endl; } ~Son() { cout &lt;&lt; \"Son析构函数!\" &lt;&lt; endl; } }; void test01(){ //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s;} int main() { test01(); system(\"pause\"); return 0;}&nbsp;总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.6.5 继承同名成员处理方式&nbsp;问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？&nbsp;访问子类同名成员 直接访问即可访问父类同名成员 需要加作用域&nbsp;示例：xxxxxxxxxxclass Base {public: Base() { m_A = 100; } void func() { cout &lt;&lt; \"Base - func()调用\" &lt;&lt; endl; } void func(int a) { cout &lt;&lt; \"Base - func(int a)调用\" &lt;&lt; endl; } public: int m_A;}; class Son : public Base {public: Son() { m_A = 200; } //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() { cout &lt;&lt; \"Son - func()调用\" &lt;&lt; endl; }public: int m_A;}; void test01(){ Son s; cout &lt;&lt; \"Son下的m_A = \" &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; \"Base下的m_A = \" &lt;&lt; s.Base::m_A &lt;&lt; endl; s.func(); s.Base::func(); s.Base::func(10); }int main() { test01(); system(\"pause\"); return EXIT_SUCCESS;}总结：子类对象可以直接访问到子类中同名成员子类对象加作用域可以访问到父类同名成员当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.6.6 继承同名静态成员处理方式&nbsp;问题：继承中同名的静态成员在子类对象上如何进行访问？&nbsp;静态成员和非静态成员出现同名，处理方式一致&nbsp;访问子类同名成员 直接访问即可访问父类同名成员 需要加作用域&nbsp;示例：xxxxxxxxxxclass Base {public: static void func() { cout &lt;&lt; \"Base - static void func()\" &lt;&lt; endl; } static void func(int a) { cout &lt;&lt; \"Base - static void func(int a)\" &lt;&lt; endl; } static int m_A;}; int Base::m_A = 100; class Son : public Base {public: static void func() { cout &lt;&lt; \"Son - static void func()\" &lt;&lt; endl; } static int m_A;}; int Son::m_A = 200; //同名成员属性void test01(){ //通过对象访问 cout &lt;&lt; \"通过对象访问： \" &lt;&lt; endl; Son s; cout &lt;&lt; \"Son 下 m_A = \" &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; \"Base 下 m_A = \" &lt;&lt; s.Base::m_A &lt;&lt; endl; //通过类名访问 cout &lt;&lt; \"通过类名访问： \" &lt;&lt; endl; cout &lt;&lt; \"Son 下 m_A = \" &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; \"Base 下 m_A = \" &lt;&lt; Son::Base::m_A &lt;&lt; endl;} //同名成员函数void test02(){ //通过对象访问 cout &lt;&lt; \"通过对象访问： \" &lt;&lt; endl; Son s; s.func(); s.Base::func(); cout &lt;&lt; \"通过类名访问： \" &lt;&lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100);}int main() { &nbsp; &nbsp; //test01(); test02(); system(\"pause\"); return 0;}总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.6.7 多继承语法&nbsp;C++允许一个类继承多个类&nbsp;语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2...&nbsp;多继承可能会引发父类中有同名成员出现，需要加作用域区分&nbsp;C++实际开发中不建议用多继承&nbsp;&nbsp;&nbsp;示例：xxxxxxxxxxclass Base1 {public: Base1() { m_A = 100; }public: int m_A;}; class Base2 {public: Base2() { m_A = 200; &nbsp;//开始是m_B 不会出问题，但是改为mA就会出现不明确 }public: int m_A;}; //语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 {public: Son() { m_C = 300; m_D = 400; }public: int m_C; int m_D;}; //多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01(){ Son s; cout &lt;&lt; \"sizeof Son = \" &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}&nbsp;总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域虚基类指针 vbptr virtual base pointer&nbsp;&nbsp;&nbsp;&nbsp;4.6.8 菱形继承&nbsp;菱形继承概念： 两个派生类继承同一个基类 又有某个类同时继承者两个派生类 这种继承被称为菱形继承，或者钻石继承&nbsp;典型的菱形继承案例：&nbsp;&nbsp;菱形继承问题：&nbsp;羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。&nbsp;示例：xxxxxxxxxxclass Animal{public: int m_Age;}; //继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal {};class Tuo &nbsp; : virtual public Animal {};class SheepTuo : public Sheep, public Tuo {}; void test01(){ SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; \"st.Sheep::m_Age = \" &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; \"st.Tuo::m_Age = \" &lt;&lt; &nbsp;st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; \"st.m_Age = \" &lt;&lt; st.m_Age &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}&nbsp;总结：菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义利用虚继承可以解决菱形继承问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.7 多态4.7.1 多态的基本概念&nbsp;多态是C++面向对象三大特性之一多态分为两类静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名动态多态: 派生类和虚函数实现运行时多态&nbsp;静态多态和动态多态区别：静态多态的函数地址早绑定 - 编译阶段确定函数地址动态多态的函数地址晚绑定 - 运行阶段确定函数地址&nbsp;下面通过案例进行讲解多态&nbsp;xxxxxxxxxxclass Animal{public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() { cout &lt;&lt; \"动物在说话\" &lt;&lt; endl; }}; class Cat :public Animal{public: void speak() { cout &lt;&lt; \"小猫在说话\" &lt;&lt; endl; }}; class Dog :public Animal{public: void speak() { cout &lt;&lt; \"小狗在说话\" &lt;&lt; endl; } };//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编 void DoSpeak(Animal &amp; animal){ animal.speak();}////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象 void test01(){ Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog);} int main() { test01(); system(\"pause\"); return 0;}总结：多态满足条件有继承关系子类重写父类中的虚函数多态使用条件父类指针或引用指向子类对象重写：函数返回值类型 函数名 参数列表 完全一致称为重写&nbsp;&nbsp;&nbsp;&nbsp;4.7.2 多态案例一-计算器类&nbsp;案例描述：分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类&nbsp;多态的优点：代码组织结构清晰可读性强利于前期和后期的扩展以及维护&nbsp;示例：xxxxxxxxxx//普通实现class Calculator {public: int getResult(string oper) { if (oper == \"+\") { return m_Num1 + m_Num2; } else if (oper == \"-\") { return m_Num1 - m_Num2; } else if (oper == \"*\") { return m_Num1 * m_Num2; } //如果要提供新的运算，需要修改源码 }public: int m_Num1; int m_Num2;}; void test01(){ //普通实现测试 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; \" + \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"+\") &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; \" - \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"-\") &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; \" * \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"*\") &lt;&lt; endl;} //多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator{public : virtual int getResult() { return 0; } int m_Num1; int m_Num2;}; //加法计算器class AddCalculator :public AbstractCalculator{public: int getResult() { return m_Num1 + m_Num2; }}; //减法计算器class SubCalculator :public AbstractCalculator{public: int getResult() { return m_Num1 - m_Num2; }}; //乘法计算器class MulCalculator :public AbstractCalculator{public: int getResult() { return m_Num1 * m_Num2; }}; void test02(){ //创建加法计算器 AbstractCalculator *abc = new AddCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" + \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; &nbsp;//用完了记得销毁 //创建减法计算器 abc = new SubCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" - \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; &nbsp; //创建乘法计算器 abc = new MulCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" * \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc;} int main() { //test01(); test02(); system(\"pause\"); return 0;}总结：C++开发提倡利用多态设计程序架构，因为多态优点很多&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.7.3 纯虚函数和抽象类&nbsp;在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容&nbsp;因此可以将虚函数改为纯虚函数&nbsp;纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;&nbsp;当类中有了纯虚函数，这个类也称为==抽象类==&nbsp;抽象类特点：无法实例化对象子类必须重写抽象类中的纯虚函数，否则也属于抽象类&nbsp;&nbsp;示例：xxxxxxxxxxclass Base{public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;}; class Son :public Base{public: virtual void func() { cout &lt;&lt; \"func调用\" &lt;&lt; endl; };}; void test01(){ Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 base = new Son; base-&gt;func(); delete base;//记得销毁} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.7.4 多态案例二-制作饮品案例描述：制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料&nbsp;利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶&nbsp;&nbsp;示例：xxxxxxxxxx//抽象制作饮品class AbstractDrinking {public: //烧水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //规定流程 void MakeDrink() { Boil(); Brew(); PourInCup(); PutSomething(); }}; //制作咖啡class Coffee : public AbstractDrinking {public: //烧水 virtual void Boil() { cout &lt;&lt; \"煮农夫山泉!\" &lt;&lt; endl; } //冲泡 virtual void Brew() { cout &lt;&lt; \"冲泡咖啡!\" &lt;&lt; endl; } //倒入杯中 virtual void PourInCup() { cout &lt;&lt; \"将咖啡倒入杯中!\" &lt;&lt; endl; } //加入辅料 virtual void PutSomething() { cout &lt;&lt; \"加入牛奶!\" &lt;&lt; endl; }}; //制作茶水class Tea : public AbstractDrinking {public: //烧水 virtual void Boil() { cout &lt;&lt; \"煮自来水!\" &lt;&lt; endl; } //冲泡 virtual void Brew() { cout &lt;&lt; \"冲泡茶叶!\" &lt;&lt; endl; } //倒入杯中 virtual void PourInCup() { cout &lt;&lt; \"将茶水倒入杯中!\" &lt;&lt; endl; } //加入辅料 virtual void PutSomething() { cout &lt;&lt; \"加入枸杞!\" &lt;&lt; endl; }}; //业务函数void DoWork(AbstractDrinking* drink) { drink-&gt;MakeDrink(); delete drink;} void test01() { DoWork(new Coffee); cout &lt;&lt; \"--------------\" &lt;&lt; endl; DoWork(new Tea);} int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.7.5 虚析构和纯虚析构&nbsp;多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码&nbsp;解决方式：将父类中的析构函数改为虚析构或者纯虚析构&nbsp;虚析构和纯虚析构共性：可以解决父类指针释放子类对象都需要有具体的函数实现虚析构和纯虚析构区别：如果是纯虚析构，该类属于抽象类，无法实例化对象&nbsp;虚析构语法：virtual ~类名(){}纯虚析构语法：virtual ~类名() = 0;类名::~类名(){}&nbsp;示例：xxxxxxxxxxclass Animal {public: Animal() { cout &lt;&lt; \"Animal 构造函数调用！\" &lt;&lt; endl; } virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //{ // cout &lt;&lt; \"Animal虚析构函数调用！\" &lt;&lt; endl; //} virtual ~Animal() = 0;}; Animal::~Animal(){ cout &lt;&lt; \"Animal 纯虚析构函数调用！\" &lt;&lt; endl;} //和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。 class Cat : public Animal {public: Cat(string name) { cout &lt;&lt; \"Cat构造函数调用！\" &lt;&lt; endl; m_Name = new string(name); } virtual void Speak() { cout &lt;&lt; *m_Name &lt;&lt; &nbsp;\"小猫在说话!\" &lt;&lt; endl; } ~Cat() { cout &lt;&lt; \"Cat析构函数调用!\" &lt;&lt; endl; if (this-&gt;m_Name != NULL) { delete m_Name; m_Name = NULL; } } public: string *m_Name;}; void test01(){ Animal *animal = new Cat(\"Tom\"); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal;} int main() { test01(); system(\"pause\"); return 0;}&nbsp;总结： 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构xxxxxxxxxx3. 拥有纯虚析构函数的类也属于抽象类4. 纯虚析构也需要实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.7.6 多态案例三-电脑组装&nbsp;案例描述：&nbsp;电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口测试时组装三台不同的电脑进行工作&nbsp;&nbsp;示例：xxxxxxxxxx#include&lt;iostream&gt;using namespace std; //抽象CPU类class CPU{public: //抽象的计算函数 virtual void calculate() = 0;}; //抽象显卡类class VideoCard{public: //抽象的显示函数 virtual void display() = 0;}; //抽象内存条类class Memory{public: //抽象的存储函数 virtual void storage() = 0;}; //电脑类class Computer{public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) { m_cpu = cpu; m_vc = vc; m_mem = mem; } //提供工作的函数 void work() { //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); } //提供析构函数 释放3个电脑零件 ~Computer() { //释放CPU零件 if (m_cpu != NULL) { delete m_cpu; m_cpu = NULL; } //释放显卡零件 if (m_vc != NULL) { delete m_vc; m_vc = NULL; } //释放内存条零件 if (m_mem != NULL) { delete m_mem; m_mem = NULL; } } private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针}; //具体厂商//Intel厂商class IntelCPU :public CPU{public: virtual void calculate() { cout &lt;&lt; \"Intel的CPU开始计算了！\" &lt;&lt; endl; }}; class IntelVideoCard :public VideoCard{public: virtual void display() { cout &lt;&lt; \"Intel的显卡开始显示了！\" &lt;&lt; endl; }}; class IntelMemory :public Memory{public: virtual void storage() { cout &lt;&lt; \"Intel的内存条开始存储了！\" &lt;&lt; endl; }}; //Lenovo厂商class LenovoCPU :public CPU{public: virtual void calculate() { cout &lt;&lt; \"Lenovo的CPU开始计算了！\" &lt;&lt; endl; }}; class LenovoVideoCard :public VideoCard{public: virtual void display() { cout &lt;&lt; \"Lenovo的显卡开始显示了！\" &lt;&lt; endl; }}; class LenovoMemory :public Memory{public: virtual void storage() { cout &lt;&lt; \"Lenovo的内存条开始存储了！\" &lt;&lt; endl; }}; void test01(){ //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout &lt;&lt; \"第一台电脑开始工作：\" &lt;&lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; \"-----------------------\" &lt;&lt; endl; cout &lt;&lt; \"第二台电脑开始工作：\" &lt;&lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; \"-----------------------\" &lt;&lt; endl; cout &lt;&lt; \"第三台电脑开始工作：\" &lt;&lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 文件操作&nbsp;程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放通过文件可以将数据持久化C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==&nbsp;文件类型分为两种：文本文件 - 文件以文本的ASCII码形式存储在计算机中二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们&nbsp;操作文件的三大类:ofstream：写操作ifstream： 读操作fstream ： 读写操作&nbsp;5.1文本文件5.1.1写文件 写文件步骤如下：包含头文件 #include &lt;fstream&gt;创建流对象 ofstream ofs;打开文件ofs.open(&quot;文件路径&quot;,打开方式);写数据ofs &lt;&lt; &quot;写入的数据&quot;;关闭文件ofs.close();&nbsp;文件打开方式：打开方式解释ios::in为读文件而打开文件ios::out为写文件而打开文件ios::ate初始位置：文件尾ios::app追加方式写文件ios::trunc如果文件存在先删除，再创建ios::binary二进制方式注意： 文件打开方式可以配合使用，利用|操作符例如：用二进制方式写文件 ios::binary | ios:: out&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;fstream&gt; void test01(){ ofstream ofs; ofs.open(\"test.txt\", ios::out); ofs &lt;&lt; \"姓名：张三\" &lt;&lt; endl; ofs &lt;&lt; \"性别：男\" &lt;&lt; endl; ofs &lt;&lt; \"年龄：18\" &lt;&lt; endl; ofs.close();} int main() { test01(); system(\"pause\"); return 0;}总结：文件操作必须包含头文件 fstream读文件可以利用 ofstream ，或者fstream类打开文件时候需要指定操作文件的路径，以及打开方式利用&lt;&lt;可以向文件中写数据操作完毕，要关闭文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2读文件&nbsp;读文件与写文件步骤相似，但是读取方式相对于比较多&nbsp;读文件步骤如下：包含头文件 #include &lt;fstream&gt;创建流对象 ifstream ifs;打开文件并判断文件是否打开成功ifs.open(&quot;文件路径&quot;,打开方式);读数据四种方式读取关闭文件ifs.close();&nbsp;示例：xxxxxxxxxx#include &lt;fstream&gt;#include &lt;string&gt;void test01(){ ifstream ifs; ifs.open(\"test.txt\", ios::in); if (!ifs.is_open()) { cout &lt;&lt; \"文件打开失败\" &lt;&lt; endl; return; } //第一种方式 //char buf[1024] = { 0 }; //while (ifs &gt;&gt; buf) //{ // cout &lt;&lt; buf &lt;&lt; endl; //} //第二种 //char buf[1024] = { 0 }; //while (ifs.getline(buf,sizeof(buf))) //{ // cout &lt;&lt; buf &lt;&lt; endl; //} //第三种 //string buf; //while (getline(ifs, buf)) //{ // cout &lt;&lt; buf &lt;&lt; endl; //} char c; while ((c = ifs.get()) != EOF) { cout &lt;&lt; c; } ifs.close(); } int main() { test01(); system(\"pause\"); return 0;}总结：读文件可以利用 ifstream ，或者fstream类利用is_open函数可以判断文件是否打开成功close 关闭文件 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2 二进制文件以二进制的方式对文件进行读写操作打开方式要指定为 ==ios::binary==&nbsp;5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write函数原型 ：ostream&amp; write(const char * buffer,int len);参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数&nbsp;示例：xxxxxxxxxx#include &lt;fstream&gt;#include &lt;string&gt; class Person{public: char m_Name[64]; int m_Age;}; //二进制文件 写文件void test01(){ //1、包含头文件 //2、创建输出流对象 ofstream ofs(\"person.txt\", ios::out | ios::binary); //3、打开文件 //ofs.open(\"person.txt\", ios::out | ios::binary); Person p = {\"张三\" , 18}; //4、写文件 ofs.write((const char *)&amp;p, sizeof(p)); //5、关闭文件 ofs.close();} int main() { test01(); system(\"pause\"); return 0;}总结：文件输出流对象 可以通过write函数，以二进制方式写数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read函数原型：istream&amp; read(char *buffer,int len);参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数示例：xxxxxxxxxx#include &lt;fstream&gt;#include &lt;string&gt; class Person{public: char m_Name[64]; int m_Age;}; void test01(){ ifstream ifs(\"person.txt\", ios::in | ios::binary); if (!ifs.is_open()) { cout &lt;&lt; \"文件打开失败\" &lt;&lt; endl; } Person p; ifs.read((char *)&amp;p, sizeof(p)); cout &lt;&lt; \"姓名： \" &lt;&lt; p.m_Name &lt;&lt; \" 年龄： \" &lt;&lt; p.m_Age &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}&nbsp;文件输入流对象 可以通过read函数，以二进制方式读数据&nbsp; (function(){var e=document.body.parentElement,t=[],n=null,i=document.body.classList.contains(\"typora-export-collapse-outline\"),r=function(e,t,n){document.addEventListener(e,function(e){if(!e.defaultPrevented)for(var i=e.target;i&&i!=this;i=i.parentNode)if(i.matches(t)){!1===n.call(i,e)&&(e.preventDefault(),e.stopPropagation());break}},!1)};function o(){return e.scrollTop}r(\"click\",\".outline-expander\",function(e){var t=this.closest(\".outline-item-wrapper\").classList;return t.contains(\"outline-item-open\")?t.remove(\"outline-item-open\"):t.add(\"outline-item-open\"),d(),!1}),r(\"click\",\".outline-item\",function(e){var t=this.querySelector(\".outline-label\");if(location.hash=\"#\"+t.getAttribute(\"href\"),i){var n=this.closest(\".outline-item-wrapper\").classList;n.contains(\"outline-item-open\")||n.add(\"outline-item-open\"),c(),n.add(\"outline-item-active\")}});var a,s,l=function(){var e=o();n=null;for(var i=0;ie.classList.remove(\"outline-item-open\"))},d=function(){if(n){c();var e=document.querySelector('.outline-label[href=\"#'+(CSS.escape?CSS.escape(n[0]):n[0])+'\"]');if(e)if(i){var t=e.closest(\".outline-item-open>ul>.outline-item-wrapper\");if(t)t.classList.add(\"outline-item-active\");else{for(var r=(e=e.closest(\".outline-item-wrapper\")).parentElement.closest(\".outline-item-wrapper\");r;)r=(e=r).parentElement.closest(\".outline-item-wrapper\");e.classList.add(\"outline-item-active\")}}else e.closest(\".outline-item-wrapper\").classList.add(\"outline-item-active\")}};window.addEventListener(\"scroll\",function(e){a&&clearTimeout(a),a=setTimeout(function(){l(),d()},300)});var u=function(){s=setTimeout(function(){!function(){t=[];var e=o();document.querySelector(\"#write\").querySelectorAll(\"h1, h2, h3, h4, h5, h6\").forEach(n=>{var i=n.getAttribute(\"id\");t.push([i,e+n.getBoundingClientRect().y])})}(),l(),d()},300)};window.addEventListener(\"resize\",function(e){s&&clearTimeout(s),u()}),u()})();","link":"/upload/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8Bbase64.html"},{"title":"","text":"html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:\"Lucida Console\",Consolas,\"Courier\",monospace; --title-bar-height:20px; } .mac-os-11 { --title-bar-height:28px; } html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; } iframe { margin: auto; } a.url { word-break: break-all; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; } #write.first-line-indent p { text-indent: 2em; } #write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; } #write.first-line-indent li { margin-left: 2em; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } .typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; } .typora-export .task-list-item input { pointer-events: none; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } #write { padding-left: 20px; padding-right: 20px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } #write li > figure:last-child { margin-bottom: 0.5rem; } #write ol, #write ul { position: relative; } img { max-width: 100%; vertical-align: middle; image-orientation: from-image; } button, input, select, textarea { color: inherit; font: inherit; } input[type=\"checkbox\"], input[type=\"radio\"] { line-height: normal; padding: 0px; } *, ::after, ::before { box-sizing: border-box; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; } p { line-height: inherit; } h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; } p { orphans: 4; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } .md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; } sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; } #write input[type=\"checkbox\"] { cursor: pointer; width: inherit; height: inherit; } figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; } figure > table { margin: 0px; } tr { break-inside: avoid; break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; } table.md-table td { min-width: 32px; } .CodeMirror-gutters { border-right: 0px; background-color: inherit; } .CodeMirror-linenumber { user-select: none; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } #write pre { white-space: pre-wrap; } #write.fences-no-line-wrapping pre { white-space: pre; } #write pre.ty-contain-cm { white-space: normal; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; } .md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } #write .md-fences.mock-cm { white-space: pre-wrap; } .md-fences.md-fences-with-lineno { padding-left: 0px; } #write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; } .md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; } .CodeMirror-line, twitterwidget { break-inside: avoid; } .footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; } .footnotes + .footnotes { margin-top: 0px; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li .mathjax-block, li p { margin: 0.5rem 0px; } li blockquote { margin: 1rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child, li > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; } #write .footnote-line { white-space: pre-wrap; } @media print { body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; } #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; } .typora-export * { -webkit-print-color-adjust: exact; } .typora-export #write { break-after: avoid; } .typora-export #write::after { height: 0px; } .is-mac table { break-inside: avoid; } .typora-export-show-outline .typora-export-sidebar { display: none; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; } p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; } #write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; } p > .md-image:only-child { display: inline-block; width: 100%; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .md-math-block { width: 100%; } .md-math-block:not(:empty)::after { display: none; } .MathJax_ref { fill: currentcolor; } [contenteditable=\"true\"]:active, [contenteditable=\"true\"]:focus, [contenteditable=\"false\"]:active, [contenteditable=\"false\"]:focus { outline: 0px; box-shadow: none; } .md-task-list-item { position: relative; list-style-type: none; } .task-list-item.md-task-list-item { padding-left: 0px; } .md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc-content::after, .md-toc::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); } .md-toc-item a { text-decoration: none; } .md-toc-inner:hover { text-decoration: underline; } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: \".\"; } code, pre, samp, tt { font-family: var(--monospace); } kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; } .md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); } code { text-align: left; vertical-align: initial; } a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; } .os-windows.monocolor-emoji .md-emoji { font-family: \"Segoe UI Symbol\", sans-serif; } .md-diagram-panel > svg { max-width: 100%; } [lang=\"flow\"] svg, [lang=\"mermaid\"] svg { max-width: 100%; height: auto; } [lang=\"mermaid\"] .node text { font-size: 1rem; } table tr th { border-bottom: 0px; } video { max-width: 100%; display: block; margin: 0px auto; } iframe { max-width: 100%; width: 100%; border: none; } .highlight td, .highlight tr { border: 0px; } mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); } .md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; } .md-expand mark .md-meta { opacity: 0.3 !important; } mark .md-meta { color: rgb(0, 0, 0); } @media print { .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; } } .md-diagram-panel .messageText { stroke: none !important; } .md-diagram-panel .start-state { fill: var(--node-fill); } .md-diagram-panel .edgeLabel rect { opacity: 1 !important; } .md-fences.md-fences-math { font-size: 1em; } .md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; } .md-fences-advanced:not(.md-focus) { background: inherit; } .typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; } .typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; } .typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; } .typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; } @media screen and (max-width: 1024px) { .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; } } @media screen and (max-width: 800px) { .typora-export-sidebar { display: none; } } .outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; } .outline-content ul { margin-top: 0px; margin-bottom: 0px; } .outline-content strong { font-weight: 400; } .outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; } .outline-expander::before { content: \"\"; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; } .outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; } .outline-expander:hover::before { content: \"\"; } .outline-h1 > .outline-item { padding-left: 0px; } .outline-h2 > .outline-item { padding-left: 1em; } .outline-h3 > .outline-item { padding-left: 2em; } .outline-h4 > .outline-item { padding-left: 3em; } .outline-h5 > .outline-item { padding-left: 4em; } .outline-h6 > .outline-item { padding-left: 5em; } .outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; } .outline-label:hover { text-decoration: underline; } .outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); } .outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; } .outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; } .outline-item-open > .outline-item > .outline-expander::before { content: \"\"; } .outline-children { display: none; } .info-panel-tab-wrapper { display: none; } .outline-item-open > .outline-children { display: block; } .typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; } .typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; } .typora-export .outline-expander::before { content: \"+\"; font-family: inherit; top: -1px; } .typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: \"−\"; } .typora-export-collapse-outline .outline-children { display: none; } .typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; } .typora-export-no-collapse-outline .outline-expander::before { content: \"\" !important; } .typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; } .md-inline-math-container mjx-container { zoom: 0.95; } .CodeMirror { height: auto; } .CodeMirror.cm-s-inner { background: inherit; } .CodeMirror-scroll { overflow: auto hidden; z-index: 3; } .CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); } .CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; } .CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); } .cm-s-inner .cm-keyword { color: rgb(119, 0, 136); } .cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); } .cm-s-inner .cm-number { color: rgb(17, 102, 68); } .cm-s-inner .cm-def { color: rgb(0, 0, 255); } .cm-s-inner .cm-variable { color: rgb(0, 0, 0); } .cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); } .cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); } .cm-s-inner .cm-string { color: rgb(170, 17, 17); } .cm-s-inner .cm-property { color: rgb(0, 0, 0); } .cm-s-inner .cm-operator { color: rgb(152, 26, 26); } .cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); } .cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); } .cm-s-inner .cm-meta { color: rgb(85, 85, 85); } .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); } .cm-s-inner .cm-builtin { color: rgb(51, 0, 170); } .cm-s-inner .cm-bracket { color: rgb(153, 153, 119); } .cm-s-inner .cm-tag { color: rgb(17, 119, 0); } .cm-s-inner .cm-attribute { color: rgb(0, 0, 204); } .cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); } .cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); } .cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); } .cm-negative { color: rgb(221, 68, 68); } .cm-positive { color: rgb(34, 153, 34); } .cm-header, .cm-strong { font-weight: 700; } .cm-del { text-decoration: line-through; } .cm-em { font-style: italic; } .cm-link { text-decoration: underline; } .cm-error { color: red; } .cm-invalidchar { color: red; } .cm-constant { color: rgb(38, 139, 210); } .cm-defined { color: rgb(181, 137, 0); } div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); } div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); } .cm-s-inner .CodeMirror-activeline-background { background: inherit; } .CodeMirror { position: relative; overflow: hidden; } .CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; } .CodeMirror-sizer { position: relative; } .CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; } .CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; } .CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; } .CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; } .CodeMirror-gutter-filler { left: 0px; bottom: 0px; } .CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; } .CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; } .CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; } .CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; } .CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; } .CodeMirror-lines { cursor: text; } .CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; } .CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; } .CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; } .CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; } .CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; } .CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; } .CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; } .CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; } .CodeMirror-measure pre { position: static; } .CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; } .CodeMirror div.CodeMirror-cursor { visibility: hidden; } .CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; } .cm-searching { background: rgba(255, 255, 0, 0.4); } span.cm-underlined { text-decoration: underline; } span.cm-strikethrough { text-decoration: line-through; } .cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); } .cm-tw-deleted { text-decoration: line-through; } .cm-tw-header5 { font-weight: 700; } .cm-tw-listitem:first-child { padding-left: 10px; } .cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; } .cm-tw-underline { text-decoration: underline; } @media print { .CodeMirror div.CodeMirror-cursor { visibility: hidden; } } :root { --side-bar-bg-color: #fafafa; --control-text-color: #777; } @include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext); /* open-sans-regular - latin-ext_latin */ /* open-sans-italic - latin-ext_latin */ /* open-sans-700 - latin-ext_latin */ /* open-sans-700italic - latin-ext_latin */ html { font-size: 16px; -webkit-font-smoothing: antialiased; } body { font-family: \"Open Sans\",\"Clear Sans\", \"Helvetica Neue\", Helvetica, Arial, 'Segoe UI Emoji', sans-serif; color: rgb(51, 51, 51); line-height: 1.6; } #write { max-width: 860px; margin: 0 auto; padding: 30px; padding-bottom: 100px; } @media only screen and (min-width: 1400px) { #write { max-width: 1024px; } } @media only screen and (min-width: 1800px) { #write { max-width: 1200px; } } #write > ul:first-child, #write > ol:first-child{ margin-top: 30px; } a { color: #4183C4; } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } h2 { font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } /*@media print { .typora-export h1, .typora-export h2 { border-bottom: none; padding-bottom: initial; } .typora-export h1::after, .typora-export h2::after { content: \"\"; display: block; height: 100px; margin-top: -96px; border-top: 1px solid #eee; } }*/ h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: #777; } p, blockquote, ul, ol, dl, table{ margin: 0.8em 0; } li>ol, li>ul { margin: 0 0; } hr { height: 2px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; overflow: hidden; box-sizing: content-box; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0; } ul:last-child, ol:last-child { margin-bottom: 0; } blockquote { border-left: 4px solid #dfe2e5; padding: 0 15px; color: #777777; } blockquote blockquote { padding-right: 0; } table { padding: 0; word-break: initial; } table tr { border: 1px solid #dfe2e5; margin: 0; padding: 0; } table tr:nth-child(2n), thead { background-color: #f8f8f8; } table th { font-weight: bold; border: 1px solid #dfe2e5; border-bottom: 0; margin: 0; padding: 6px 13px; } table td { border: 1px solid #dfe2e5; margin: 0; padding: 6px 13px; } table th:first-child, table td:first-child { margin-top: 0; } table th:last-child, table td:last-child { margin-bottom: 0; } .CodeMirror-lines { padding-left: 4px; } .code-tooltip { box-shadow: 0 1px 1px 0 rgba(0,28,36,.3); border-top: 1px solid #eef2f2; } .md-fences, code, tt { border: 1px solid #e7eaed; background-color: #f8f8f8; border-radius: 3px; padding: 0; padding: 2px 4px 0px 4px; font-size: 0.9em; } code { background-color: #f3f4f4; padding: 0 2px 0 2px; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; } .md-task-list-item > input { margin-left: -1.3em; } @media print { html { font-size: 13px; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: #f8f8f8; } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border: 0; border-radius: 3px; color: #777777; margin-top: 0 !important; } .mathjax-block>.code-tooltip { bottom: .375rem; } .md-mathjax-midline { background: #fafafa; } #write>h3.md-focus:before{ left: -1.5625rem; top: .375rem; } #write>h4.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h5.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h6.md-focus:before{ left: -1.5625rem; top: .285714286rem; } .md-image>.md-meta { /*border: 1px solid #ddd;*/ border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; } .md-tag { color: #a7a7a7; opacity: 1; } .md-toc { margin-top:20px; padding-bottom:20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid #ddd; background-color: #f8f8f8; } #typora-quick-open-item { background-color: #FAFAFA; border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee; border-style: solid; border-width: 1px; } /** focus mode */ .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer{ font-family: \"Segoe UI\", \"Arial\", sans-serif; } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state{ visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: #fafafa; background-color: var(--side-bar-bg-color); } .md-lang { color: #b4654d; } /*.html-for-mac { --item-hover-bg-color: #E6F0FE; }*/ #md-notification .btn { border: 0; } .dropdown-menu .divider { border-color: #e5e5e5; opacity: 0.4; } .ty-preferences .window-content { background-color: #fafafa; } .ty-preferences .nav-group-item.active { color: white; background: #999; } .menu-item-container a.menu-style-btn { background-color: #f5f8fa; background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); } C++提高编程base64 C++提高编程1 模板1.1 模板的概念1.2 函数模板1.2.1 函数模板语法1.2.2 函数模板注意事项1.2.3 函数模板案例1.2.4 普通函数与函数模板的区别1.2.5 普通函数与函数模板的调用规则1.2.6 模板的局限性1.3 类模板1.3.1 类模板语法1.3.2 类模板与函数模板区别1.3.3 类模板中成员函数创建时机1.3.4 类模板对象做函数参数1.3.5 类模板与继承1.3.6 类模板成员函数类外实现1.3.7 类模板分文件编写1.3.8 类模板与友元1.3.9 类模板案例2 STL初识2.1 STL的诞生2.2 STL基本概念2.3 STL六大组件2.4 STL中容器、算法、迭代器2.5 容器算法迭代器初识2.5.1 vector存放内置数据类型2.5.2 Vector存放自定义数据类型2.5.3 Vector容器嵌套容器3 STL- 常用容器3.1 string容器3.1.1 string基本概念3.1.2 string构造函数3.1.3 string赋值操作3.1.4 string字符串拼接3.1.5 string查找和替换3.1.6 string字符串比较3.1.7 string字符存取3.1.8 string插入和删除3.1.9 string子串3.2 vector容器3.2.1 vector基本概念3.2.2 vector构造函数3.2.3 vector赋值操作3.2.4 vector容量和大小3.2.5 vector插入和删除3.2.6 vector数据存取3.2.7 vector互换容器3.2.8 vector预留空间3.3 deque容器3.3.1 deque容器基本概念3.3.2 deque构造函数3.3.3 deque赋值操作3.3.4 deque大小操作3.3.5 deque 插入和删除3.3.6 deque 数据存取3.3.7 deque 排序3.4 案例-评委打分3.4.1 案例描述3.4.2 实现步骤3.5 stack容器3.5.1 stack 基本概念3.5.2 stack 常用接口3.6 queue 容器3.6.1 queue 基本概念3.6.2 queue 常用接口3.7 list容器3.7.1 list基本概念3.7.2 list构造函数3.7.3 list 赋值和交换3.7.4 list 大小操作3.7.5 list 插入和删除3.7.6 list 数据存取3.7.7 list 反转和排序3.7.8 排序案例3.8 set/ multiset 容器3.8.1 set基本概念3.8.2 set构造和赋值3.8.3 set大小和交换3.8.4 set插入和删除3.8.5 set查找和统计3.8.6 set和multiset区别3.8.7 pair对组创建3.8.8 set容器排序3.9 map/ multimap容器3.9.1 map基本概念3.9.2 map构造和赋值3.9.3 map大小和交换3.9.4 map插入和删除3.9.5 map查找和统计3.9.6 map容器排序3.10 案例-员工分组3.10.1 案例描述3.10.2 实现步骤4 STL- 函数对象4.1 函数对象4.1.1 函数对象概念4.1.2 函数对象使用4.2 谓词4.2.1 谓词概念4.2.2 一元谓词4.2.3 二元谓词4.3 内建函数对象4.3.1 内建函数对象意义4.3.2 算术仿函数4.3.3 关系仿函数4.3.4 逻辑仿函数5 STL- 常用算法5.1 常用遍历算法5.1.1 for_each5.1.2 transform5.2 常用查找算法5.2.1 find5.2.2 find_if5.2.3 adjacent_find5.2.4 binary_search5.2.5 count5.2.6 count_if5.3 常用排序算法5.3.1 sort5.3.2 random_shuffle5.3.3 merge5.3.4 reverse5.4 常用拷贝和替换算法5.4.1 copy5.4.2 replace5.4.3 replace_if5.4.4 swap5.5 常用算术生成算法5.5.1 accumulate5.5.2 fill5.6 常用集合算法5.6.1 set_intersection5.6.2 set_union5.6.3 set_differenceC++提高编程&nbsp;本阶段主要针对C++泛型编程和STL技术做详细讲解，探讨C++更深层的使用&nbsp;&nbsp;1 模板1.1 模板的概念&nbsp;模板就是建立通用的模具，大大提高复用性&nbsp;例如生活中的模板&nbsp;一寸照片模板：&nbsp;&nbsp;PPT模板：&nbsp;&nbsp;&nbsp;模板的特点：模板不可以直接使用，它只是一个框架模板的通用并不是万能的&nbsp;&nbsp;&nbsp;&nbsp;1.2 函数模板&nbsp;C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板C++提供两种模板机制:函数模板和类模板 &nbsp;1.2.1 函数模板语法函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。&nbsp;语法： template&lt;typename T&gt;函数声明或定义解释：template --- 声明创建模板typename --- 表面其后面的符号是一种数据类型，可以用class代替T --- 通用的数据类型，名称可以替换，通常为大写字母&nbsp;示例：xxxxxxxxxx //交换整型函数void swapInt(int&amp; a, int&amp; b) { int temp = a; a = b; b = temp;} //交换浮点型函数void swapDouble(double&amp; a, double&amp; b) { double temp = a; a = b; b = temp;} //利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b){ T temp = a; a = b; b = temp;} void test01(){ int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; } int main() { test01(); system(\"pause\"); return 0;}总结：函数模板利用关键字 template使用函数模板有两种方式：自动类型推导、显示指定类型模板的目的是为了提高复用性，将类型参数化&nbsp;&nbsp;&nbsp;&nbsp;1.2.2 函数模板注意事项注意事项：自动类型推导，必须推导出一致的数据类型T,才可以使用模板必须要确定出T的数据类型，才可以使用&nbsp;示例：​x//利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b){ T temp = a; a = b; b = temp;} // 1、自动类型推导，必须推导出一致的数据类型T,才可以使用void test01(){ int a = 10; int b = 20; char c = 'c'; mySwap(a, b); // 正确，可以推导出一致的T //mySwap(a, c); // 错误，推导不出一致的T类型} // 2、模板必须要确定出T的数据类型，才可以使用template&lt;class T&gt;void func(){ cout &lt;&lt; \"func 调用\" &lt;&lt; endl;} void test02(){ //func(); //错误，模板不能独立使用，必须确定出T的类型 func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板} int main() { test01(); test02(); system(\"pause\"); return 0;}总结：使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.3 函数模板案例案例描述：利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序排序规则从大到小，排序算法为选择排序分别利用char数组和int数组进行测试&nbsp;示例：xxxxxxxxxx//交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b){ T temp = a; a = b; b = temp;} template&lt;class T&gt; // 也可以替换成typename//利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len){ for (int i = 0; i &lt; len; i++) { int max = i; //最大数的下标 for (int j = i + 1; j &lt; len; j++) { if (arr[max] &lt; arr[j]) { max = j; } } if (max != i) //如果最大数的下标不是i，交换两者 { mySwap(arr[max], arr[i]); } }}template&lt;typename T&gt;void printArray(T arr[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl;}void test01(){ //测试char数组 char charArr[] = \"bdcfeagh\"; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num);} void test02(){ //测试int数组 int intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 }; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num);} int main() { test01(); test02(); system(\"pause\"); return 0;}总结：模板可以提高代码复用，需要熟练掌握&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.4 普通函数与函数模板的区别&nbsp;普通函数与函数模板区别：普通函数调用时可以发生自动类型转换（隐式类型转换）函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换如果利用显示指定类型的方式，可以发生隐式类型转换&nbsp;示例：xxxxxxxxxx//普通函数int myAdd01(int a, int b){ return a + b;} //函数模板template&lt;class T&gt;T myAdd02(T a, T b) &nbsp;{ return a + b;} //使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换void test01(){ int a = 10; int b = 20; char c = 'c'; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的'c'隐式转换为int类型 'c' 对应 ASCII码 99 //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换} int main() { test01(); system(\"pause\"); return 0;}总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.5 普通函数与函数模板的调用规则&nbsp;调用规则如下：如果函数模板和普通函数都可以实现，优先调用普通函数可以通过空模板参数列表来强制调用函数模板函数模板也可以发生重载如果函数模板可以产生更好的匹配,优先调用函数模板&nbsp;&nbsp;示例：xxxxxxxxxx//普通函数与函数模板调用规则void myPrint(int a, int b){ cout &lt;&lt; \"调用的普通函数\" &lt;&lt; endl;} template&lt;typename T&gt;void myPrint(T a, T b) { cout &lt;&lt; \"调用的模板\" &lt;&lt; endl;} template&lt;typename T&gt;void myPrint(T a, T b, T c) { cout &lt;&lt; \"调用重载的模板\" &lt;&lt; endl; } void test01(){ //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint&lt;&gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = 'a'; char c2 = 'b'; myPrint(c1, c2); //调用函数模板} int main() { test01(); system(\"pause\"); return 0;}总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.6 模板的局限性局限性：模板的通用性并不是万能的&nbsp;例如：xxxxxxxxxx template&lt;class T&gt; void f(T a, T b) { &nbsp; a = b; &nbsp; }在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了&nbsp;再例如：xxxxxxxxxx template&lt;class T&gt; void f(T a, T b) { &nbsp; if(a &gt; b) { ... } &nbsp; }在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行&nbsp;因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板&nbsp;示例：xxxxxxxxxx#include&lt;iostream&gt;using namespace std; #include &lt;string&gt; class Person{public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age;}; //普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b){ if (a == b) { return true; } else { return false; }} //具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型//具体化优先于常规模板template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2){ if ( p1.m_Name &nbsp;== p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) { return true; } else { return false; }} void test01(){ int a = 10; int b = 20; //内置数据类型可以直接使用通用的函数模板 bool ret = myCompare(a, b); if (ret) { cout &lt;&lt; \"a == b \" &lt;&lt; endl; } else { cout &lt;&lt; \"a != b \" &lt;&lt; endl; }} void test02(){ Person p1(\"Tom\", 10); Person p2(\"Tom\", 10); //自定义数据类型，不会调用普通的函数模板 //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 bool ret = myCompare(p1, p2); if (ret) { cout &lt;&lt; \"p1 == p2 \" &lt;&lt; endl; } else { cout &lt;&lt; \"p1 != p2 \" &lt;&lt; endl; }} int main() { test01(); test02(); system(\"pause\"); return 0;}总结：利用具体化的模板，可以解决自定义类型的通用化学习模板并不是为了写模板，而是在STL能够运用系统提供的模板&nbsp;&nbsp;&nbsp;&nbsp;1.3 类模板1.3.1 类模板语法类模板作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。&nbsp;语法： xxxxxxxxxxtemplate&lt;typename T&gt;类解释：template --- 声明创建模板typename --- 表面其后面的符号是一种数据类型，可以用class代替T --- 通用的数据类型，名称可以替换，通常为大写字母&nbsp;示例：xxxxxxxxxx#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType&gt; class Person{public: Person(NameType name, AgeType age) { this-&gt;mName = name; this-&gt;mAge = age; } void showPerson() { cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;mName &lt;&lt; \" age: \" &lt;&lt; this-&gt;mAge &lt;&lt; endl; }public: NameType mName; AgeType mAge;}; void test01(){ // 指定NameType 为string类型，AgeType 为 int类型 Person&lt;string, int&gt;P1(\"孙悟空\", 999); P1.showPerson();} int main() { test01(); system(\"pause\"); return 0;}总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3.2 类模板与函数模板区别&nbsp;类模板与函数模板区别主要有两点：类模板没有自动类型推导的使用方式类模板在模板参数列表中可以有默认参数&nbsp;示例：xxxxxxxxxx#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person{public: Person(NameType name, AgeType age) { this-&gt;mName = name; this-&gt;mAge = age; } void showPerson() { cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;mName &lt;&lt; \" age: \" &lt;&lt; this-&gt;mAge &lt;&lt; endl; }public: NameType mName; AgeType mAge;}; //1、类模板没有自动类型推导的使用方式void test01(){ // Person p(\"孙悟空\", 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person &lt;string ,int&gt;p(\"孙悟空\", 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson();} //2、类模板在模板参数列表中可以有默认参数void test02(){ Person &lt;string&gt; p(\"猪八戒\", 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson();} int main() { test01(); test02(); system(\"pause\"); return 0;}总结：类模板使用只能用显示指定类型方式类模板中的模板参数列表可以有默认参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3.3 类模板中成员函数创建时机&nbsp;类模板中成员函数和普通类中成员函数创建时机是有区别的：普通类中的成员函数一开始就可以创建类模板中的成员函数在调用时才创建&nbsp;&nbsp;示例：xxxxxxxxxxclass Person1{public: void showPerson1() { cout &lt;&lt; \"Person1 show\" &lt;&lt; endl; }}; class Person2{public: void showPerson2() { cout &lt;&lt; \"Person2 show\" &lt;&lt; endl; }}; template&lt;class T&gt;class MyClass{public: T obj; //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成 void fun1() { obj.showPerson1(); } void fun2() { obj.showPerson2(); } }; void test01(){ MyClass&lt;Person1&gt; m; m.fun1(); //m.fun2();//编译会出错，说明函数调用才会去创建成员函数} int main() { test01(); system(\"pause\"); return 0;}总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建&nbsp;&nbsp;&nbsp;&nbsp;1.3.4 类模板对象做函数参数学习目标：类模板实例化出的对象，向函数传参的方式&nbsp;一共有三种传入方式：指定传入的类型 --- 直接显示对象的数据类型参数模板化 --- 将对象中的参数变为模板进行传递整个类模板化 --- 将这个对象类型 模板化进行传递&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person{public: Person(NameType name, AgeType age) { this-&gt;mName = name; this-&gt;mAge = age; } void showPerson() { cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;mName &lt;&lt; \" age: \" &lt;&lt; this-&gt;mAge &lt;&lt; endl; }public: NameType mName; AgeType mAge;}; //1、指定传入的类型void printPerson1(Person&lt;string, int&gt; &amp;p) { p.showPerson();}void test01(){ Person &lt;string, int &gt;p(\"孙悟空\", 100); printPerson1(p);} //2、参数模板化template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p){ p.showPerson(); cout &lt;&lt; \"T1的类型为： \" &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; \"T2的类型为： \" &lt;&lt; typeid(T2).name() &lt;&lt; endl;}void test02(){ Person &lt;string, int &gt;p(\"猪八戒\", 90); printPerson2(p);} //3、整个类模板化template&lt;class T&gt;void printPerson3(T &amp; p){ cout &lt;&lt; \"T的类型为： \" &lt;&lt; typeid(T).name() &lt;&lt; endl; p.showPerson(); }void test03(){ Person &lt;string, int &gt;p(\"唐僧\", 30); printPerson3(p);} int main() { test01(); test02(); test03(); system(\"pause\"); return 0;}总结：通过类模板创建的对象，可以有三种方式向函数中进行传参使用比较广泛是第一种：指定传入的类型&nbsp;&nbsp;&nbsp;&nbsp;1.3.5 类模板与继承&nbsp;当类模板碰到继承时，需要注意一下几点：当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型如果不指定，编译器无法给子类分配内存如果想灵活指定出父类中T的类型，子类也需变为类模板&nbsp;示例：xxxxxxxxxxtemplate&lt;class T&gt;class Base{ T m;}; //class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承class Son :public Base&lt;int&gt; //必须指定一个类型{};void test01(){ Son c;} //类模板继承类模板 ,可以用T2指定父类中的T类型template&lt;class T1, class T2&gt;class Son2 :public Base&lt;T2&gt;{public: Son2() { cout &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; typeid(T2).name() &lt;&lt; endl; }}; void test02(){ Son2&lt;int, char&gt; child1;} int main() { test01(); test02(); system(\"pause\"); return 0;}总结：如果父类是类模板，子类需要指定出父类中T的数据类型&nbsp;&nbsp;&nbsp;&nbsp;1.3.6 类模板成员函数类外实现&nbsp;学习目标：能够掌握类模板中的成员函数类外实现&nbsp;示例：xxxxxxxxxx#include &lt;string&gt; //类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person {public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age;}; //构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age;} //成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() { cout &lt;&lt; \"姓名: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" 年龄:\" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;} void test01(){ Person&lt;string, int&gt; p(\"Tom\", 20); p.showPerson();} int main() { test01(); system(\"pause\"); return 0;}总结：类模板中成员函数类外实现时，需要加上模板参数列表&nbsp;&nbsp;&nbsp;&nbsp;1.3.7 类模板分文件编写学习目标：掌握类模板成员函数分文件编写产生的问题以及解决方式&nbsp;问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到解决：解决方式1：直接包含.cpp源文件解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制&nbsp;示例：person.hpp中代码：xxxxxxxxxx#pragma once#include &lt;iostream&gt;using namespace std;#include &lt;string&gt; template&lt;class T1, class T2&gt;class Person {public: Person(T1 name, T2 age); void showPerson();public: T1 m_Name; T2 m_Age;}; //构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age;} //成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() { cout &lt;&lt; \"姓名: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" 年龄:\" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;}&nbsp;类模板分文件编写.cpp中代码xxxxxxxxxx#include&lt;iostream&gt;using namespace std; //#include \"person.h\"#include \"person.cpp\" //解决方式1，包含cpp源文件 //解决方式2，将声明和实现写到一起，文件后缀名改为.hpp#include \"person.hpp\"void test01(){ Person&lt;string, int&gt; p(\"Tom\", 10); p.showPerson();} int main() { test01(); system(\"pause\"); return 0;}总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp&nbsp;&nbsp;&nbsp;&nbsp;1.3.8 类模板与友元&nbsp;学习目标：掌握类模板配合友元函数的类内和类外实现&nbsp;全局函数类内实现 - 直接在类内声明友元即可全局函数类外实现 - 需要提前让编译器知道全局函数的存在&nbsp;示例：xxxxxxxxxx#include &lt;string&gt; //2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元template&lt;class T1, class T2&gt; class Person; //如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt; &amp; p){ cout &lt;&lt; \"类外实现 ---- 姓名： \" &lt;&lt; p.m_Name &lt;&lt; \" 年龄：\" &lt;&lt; p.m_Age &lt;&lt; endl;} template&lt;class T1, class T2&gt;class Person{ //1、全局函数配合友元 &nbsp; 类内实现 friend void printPerson(Person&lt;T1, T2&gt; &amp; p) { cout &lt;&lt; \"姓名： \" &lt;&lt; p.m_Name &lt;&lt; \" 年龄：\" &lt;&lt; p.m_Age &lt;&lt; endl; } //全局函数配合友元 类外实现 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p); public: Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } private: T1 m_Name; T2 m_Age; }; //1、全局函数在类内实现void test01(){ Person &lt;string, int &gt;p(\"Tom\", 20); printPerson(p);} //2、全局函数在类外实现void test02(){ Person &lt;string, int &gt;p(\"Jerry\", 30); printPerson2(p);} int main() { //test01(); test02(); system(\"pause\"); return 0;}总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3.9 类模板案例案例描述: 实现一个通用的数组类，要求如下：&nbsp;可以对内置数据类型以及自定义数据类型的数据进行存储将数组中的数据存储到堆区构造函数中可以传入数组的容量提供对应的拷贝构造函数以及operator=防止浅拷贝问题提供尾插法和尾删法对数组中的数据进行增加和删除可以通过下标的方式访问数组中的元素可以获取数组中当前元素个数和数组的容量&nbsp;&nbsp;示例：myArray.hpp中代码xxxxxxxxxx#pragma once#include &lt;iostream&gt;using namespace std; template&lt;class T&gt;class MyArray{public: &nbsp; &nbsp; //构造函数 MyArray(int capacity) { this-&gt;m_Capacity = capacity; this-&gt;m_Size = 0; pAddress = new T[this-&gt;m_Capacity]; } //拷贝构造 MyArray(const MyArray &amp; arr) { this-&gt;m_Capacity = arr.m_Capacity; this-&gt;m_Size = arr.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) { //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值， // 普通类型可以直接= 但是指针类型需要深拷贝 this-&gt;pAddress[i] = arr.pAddress[i]; } } //重载= 操作符 防止浅拷贝问题 MyArray&amp; operator=(const MyArray&amp; myarray) { if (this-&gt;pAddress != NULL) { delete[] this-&gt;pAddress; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; } this-&gt;m_Capacity = myarray.m_Capacity; this-&gt;m_Size = myarray.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) { this-&gt;pAddress[i] = myarray[i]; } return *this; } //重载[] 操作符 arr[0] T&amp; operator [](int index) { return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理 } //尾插法 void Push_back(const T &amp; val) { if (this-&gt;m_Capacity == this-&gt;m_Size) { return; } this-&gt;pAddress[this-&gt;m_Size] = val; this-&gt;m_Size++; } //尾删法 void Pop_back() { if (this-&gt;m_Size == 0) { return; } this-&gt;m_Size--; } //获取数组容量 int getCapacity() { return this-&gt;m_Capacity; } //获取数组大小 int getSize() { return this-&gt;m_Size; } //析构 ~MyArray() { if (this-&gt;pAddress != NULL) { delete[] this-&gt;pAddress; this-&gt;pAddress = NULL; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; } } private: T * pAddress; &nbsp;//指向一个堆空间，这个空间存储真正的数据 int m_Capacity; //容量 int m_Size; &nbsp; // 大小};&nbsp;类模板案例—数组类封装.cpp中xxxxxxxxxx#include \"myArray.hpp\"#include &lt;string&gt; void printIntArray(MyArray&lt;int&gt;&amp; arr) { for (int i = 0; i &lt; arr.getSize(); i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl;} //测试内置数据类型void test01(){ MyArray&lt;int&gt; array1(10); for (int i = 0; i &lt; 10; i++) { array1.Push_back(i); } cout &lt;&lt; \"array1打印输出：\" &lt;&lt; endl; printIntArray(array1); cout &lt;&lt; \"array1的大小：\" &lt;&lt; array1.getSize() &lt;&lt; endl; cout &lt;&lt; \"array1的容量：\" &lt;&lt; array1.getCapacity() &lt;&lt; endl; cout &lt;&lt; \"--------------------------\" &lt;&lt; endl; MyArray&lt;int&gt; array2(array1); array2.Pop_back(); cout &lt;&lt; \"array2打印输出：\" &lt;&lt; endl; printIntArray(array2); cout &lt;&lt; \"array2的大小：\" &lt;&lt; array2.getSize() &lt;&lt; endl; cout &lt;&lt; \"array2的容量：\" &lt;&lt; array2.getCapacity() &lt;&lt; endl;} //测试自定义数据类型class Person {public: Person() {} Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; }public: string m_Name; int m_Age;}; void printPersonArray(MyArray&lt;Person&gt;&amp; personArr){ for (int i = 0; i &lt; personArr.getSize(); i++) { cout &lt;&lt; \"姓名：\" &lt;&lt; personArr[i].m_Name &lt;&lt; \" 年龄： \" &lt;&lt; personArr[i].m_Age &lt;&lt; endl; } } void test02(){ //创建数组 MyArray&lt;Person&gt; pArray(10); Person p1(\"孙悟空\", 30); Person p2(\"韩信\", 20); Person p3(\"妲己\", 18); Person p4(\"王昭君\", 15); Person p5(\"赵云\", 24); //插入数据 pArray.Push_back(p1); pArray.Push_back(p2); pArray.Push_back(p3); pArray.Push_back(p4); pArray.Push_back(p5); printPersonArray(pArray); cout &lt;&lt; \"pArray的大小：\" &lt;&lt; pArray.getSize() &lt;&lt; endl; cout &lt;&lt; \"pArray的容量：\" &lt;&lt; pArray.getCapacity() &lt;&lt; endl; } int main() { //test01(); test02(); system(\"pause\"); return 0;}总结：能够利用所学知识点实现通用的数组&nbsp;&nbsp;2 STL初识2.1 STL的诞生&nbsp;长久以来，软件界一直希望建立一种可重复利用的东西C++的面向对象和泛型编程思想，目的就是复用性的提升大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作为了建立数据结构和算法的一套标准,诞生了STL&nbsp;2.2 STL基本概念&nbsp;STL(Standard Template Library,标准模板库)STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数&nbsp;&nbsp;2.3 STL六大组件STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器&nbsp;容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。算法：各种常用的算法，如sort、find、copy、for_each等迭代器：扮演了容器与算法之间的胶合剂。仿函数：行为类似函数，可作为算法的某种策略。适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。空间配置器：负责空间的配置与管理。&nbsp;&nbsp;2.4 STL中容器、算法、迭代器&nbsp;容器：置物之所也STL容器就是将运用最广泛的一些数据结构实现出来常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等这些容器分为序列式容器和关联式容器两种: 序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。 ​ 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系&nbsp;算法：问题之解法也有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)算法分为:质变算法和非质变算法。质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等&nbsp;迭代器：容器和算法之间粘合剂提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。每个容器都有自己专属的迭代器迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针&nbsp;迭代器种类：种类功能支持运算输入迭代器对数据的只读访问只读，支持++、==、！=输出迭代器对数据的只写访问只写，支持++前向迭代器读写操作，并能向前推进迭代器读写，支持++、==、！=双向迭代器读写操作，并能向前和向后操作读写，支持++、--，随机访问迭代器读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器读写，支持++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=常用的容器中迭代器种类为双向迭代器，和随机访问迭代器&nbsp;&nbsp;&nbsp;2.5 容器算法迭代器初识&nbsp;了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器&nbsp;2.5.1 vector存放内置数据类型&nbsp;容器： vector算法： for_each迭代器： vector&lt;int&gt;::iterator&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt;#include &lt;algorithm&gt; void MyPrint(int val){ cout &lt;&lt; val &lt;&lt; endl;} void test01() { //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 vector&lt;int&gt; v; //向容器中放数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 //v.begin()返回迭代器，这个迭代器指向容器中第一个数据 //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 //vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型 vector&lt;int&gt;::iterator pBegin = v.begin(); vector&lt;int&gt;::iterator pEnd = v.end(); //第一种遍历方式： while (pBegin != pEnd) { cout &lt;&lt; *pBegin &lt;&lt; endl; pBegin++; } //第二种遍历方式： for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; endl; } cout &lt;&lt; endl; //第三种遍历方式： //使用STL提供标准遍历算法 头文件 algorithm for_each(v.begin(), v.end(), MyPrint);} int main() { test01(); system(\"pause\"); return 0;}&nbsp;2.5.2 Vector存放自定义数据类型&nbsp;学习目标：vector中存放自定义数据类型，并打印输出&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt;#include &lt;string&gt; //自定义数据类型class Person {public: Person(string name, int age) { mName = name; mAge = age; }public: string mName; int mAge;};//存放对象void test01() { vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); Person p5(\"eee\", 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; \"Name:\" &lt;&lt; (*it).mName &lt;&lt; \" Age:\" &lt;&lt; (*it).mAge &lt;&lt; endl; }} //放对象指针void test02() { vector&lt;Person*&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); Person p5(\"eee\", 50); v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); v.push_back(&amp;p4); v.push_back(&amp;p5); for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) { Person * p = (*it); cout &lt;&lt; \"Name:\" &lt;&lt; p-&gt;mName &lt;&lt; \" Age:\" &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl; }} int main() { test01(); &nbsp; &nbsp; test02(); system(\"pause\"); return 0;}&nbsp;2.5.3 Vector容器嵌套容器&nbsp;学习目标：容器中嵌套容器，我们将所有数据进行遍历输出&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt; //容器嵌套容器void test01() { vector&lt; vector&lt;int&gt; &gt; &nbsp;v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; for (int i = 0; i &lt; 4; i++) { v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); } //将容器元素插入到vector v中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) { for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { cout &lt;&lt; *vit &lt;&lt; \" \"; } cout &lt;&lt; endl; } } int main() { test01(); system(\"pause\"); return 0;}&nbsp;&nbsp;3 STL- 常用容器3.1 string容器&nbsp;3.1.1 string基本概念本质：string是C++风格的字符串，而string本质上是一个类&nbsp;string和char * 区别：char * 是一个指针string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。&nbsp;特点：string 类内部封装了很多成员方法例如：查找find，拷贝copy，删除delete 替换replace，插入insertstring管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责&nbsp;3.1.2 string构造函数构造函数原型：string(); //创建一个空的字符串 例如: string str; string(const char* s); //使用字符串s初始化string(const string&amp; str); //使用一个string对象初始化另一个string对象string(int n, char c); //使用n个字符c初始化 &nbsp;示例：xxxxxxxxxx#include &lt;string&gt;//string构造void test01(){ string s1; //创建空字符串，调用无参构造函数 cout &lt;&lt; \"str1 = \" &lt;&lt; s1 &lt;&lt; endl; const char* str = \"hello world\"; string s2(str); //把c_string转换成了string cout &lt;&lt; \"str2 = \" &lt;&lt; s2 &lt;&lt; endl; string s3(s2); //调用拷贝构造函数 cout &lt;&lt; \"str3 = \" &lt;&lt; s3 &lt;&lt; endl; string s4(10, 'a'); cout &lt;&lt; \"str3 = \" &lt;&lt; s3 &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：string的多种构造方式没有可比性，灵活使用即可&nbsp;&nbsp;&nbsp;&nbsp;3.1.3 string赋值操作功能描述：给string字符串进行赋值&nbsp;赋值的函数原型：string&amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串string&amp; operator=(const string &amp;s); //把字符串s赋给当前的字符串string&amp; operator=(char c); //字符赋值给当前的字符串string&amp; assign(const char *s); //把字符串s赋给当前的字符串string&amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串string&amp; assign(const string &amp;s); //把字符串s赋给当前字符串string&amp; assign(int n, char c); //用n个字符c赋给当前字符串&nbsp;示例：xxxxxxxxxx//赋值void test01(){ string str1; str1 = \"hello world\"; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str2; str2 = str1; cout &lt;&lt; \"str2 = \" &lt;&lt; str2 &lt;&lt; endl; string str3; str3 = 'a'; cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl; string str4; str4.assign(\"hello c++\"); cout &lt;&lt; \"str4 = \" &lt;&lt; str4 &lt;&lt; endl; string str5; str5.assign(\"hello c++\",5); cout &lt;&lt; \"str5 = \" &lt;&lt; str5 &lt;&lt; endl; string str6; str6.assign(str5); cout &lt;&lt; \"str6 = \" &lt;&lt; str6 &lt;&lt; endl; string str7; str7.assign(5, 'x'); cout &lt;&lt; \"str7 = \" &lt;&lt; str7 &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结： string的赋值方式很多，operator= 这种方式是比较实用的&nbsp;&nbsp;&nbsp;&nbsp;3.1.4 string字符串拼接功能描述：实现在字符串末尾拼接字符串&nbsp;函数原型：string&amp; operator+=(const char* str); //重载+=操作符string&amp; operator+=(const char c); //重载+=操作符string&amp; operator+=(const string&amp; str); //重载+=操作符string&amp; append(const char *s); //把字符串s连接到当前字符串结尾string&amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾string&amp; append(const string &amp;s); //同operator+=(const string&amp; str)string&amp; append(const string &amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾&nbsp;示例：xxxxxxxxxx//字符串拼接void test01(){ string str1 = \"我\"; str1 += \"爱玩游戏\"; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; str1 += ':'; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str2 = \"LOL DNF\"; str1 += str2; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str3 = \"I\"; str3.append(\" love \"); str3.append(\"game abcde\", 4); //str3.append(str2); str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl;}int main() { test01(); system(\"pause\"); return 0;}总结：字符串拼接的重载版本很多，初学阶段记住几种即可&nbsp;&nbsp;&nbsp;3.1.5 string查找和替换功能描述：查找：查找指定字符串是否存在替换：在指定的位置替换字符串&nbsp;函数原型：int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置int find(const char c, int pos = 0) const; //查找字符c第一次出现位置int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串strstring&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s&nbsp;示例：xxxxxxxxxx//查找和替换void test01(){ //查找 string str1 = \"abcdefgde\"; int pos = str1.find(\"de\"); if (pos == -1) { cout &lt;&lt; \"未找到\" &lt;&lt; endl; } else { cout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl; } pos = str1.rfind(\"de\"); cout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl; } void test02(){ //替换 string str1 = \"abcdefgde\"; str1.replace(1, 3, \"1111\"); cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl;} int main() { //test01(); //test02(); system(\"pause\"); return 0;}总结：find查找是从左往后，rfind从右往左find找到字符串后返回查找的第一个字符位置，找不到返回-1replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.6 string字符串比较功能描述：字符串之间的比较比较方式：字符串比较是按字符的ASCII码进行对比= 返回 0&gt; 返回 1 &lt; 返回 -1&nbsp;函数原型：int compare(const string &amp;s) const; //与字符串s比较int compare(const char *s) const; //与字符串s比较&nbsp;&nbsp;示例：xxxxxxxxxx//字符串比较void test01(){ string s1 = \"hello\"; string s2 = \"aello\"; int ret = s1.compare(s2); if (ret == 0) { cout &lt;&lt; \"s1 等于 s2\" &lt;&lt; endl; } else if (ret &gt; 0) { cout &lt;&lt; \"s1 大于 s2\" &lt;&lt; endl; } else { cout &lt;&lt; \"s1 小于 s2\" &lt;&lt; endl; } } int main() { test01(); system(\"pause\"); return 0;}总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大&nbsp;&nbsp;3.1.7 string字符存取&nbsp;string中单个字符存取方式有两种&nbsp;char&amp; operator[](int n); //通过[]方式取字符char&amp; at(int n); //通过at方法获取字符&nbsp;&nbsp;示例：xxxxxxxxxxvoid test01(){ string str = \"hello world\"; for (int i = 0; i &lt; str.size(); i++) { cout &lt;&lt; str[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; for (int i = 0; i &lt; str.size(); i++) { cout &lt;&lt; str.at(i) &lt;&lt; \" \"; } cout &lt;&lt; endl; //字符修改 str[0] = 'x'; str.at(1) = 'x'; cout &lt;&lt; str &lt;&lt; endl; } int main() { test01(); system(\"pause\"); return 0;}总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at&nbsp;&nbsp;&nbsp;&nbsp;3.1.8 string插入和删除功能描述：对string字符串进行插入和删除字符操作函数原型：string&amp; insert(int pos, const char* s); //插入字符串string&amp; insert(int pos, const string&amp; str); //插入字符串string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符cstring&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符 &nbsp;&nbsp;示例：xxxxxxxxxx//字符串插入和删除void test01(){ string str = \"hello\"; str.insert(1, \"111\"); cout &lt;&lt; str &lt;&lt; endl; str.erase(1, 3); &nbsp;//从1号位置开始3个字符 cout &lt;&lt; str &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：插入和删除的起始下标都是从0开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.9 string子串功能描述：从字符串中获取想要的子串&nbsp;函数原型：string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串&nbsp;示例：xxxxxxxxxx//子串void test01(){ string str = \"abcdefg\"; string subStr = str.substr(1, 3); cout &lt;&lt; \"subStr = \" &lt;&lt; subStr &lt;&lt; endl; string email = \"hello@sina.com\"; int pos = email.find(\"@\"); string username = email.substr(0, pos); cout &lt;&lt; \"username: \" &lt;&lt; username &lt;&lt; endl; } int main() { test01(); system(\"pause\"); return 0;}总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息&nbsp;&nbsp;&nbsp;3.2 vector容器&nbsp;3.2.1 vector基本概念功能：vector数据结构和数组非常相似，也称为单端数组&nbsp;vector与普通数组区别：不同之处在于数组是静态空间，而vector可以动态扩展&nbsp;动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间&nbsp;&nbsp;vector容器的迭代器是支持随机访问的迭代器&nbsp;&nbsp;3.2.2 vector构造函数&nbsp;功能描述：创建vector容器&nbsp;函数原型：vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。vector(n, elem); //构造函数将n个elem拷贝给本身。vector(const vector &amp;vec); //拷贝构造函数。&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} void test01(){ vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); vector&lt;int&gt; v2(v1.begin(), v1.end()); printVector(v2); vector&lt;int&gt; v3(10, 100); printVector(v3); vector&lt;int&gt; v4(v3); printVector(v4);} int main() { test01(); system(\"pause\"); return 0;}总结：vector的多种构造方式没有可比性，灵活使用即可&nbsp;&nbsp;&nbsp;&nbsp;3.2.3 vector赋值操作&nbsp;功能描述：给vector容器进行赋值&nbsp;函数原型：vector&amp; operator=(const vector &amp;vec);//重载等号操作符assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem); //将n个elem拷贝赋值给本身。&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //赋值操作void test01(){ vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); vector&lt;int&gt;v2; v2 = v1; printVector(v2); vector&lt;int&gt;v3; v3.assign(v1.begin(), v1.end()); printVector(v3); vector&lt;int&gt;v4; v4.assign(10, 100); printVector(v4);} int main() { test01(); system(\"pause\"); return 0;} 总结： vector赋值方式比较简单，使用operator=，或者assign都可以&nbsp;&nbsp;&nbsp;3.2.4 vector容量和大小功能描述：对vector容器的容量和大小操作&nbsp;函数原型：empty(); //判断容器是否为空capacity(); //容器的容量size(); //返回容器中元素的个数resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} void test01(){ vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); if (v1.empty()) { cout &lt;&lt; \"v1为空\" &lt;&lt; endl; } else { cout &lt;&lt; \"v1不为空\" &lt;&lt; endl; cout &lt;&lt; \"v1的容量 = \" &lt;&lt; v1.capacity() &lt;&lt; endl; cout &lt;&lt; \"v1的大小 = \" &lt;&lt; v1.size() &lt;&lt; endl; } //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 v1.resize(15,10); printVector(v1); //resize 重新指定大小 ，若指定的更小，超出部分元素被删除 v1.resize(5); printVector(v1);} int main() { test01(); system(\"pause\"); return 0;} 总结：判断是否为空 --- empty返回元素个数 --- size返回容器容量 --- capacity重新指定大小 --- resize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.5 vector插入和删除功能描述：对vector容器进行插入、删除操作&nbsp;函数原型：push_back(ele); //尾部插入元素elepop_back(); //删除最后一个元素insert(const_iterator pos, ele); //迭代器指向位置pos插入元素eleinsert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素eleerase(const_iterator pos); //删除迭代器指向的元素erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素clear(); //删除容器中所有元素&nbsp;&nbsp;示例：xxxxxxxxxx #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //插入和删除void test01(){ vector&lt;int&gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1);} int main() { test01(); system(\"pause\"); return 0;}总结：尾插 --- push_back尾删 --- pop_back插入 --- insert (位置迭代器)删除 --- erase （位置迭代器）清空 --- clear &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.6 vector数据存取&nbsp;功能描述：对vector中的数据的存取操作&nbsp;函数原型：at(int idx); //返回索引idx所指的数据operator[]; //返回索引idx所指的数据front(); //返回容器中第一个数据元素back(); //返回容器中最后一个数据元素&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt; void test01(){ vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } for (int i = 0; i &lt; v1.size(); i++) { cout &lt;&lt; v1[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; for (int i = 0; i &lt; v1.size(); i++) { cout &lt;&lt; v1.at(i) &lt;&lt; \" \"; } cout &lt;&lt; endl; cout &lt;&lt; \"v1的第一个元素为： \" &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; \"v1的最后一个元素为： \" &lt;&lt; v1.back() &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：除了用迭代器获取vector容器中元素，[ ]和at也可以front返回容器第一个元素back返回容器最后一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.7 vector互换容器功能描述：实现两个容器内元素进行互换&nbsp;函数原型：swap(vec); // 将vec与本身的元素互换&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} void test01(){ vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); vector&lt;int&gt;v2; for (int i = 10; i &gt; 0; i--) { v2.push_back(i); } printVector(v2); //互换容器 cout &lt;&lt; \"互换后\" &lt;&lt; endl; v1.swap(v2); printVector(v1); printVector(v2);} void test02(){ vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) { v.push_back(i); } cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl; v.resize(3); cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl; //收缩内存 vector&lt;int&gt;(v).swap(v); //匿名对象 cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl;} int main() { test01(); test02(); system(\"pause\"); return 0;} 总结：swap可以使两个容器互换，可以达到实用的收缩内存效果&nbsp;&nbsp;&nbsp;&nbsp;3.2.8 vector预留空间功能描述：减少vector在动态扩展容量时的扩展次数&nbsp;函数原型：reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt; void test01(){ vector&lt;int&gt; v; //预留空间 v.reserve(100000); int num = 0; int* p = NULL; for (int i = 0; i &lt; 100000; i++) { v.push_back(i); if (p != &amp;v[0]) { p = &amp;v[0]; num++; } } cout &lt;&lt; \"num:\" &lt;&lt; num &lt;&lt; endl;} int main() { test01(); &nbsp; &nbsp; system(\"pause\"); return 0;}总结：如果数据量较大，可以一开始利用reserve预留空间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3 deque容器3.3.1 deque容器基本概念&nbsp;功能：双端数组，可以对头端进行插入删除操作&nbsp;deque与vector区别：vector对于头部的插入删除效率低，数据量越大，效率越低deque相对而言，对头部的插入删除速度回比vector快vector访问元素时的速度会比deque快,这和两者内部实现有关&nbsp;deque内部工作原理:deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间deque容器的迭代器也是支持随机访问的&nbsp;3.3.2 deque构造函数功能描述：deque容器构造&nbsp;函数原型：deque&lt;T&gt; deqT; //默认构造形式deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。deque(n, elem); //构造函数将n个elem拷贝给本身。deque(const deque &amp;deq); //拷贝构造函数&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;}//deque构造void test01() { deque&lt;int&gt; d1; //无参构造函数 for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque&lt;int&gt; d2(d1.begin(),d1.end()); printDeque(d2); deque&lt;int&gt;d3(10,100); printDeque(d3); deque&lt;int&gt;d4 = d3; printDeque(d4);} int main() { test01(); system(\"pause\"); return 0;}总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可&nbsp;&nbsp;&nbsp;&nbsp;3.3.3 deque赋值操作&nbsp;功能描述：给deque容器进行赋值&nbsp;函数原型：deque&amp; operator=(const deque &amp;deq); //重载等号操作符assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem); //将n个elem拷贝赋值给本身。&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;}//赋值操作void test01(){ deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque&lt;int&gt;d2; d2 = d1; printDeque(d2); deque&lt;int&gt;d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque&lt;int&gt;d4; d4.assign(10, 100); printDeque(d4); } int main() { test01(); system(\"pause\"); return 0;}总结：deque赋值操作也与vector相同，需熟练掌握&nbsp;&nbsp;&nbsp;3.3.4 deque大小操作功能描述：对deque容器的大小进行操作&nbsp;函数原型：deque.empty(); //判断容器是否为空deque.size(); //返回容器中元素的个数deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //大小操作void test01(){ deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } printDeque(d1); //判断容器是否为空 if (d1.empty()) { cout &lt;&lt; \"d1为空!\" &lt;&lt; endl; } else { cout &lt;&lt; \"d1不为空!\" &lt;&lt; endl; //统计大小 cout &lt;&lt; \"d1的大小为：\" &lt;&lt; d1.size() &lt;&lt; endl; } //重新指定大小 d1.resize(15, 1); printDeque(d1); d1.resize(5); printDeque(d1);} int main() { test01(); system(\"pause\"); return 0;}总结：deque没有容量的概念判断是否为空 --- empty返回元素个数 --- size重新指定个数 --- resize&nbsp;&nbsp;&nbsp;&nbsp;3.3.5 deque 插入和删除功能描述：向deque容器中插入和删除数据&nbsp;函数原型：两端插入操作：push_back(elem); //在容器尾部添加一个数据push_front(elem); //在容器头部插入一个数据pop_back(); //删除容器最后一个数据pop_front(); //删除容器第一个数据指定位置操作：insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。clear(); //清空容器的所有数据erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos); //删除pos位置的数据，返回下一个数据的位置。&nbsp;&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;}//两端操作void test01(){ deque&lt;int&gt; d; //尾插 d.push_back(10); d.push_back(20); //头插 d.push_front(100); d.push_front(200); printDeque(d); //尾删 d.pop_back(); //头删 d.pop_front(); printDeque(d);} //插入void test02(){ deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.insert(d.begin(), 1000); printDeque(d); d.insert(d.begin(), 2,10000); printDeque(d); deque&lt;int&gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d.insert(d.begin(), d2.begin(), d2.end()); printDeque(d); } //删除void test03(){ deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.erase(d.begin()); printDeque(d); d.erase(d.begin(), d.end()); d.clear(); printDeque(d);} int main() { //test01(); //test02(); &nbsp; &nbsp;test03(); &nbsp; &nbsp; system(\"pause\"); return 0;} 总结：插入和删除提供的位置是迭代器！尾插 --- push_back尾删 --- pop_back头插 --- push_front头删 --- pop_front&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.6 deque 数据存取&nbsp;功能描述：对deque 中的数据的存取操作&nbsp;函数原型：at(int idx); //返回索引idx所指的数据operator[]; //返回索引idx所指的数据front(); //返回容器中第一个数据元素back(); //返回容器中最后一个数据元素&nbsp;示例：xxxxxxxxxx#include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //数据存取void test01(){ deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); for (int i = 0; i &lt; d.size(); i++) { cout &lt;&lt; d[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; for (int i = 0; i &lt; d.size(); i++) { cout &lt;&lt; d.at(i) &lt;&lt; \" \"; } cout &lt;&lt; endl; cout &lt;&lt; \"front:\" &lt;&lt; d.front() &lt;&lt; endl; cout &lt;&lt; \"back:\" &lt;&lt; d.back() &lt;&lt; endl; } int main() { test01(); system(\"pause\"); return 0;}总结：除了用迭代器获取deque容器中元素，[ ]和at也可以front返回容器第一个元素back返回容器最后一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.7 deque 排序功能描述：利用算法实现对deque容器进行排序&nbsp;算法：sort(iterator beg, iterator end) //对beg和end区间内元素进行排序&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;deque&gt;#include &lt;algorithm&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} void test01(){ deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); sort(d.begin(), d.end()); printDeque(d); } int main() { test01(); system(\"pause\"); return 0;}总结：sort算法非常实用，使用时包含头文件 algorithm即可&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4 案例-评委打分&nbsp;3.4.1 案例描述有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。&nbsp;3.4.2 实现步骤创建五名选手，放到vector中遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中sort算法对deque容器中分数排序，去除最高和最低分deque容器遍历一遍，累加总分获取平均分&nbsp;&nbsp;示例代码：xxxxxxxxxx//选手类class Person{public: Person(string name, int score) { this-&gt;m_Name = name; this-&gt;m_Score = score; } string m_Name; //姓名 int m_Score; &nbsp;//平均分}; void createPerson(vector&lt;Person&gt;&amp;v){ string nameSeed = \"ABCDE\"; for (int i = 0; i &lt; 5; i++) { string name = \"选手\"; name += nameSeed[i]; int score = 0; Person p(name, score); //将创建的person对象 放入到容器中 v.push_back(p); }} //打分void setScore(vector&lt;Person&gt;&amp;v){ for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { //将评委的分数 放入到deque容器中 deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) { int score = rand() % 41 + 60; &nbsp;// 60 ~ 100 d.push_back(score); } //cout &lt;&lt; \"选手： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 打分： \" &lt;&lt; endl; //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) //{ // cout &lt;&lt; *dit &lt;&lt; \" \"; //} //cout &lt;&lt; endl; //排序 sort(d.begin(), d.end()); //去除最高和最低分 d.pop_back(); d.pop_front(); //取平均分 int sum = 0; for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) { sum += *dit; //累加每个评委的分数 } int avg = sum / d.size(); //将平均分 赋值给选手身上 it-&gt;m_Score = avg; } } void showScore(vector&lt;Person&gt;&amp;v){ for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 平均分： \" &lt;&lt; it-&gt;m_Score &lt;&lt; endl; }} int main() { //随机数种子 srand((unsigned int)time(NULL)); //1、创建5名选手 vector&lt;Person&gt;v; &nbsp;//存放选手容器 createPerson(v); //测试 //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) //{ // cout &lt;&lt; \"姓名： \" &lt;&lt; (*it).m_Name &lt;&lt; \" 分数： \" &lt;&lt; (*it).m_Score &lt;&lt; endl; //} //2、给5名选手打分 setScore(v); //3、显示最后得分 showScore(v); system(\"pause\"); return 0;}总结： 选取不同的容器操作数据，可以提升代码的效率&nbsp;&nbsp;&nbsp;3.5 stack容器3.5.1 stack 基本概念&nbsp;概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口&nbsp;&nbsp;栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为栈中进入数据称为 --- 入栈 push栈中弹出数据称为 --- 出栈 pop&nbsp;生活中的栈：&nbsp;&nbsp;&nbsp;3.5.2 stack 常用接口功能描述：栈容器常用的对外接口&nbsp;构造函数：stack&lt;T&gt; stk; //stack采用模板类实现， stack对象的默认构造形式stack(const stack &amp;stk); //拷贝构造函数赋值操作：stack&amp; operator=(const stack &amp;stk); //重载等号操作符数据存取：push(elem); //向栈顶添加元素pop(); //从栈顶移除第一个元素top(); //返回栈顶元素大小操作：empty(); //判断堆栈是否为空size(); //返回栈的大小&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;stack&gt; //栈容器常用接口void test01(){ //创建栈容器 栈容器必须符合先进后出 stack&lt;int&gt; s; //向栈中添加元素，叫做 压栈 入栈 s.push(10); s.push(20); s.push(30); while (!s.empty()) { //输出栈顶元素 cout &lt;&lt; \"栈顶元素为： \" &lt;&lt; s.top() &lt;&lt; endl; //弹出栈顶元素 s.pop(); } cout &lt;&lt; \"栈的大小为：\" &lt;&lt; s.size() &lt;&lt; endl; } int main() { test01(); system(\"pause\"); return 0;}总结：入栈 --- push出栈 --- pop返回栈顶 --- top判断栈是否为空 --- empty返回栈大小 --- size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6 queue 容器3.6.1 queue 基本概念&nbsp;概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口&nbsp;&nbsp;&nbsp;队列容器允许从一端新增元素，从另一端移除元素队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为队列中进数据称为 --- 入队 push队列中出数据称为 --- 出队 pop&nbsp;生活中的队列：&nbsp;&nbsp;&nbsp;3.6.2 queue 常用接口&nbsp;功能描述：栈容器常用的对外接口&nbsp;构造函数：queue&lt;T&gt; que; //queue采用模板类实现，queue对象的默认构造形式queue(const queue &amp;que); //拷贝构造函数赋值操作：queue&amp; operator=(const queue &amp;que); //重载等号操作符数据存取：push(elem); //往队尾添加元素pop(); //从队头移除第一个元素back(); //返回最后一个元素front(); //返回第一个元素大小操作：empty(); //判断堆栈是否为空size(); //返回栈的大小&nbsp;示例：xxxxxxxxxx#include &lt;queue&gt;#include &lt;string&gt;class Person{public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age;}; void test01() { //创建队列 queue&lt;Person&gt; q; //准备数据 Person p1(\"唐僧\", 30); Person p2(\"孙悟空\", 1000); Person p3(\"猪八戒\", 900); Person p4(\"沙僧\", 800); //向队列中添加元素 入队操作 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //队列不提供迭代器，更不支持随机访问 while (!q.empty()) { //输出队头元素 cout &lt;&lt; \"队头元素-- 姓名： \" &lt;&lt; q.front().m_Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; \" 年龄： \"&lt;&lt; q.front().m_Age &lt;&lt; endl; &nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; \"队尾元素-- 姓名： \" &lt;&lt; q.back().m_Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; \" 年龄： \" &lt;&lt; q.back().m_Age &lt;&lt; endl; &nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; endl; //弹出队头元素 q.pop(); } cout &lt;&lt; \"队列大小为：\" &lt;&lt; q.size() &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：入队 --- push出队 --- pop返回队头元素 --- front返回队尾元素 --- back判断队是否为空 --- empty返回队列大小 --- size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7 list容器3.7.1 list基本概念&nbsp;功能：将数据进行链式存储链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的&nbsp;链表的组成：链表由一系列结点组成&nbsp;结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域&nbsp;STL中的链表是一个双向循环链表&nbsp;由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器&nbsp;list的优点：采用动态存储分配，不会造成内存浪费和溢出链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素list的缺点：链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大&nbsp;List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。&nbsp;总结：STL中List和vector是两个最常被使用的容器，各有优缺点&nbsp;&nbsp;3.7.2 list构造函数功能描述：创建list容器&nbsp;函数原型：list&lt;T&gt; lst; //list采用采用模板类实现,对象的默认构造形式：list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。list(n,elem); //构造函数将n个elem拷贝给本身。list(const list &amp;lst); //拷贝构造函数。&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} void test01(){ list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); list&lt;int&gt;L2(L1.begin(),L1.end()); printList(L2); list&lt;int&gt;L3(L2); printList(L3); list&lt;int&gt;L4(10, 1000); printList(L4);} int main() { test01(); system(\"pause\"); return 0;}总结：list构造方式同其他几个STL常用容器，熟练掌握即可&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3 list 赋值和交换功能描述：给list容器进行赋值，以及交换list容器函数原型：assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem); //将n个elem拷贝赋值给本身。list&amp; operator=(const list &amp;lst); //重载等号操作符swap(lst); //将lst与本身的元素互换。&nbsp;示例：xxxxxxxxxx#include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //赋值和交换void test01(){ list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //赋值 list&lt;int&gt;L2; L2 = L1; printList(L2); list&lt;int&gt;L3; L3.assign(L2.begin(), L2.end()); printList(L3); list&lt;int&gt;L4; L4.assign(10, 100); printList(L4); } //交换void test02(){ list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list&lt;int&gt;L2; L2.assign(10, 100); cout &lt;&lt; \"交换前： \" &lt;&lt; endl; printList(L1); printList(L2); cout &lt;&lt; endl; L1.swap(L2); cout &lt;&lt; \"交换后： \" &lt;&lt; endl; printList(L1); printList(L2); } int main() { //test01(); test02(); system(\"pause\"); return 0;}总结：list赋值和交换操作能够灵活运用即可&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.4 list 大小操作功能描述：对list容器的大小进行操作&nbsp;函数原型：size(); //返回容器中元素的个数empty(); //判断容器是否为空resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。&nbsp;示例：xxxxxxxxxx#include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //大小操作void test01(){ list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) { cout &lt;&lt; \"L1为空\" &lt;&lt; endl; } else { cout &lt;&lt; \"L1不为空\" &lt;&lt; endl; cout &lt;&lt; \"L1的大小为： \" &lt;&lt; L1.size() &lt;&lt; endl; } //重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1);} int main() { test01(); system(\"pause\"); return 0;}总结：判断是否为空 --- empty返回元素个数 --- size重新指定个数 --- resize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.5 list 插入和删除功能描述：对list容器进行数据的插入和删除&nbsp;函数原型：push_back(elem);//在容器尾部加入一个元素pop_back();//删除容器中最后一个元素push_front(elem);//在容器开头插入一个元素pop_front();//从容器开头移除第一个元素insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos);//删除pos位置的数据，返回下一个数据的位置。remove(elem);//删除容器中所有与elem值匹配的元素。&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //插入和删除void test01(){ list&lt;int&gt; L; //尾插 L.push_back(10); L.push_back(20); L.push_back(30); //头插 L.push_front(100); L.push_front(200); L.push_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list&lt;int&gt;::iterator it = L.begin(); L.insert(++it, 1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.push_back(10000); L.push_back(10000); L.push_back(10000); printList(L); L.remove(10000); printList(L); &nbsp; &nbsp; &nbsp; &nbsp;//清空 L.clear(); printList(L);} int main() { test01(); system(\"pause\"); return 0;}总结：尾插 --- push_back尾删 --- pop_back头插 --- push_front头删 --- pop_front插入 --- insert删除 --- erase移除 --- remove清空 --- clear&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.6 list 数据存取功能描述：对list容器中数据进行存取&nbsp;函数原型：front(); //返回第一个元素。back(); //返回最后一个元素。&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;list&gt; //数据存取void test01(){ list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据 //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据 cout &lt;&lt; \"第一个元素为： \" &lt;&lt; L1.front() &lt;&lt; endl; cout &lt;&lt; \"最后一个元素为： \" &lt;&lt; L1.back() &lt;&lt; endl; //list容器的迭代器是双向迭代器，不支持随机访问 list&lt;int&gt;::iterator it = L1.begin(); //it = it + 1;//错误，不可以跳跃访问，即使是+1} int main() { test01(); system(\"pause\"); return 0;} 总结：list容器中不可以通过[]或者at方式访问数据返回第一个元素 --- front返回最后一个元素 --- back&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.7 list 反转和排序功能描述：将容器中的元素反转，以及将容器中的数据进行排序&nbsp;函数原型：reverse(); //反转链表sort(); //链表排序&nbsp;&nbsp;示例：xxxxxxxxxxvoid printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} bool myCompare(int val1 , int val2){ return val1 &gt; val2;} //反转和排序void test01(){ list&lt;int&gt; L; L.push_back(90); L.push_back(30); L.push_back(20); L.push_back(70); printList(L); //反转容器的元素 L.reverse(); printList(L); //排序 L.sort(); //默认的排序规则 从小到大 printList(L); L.sort(myCompare); //指定规则，从大到小 printList(L);} int main() { test01(); system(\"pause\"); return 0;}总结：反转 --- reverse排序 --- sort （成员函数）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.8 排序案例案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序&nbsp;示例：xxxxxxxxxx#include &lt;list&gt;#include &lt;string&gt;class Person {public: Person(string name, int age , int height) { m_Name = name; m_Age = age; m_Height = height; } public: string m_Name; &nbsp;//姓名 int m_Age; &nbsp; &nbsp; &nbsp;//年龄 int m_Height; &nbsp; //身高}; bool ComparePerson(Person&amp; p1, Person&amp; p2) { if (p1.m_Age == p2.m_Age) { return p1.m_Height &nbsp;&gt; p2.m_Height; } else { return &nbsp;p1.m_Age &lt; p2.m_Age; } } void test01() { list&lt;Person&gt; L; Person p1(\"刘备\", 35 , 175); Person p2(\"曹操\", 45 , 180); Person p3(\"孙权\", 40 , 170); Person p4(\"赵云\", 25 , 190); Person p5(\"张飞\", 35 , 160); Person p6(\"关羽\", 35 , 200); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); L.push_back(p5); L.push_back(p6); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄： \" &lt;&lt; it-&gt;m_Age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; \" 身高： \" &lt;&lt; it-&gt;m_Height &lt;&lt; endl; } cout &lt;&lt; \"---------------------------------\" &lt;&lt; endl; L.sort(ComparePerson); //排序 for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄： \" &lt;&lt; it-&gt;m_Age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; \" 身高： \" &lt;&lt; it-&gt;m_Height &lt;&lt; endl; }} int main() { test01(); system(\"pause\"); return 0;}&nbsp;总结：对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8 set/ multiset 容器3.8.1 set基本概念简介：所有元素都会在插入时自动被排序&nbsp;&nbsp;本质：set/multiset属于关联式容器，底层结构是用二叉树实现。&nbsp;&nbsp;set和multiset区别：set不允许容器中有重复的元素multiset允许容器中有重复的元素&nbsp;&nbsp;3.8.2 set构造和赋值功能描述：创建set容器以及赋值&nbsp;构造：set&lt;T&gt; st; //默认构造函数：set(const set &amp;st); //拷贝构造函数赋值：set&amp; operator=(const set &amp;st); //重载等号操作符&nbsp;示例：xxxxxxxxxx#include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s){ for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //构造和赋值void test01(){ set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //拷贝构造 set&lt;int&gt;s2(s1); printSet(s2); //赋值 set&lt;int&gt;s3; s3 = s2; printSet(s3);} int main() { test01(); system(\"pause\"); return 0;}总结：set容器插入数据时用insertset容器插入数据的数据会自动排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.3 set大小和交换功能描述：统计set容器大小以及交换set容器&nbsp;函数原型：size(); //返回容器中元素的数目empty(); //判断容器是否为空swap(st); //交换两个集合容器&nbsp;示例：xxxxxxxxxx#include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s){ for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //大小void test01(){ set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); if (s1.empty()) { cout &lt;&lt; \"s1为空\" &lt;&lt; endl; } else { cout &lt;&lt; \"s1不为空\" &lt;&lt; endl; cout &lt;&lt; \"s1的大小为： \" &lt;&lt; s1.size() &lt;&lt; endl; } } //交换void test02(){ set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); set&lt;int&gt; s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); cout &lt;&lt; \"交换前\" &lt;&lt; endl; printSet(s1); printSet(s2); cout &lt;&lt; endl; cout &lt;&lt; \"交换后\" &lt;&lt; endl; s1.swap(s2); printSet(s1); printSet(s2);} int main() { //test01(); test02(); system(\"pause\"); return 0;}总结：统计大小 --- size判断是否为空 --- empty交换容器 --- swap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.4 set插入和删除功能描述：set容器进行插入数据和删除数据&nbsp;&nbsp;函数原型：insert(elem); //在容器中插入元素。clear(); //清除所有元素erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(elem); //删除容器中值为elem的元素。&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s){ for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} //插入和删除void test01(){ set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1);} int main() { test01(); system(\"pause\"); return 0;}总结：插入 --- insert删除 --- erase清空 --- clear&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.5 set查找和统计功能描述：对set容器进行查找数据以及统计数据&nbsp;函数原型：find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();count(key); //统计key的元素个数&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;set&gt; //查找和统计void test01(){ set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); //查找 set&lt;int&gt;::iterator pos = s1.find(30); if (pos != s1.end()) { cout &lt;&lt; \"找到了元素 ： \" &lt;&lt; *pos &lt;&lt; endl; } else { cout &lt;&lt; \"未找到元素\" &lt;&lt; endl; } //统计 int num = s1.count(30); cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：查找 --- find （返回的是迭代器）统计 --- count （对于set，结果为0或者1）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.6 set和multiset区别学习目标：掌握set和multiset的区别&nbsp;区别：set不可以插入重复数据，而multiset可以set插入数据的同时会返回插入结果，表示插入是否成功multiset不会检测数据，因此可以插入重复数据&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;set&gt; //set和multiset区别void test01(){ set&lt;int&gt; s; pair&lt;set&lt;int&gt;::iterator, bool&gt; &nbsp;ret = s.insert(10); if (ret.second) { cout &lt;&lt; \"第一次插入成功!\" &lt;&lt; endl; } else { cout &lt;&lt; \"第一次插入失败!\" &lt;&lt; endl; } ret = s.insert(10); if (ret.second) { cout &lt;&lt; \"第二次插入成功!\" &lt;&lt; endl; } else { cout &lt;&lt; \"第二次插入失败!\" &lt;&lt; endl; } &nbsp; &nbsp; //multiset multiset&lt;int&gt; ms; ms.insert(10); ms.insert(10); for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：如果不允许插入重复数据可以利用set如果需要插入重复数据利用multiset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.7 pair对组创建功能描述：成对出现的数据，利用对组可以返回两个数据&nbsp;&nbsp;两种创建方式：pair&lt;type, type&gt; p ( value1, value2 );pair&lt;type, type&gt; p = make_pair( value1, value2 );&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;string&gt; //对组创建void test01(){ pair&lt;string, int&gt; p(string(\"Tom\"), 20); cout &lt;&lt; \"姓名： \" &lt;&lt; &nbsp;p.first &lt;&lt; \" 年龄： \" &lt;&lt; p.second &lt;&lt; endl; pair&lt;string, int&gt; p2 = make_pair(\"Jerry\", 10); cout &lt;&lt; \"姓名： \" &lt;&lt; p2.first &lt;&lt; \" 年龄： \" &lt;&lt; p2.second &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：两种方式都可以创建对组，记住一种即可&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.8 set容器排序学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则&nbsp;主要技术点：利用仿函数，可以改变排序规则&nbsp;&nbsp;示例一 set存放内置数据类型xxxxxxxxxx#include &lt;set&gt; class MyCompare {public: bool operator()(int v1, int v2) { return v1 &gt; v2; }};void test01() { &nbsp; &nbsp; set&lt;int&gt; s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(30); s1.insert(50); //默认从小到大 for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; //指定排序规则 set&lt;int,MyCompare&gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(30); s2.insert(50); for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：利用仿函数可以指定set容器的排序规则&nbsp;示例二 set存放自定义数据类型xxxxxxxxxx#include &lt;set&gt;#include &lt;string&gt; class Person{public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; };class comparePerson{public: bool operator()(const Person&amp; p1, const Person &amp;p2) { //按照年龄进行排序 降序 return p1.m_Age &gt; p2.m_Age; }}; void test01(){ set&lt;Person, comparePerson&gt; s; Person p1(\"刘备\", 23); Person p2(\"关羽\", 27); Person p3(\"张飞\", 25); Person p4(\"赵云\", 21); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄： \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; }}int main() { test01(); system(\"pause\"); return 0;}总结：对于自定义数据类型，set必须指定排序规则才可以插入数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9 map/ multimap容器3.9.1 map基本概念简介：map中所有元素都是pairpair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）所有元素都会根据元素的键值自动排序&nbsp;本质：map/multimap属于关联式容器，底层结构是用二叉树实现。&nbsp;优点：可以根据key值快速找到value值&nbsp;map和multimap区别：map不允许容器中有重复key值元素multimap允许容器中有重复key值元素&nbsp;3.9.2 map构造和赋值功能描述：对map容器进行构造和赋值操作函数原型：构造：map&lt;T1, T2&gt; mp; //map默认构造函数: map(const map &amp;mp); //拷贝构造函数&nbsp;赋值：map&amp; operator=(const map &amp;mp); //重载等号操作符&nbsp;示例：xxxxxxxxxx#include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m){ for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; \"key = \" &lt;&lt; it-&gt;first &lt;&lt; \" value = \" &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl;} void test01(){ map&lt;int,int&gt;m; //默认构造 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); printMap(m); map&lt;int, int&gt;m2(m); //拷贝构造 printMap(m2); map&lt;int, int&gt;m3; m3 = m2; //赋值 printMap(m3);} int main() { test01(); system(\"pause\"); return 0;}总结：map中所有元素都是成对出现，插入数据时候要使用对组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9.3 map大小和交换功能描述：统计map容器大小以及交换map容器&nbsp;&nbsp;函数原型：size(); //返回容器中元素的数目empty(); //判断容器是否为空swap(st); //交换两个集合容器&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m){ for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; \"key = \" &lt;&lt; it-&gt;first &lt;&lt; \" value = \" &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl;} void test01(){ map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); if (m.empty()) { cout &lt;&lt; \"m为空\" &lt;&lt; endl; } else { cout &lt;&lt; \"m不为空\" &lt;&lt; endl; cout &lt;&lt; \"m的大小为： \" &lt;&lt; m.size() &lt;&lt; endl; }} //交换void test02(){ map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); map&lt;int, int&gt;m2; m2.insert(pair&lt;int, int&gt;(4, 100)); m2.insert(pair&lt;int, int&gt;(5, 200)); m2.insert(pair&lt;int, int&gt;(6, 300)); cout &lt;&lt; \"交换前\" &lt;&lt; endl; printMap(m); printMap(m2); cout &lt;&lt; \"交换后\" &lt;&lt; endl; m.swap(m2); printMap(m); printMap(m2);} int main() { test01(); test02(); system(\"pause\"); return 0;}总结：统计大小 --- size判断是否为空 --- empty交换容器 --- swap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9.4 map插入和删除功能描述：map容器进行插入数据和删除数据&nbsp;&nbsp;函数原型：insert(elem); //在容器中插入元素。clear(); //清除所有元素erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(key); //删除容器中值为key的元素。&nbsp;示例：xxxxxxxxxx#include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m){ for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; \"key = \" &lt;&lt; it-&gt;first &lt;&lt; \" value = \" &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl;} void test01(){ //插入 map&lt;int, int&gt; m; //第一种插入方式 m.insert(pair&lt;int, int&gt;(1, 10)); //第二种插入方式 m.insert(make_pair(2, 20)); //第三种插入方式 m.insert(map&lt;int, int&gt;::value_type(3, 30)); //第四种插入方式 m[4] = 40; printMap(m); //删除 m.erase(m.begin()); printMap(m); m.erase(3); printMap(m); //清空 m.erase(m.begin(),m.end()); m.clear(); printMap(m);} int main() { test01(); system(\"pause\"); return 0;}总结：map插入方式很多，记住其一即可插入 --- insert 删除 --- erase清空 --- clear&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9.5 map查找和统计功能描述：对map容器进行查找数据以及统计数据&nbsp;函数原型：find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();count(key); //统计key的元素个数&nbsp;示例：xxxxxxxxxx#include &lt;map&gt; //查找和统计void test01(){ map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); //查找 map&lt;int, int&gt;::iterator pos = m.find(3); if (pos != m.end()) { cout &lt;&lt; \"找到了元素 key = \" &lt;&lt; (*pos).first &lt;&lt; \" value = \" &lt;&lt; (*pos).second &lt;&lt; endl; } else { cout &lt;&lt; \"未找到元素\" &lt;&lt; endl; } //统计 int num = m.count(3); cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：查找 --- find （返回的是迭代器）统计 --- count （对于map，结果为0或者1）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9.6 map容器排序学习目标：map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则&nbsp;&nbsp;主要技术点:利用仿函数，可以改变排序规则&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;map&gt; class MyCompare {public: bool operator()(int v1, int v2) { return v1 &gt; v2; }}; void test01() { //默认从小到大排序 //利用仿函数实现从大到小排序 map&lt;int, int, MyCompare&gt; m; m.insert(make_pair(1, 10)); m.insert(make_pair(2, 20)); m.insert(make_pair(3, 30)); m.insert(make_pair(4, 40)); m.insert(make_pair(5, 50)); for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; \"key:\" &lt;&lt; it-&gt;first &lt;&lt; \" value:\" &lt;&lt; it-&gt;second &lt;&lt; endl; }}int main() { test01(); system(\"pause\"); return 0;}总结：利用仿函数可以指定map容器的排序规则对于自定义数据类型，map必须要指定排序规则,同set容器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10 案例-员工分组3.10.1 案例描述公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作员工信息有: 姓名 工资组成；部门分为：策划、美术、研发随机给10名员工分配部门和工资通过multimap进行信息的插入 key(部门编号) value(员工)分部门显示员工信息&nbsp;&nbsp;3.10.2 实现步骤创建10名员工，放到vector中遍历vector容器，取出每个员工，进行随机分组分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中分部门显示员工信息&nbsp;&nbsp;案例代码：xxxxxxxxxx#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt; /*- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发- 随机给10名员工分配部门和工资- 通过multimap进行信息的插入 key(部门编号) value(员工)- 分部门显示员工信息*/ #define CEHUA 0#define MEISHU 1#define YANFA 2 class Worker{public: string m_Name; int m_Salary;}; void createWorker(vector&lt;Worker&gt;&amp;v){ string nameSeed = \"ABCDEFGHIJ\"; for (int i = 0; i &lt; 10; i++) { Worker worker; worker.m_Name = \"员工\"; worker.m_Name += nameSeed[i]; worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999 //将员工放入到容器中 v.push_back(worker); }} //员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m){ for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++) { //产生随机部门编号 int deptId = rand() % 3; // 0 1 2 //将员工插入到分组中 //key部门编号，value具体员工 m.insert(make_pair(deptId, *it)); }} void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m){ // 0 A B C &nbsp; 1 D E &nbsp; 2 F G ... cout &lt;&lt; \"策划部门：\" &lt;&lt; endl; multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA); int count = m.count(CEHUA); // 统计具体人数 int index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++) { cout &lt;&lt; \"姓名： \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" 工资： \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } cout &lt;&lt; \"----------------------\" &lt;&lt; endl; cout &lt;&lt; \"美术部门： \" &lt;&lt; endl; pos = m.find(MEISHU); count = m.count(MEISHU); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) { cout &lt;&lt; \"姓名： \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" 工资： \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } cout &lt;&lt; \"----------------------\" &lt;&lt; endl; cout &lt;&lt; \"研发部门： \" &lt;&lt; endl; pos = m.find(YANFA); count = m.count(YANFA); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) { cout &lt;&lt; \"姓名： \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" 工资： \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } } int main() { srand((unsigned int)time(NULL)); //1、创建员工 vector&lt;Worker&gt;vWorker; createWorker(vWorker); //2、员工分组 multimap&lt;int, Worker&gt;mWorker; setGroup(vWorker, mWorker); //3、分组显示员工 showWorkerByGourp(mWorker); ////测试 //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) //{ // cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 工资： \" &lt;&lt; it-&gt;m_Salary &lt;&lt; endl; //} system(\"pause\"); return 0;}总结：当数据以键值对形式存在，可以考虑用map 或 multimap&nbsp;&nbsp;&nbsp;4 STL- 函数对象4.1 函数对象4.1.1 函数对象概念概念：重载函数调用操作符的类，其对象常称为函数对象函数对象使用重载的()时，行为类似函数调用，也叫仿函数&nbsp;本质：函数对象(仿函数)是一个类，不是一个函数&nbsp;4.1.2 函数对象使用特点：函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值函数对象超出普通函数的概念，函数对象可以有自己的状态函数对象可以作为参数传递&nbsp;&nbsp;示例:xxxxxxxxxx#include &lt;string&gt; //1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值class MyAdd{public : int operator()(int v1,int v2) { return v1 + v2; }}; void test01(){ MyAdd myAdd; cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;} //2、函数对象可以有自己的状态class MyPrint{public: MyPrint() { count = 0; } void operator()(string test) { cout &lt;&lt; test &lt;&lt; endl; count++; //统计使用次数 } int count; //内部自己的状态};void test02(){ MyPrint myPrint; myPrint(\"hello world\"); myPrint(\"hello world\"); myPrint(\"hello world\"); cout &lt;&lt; \"myPrint调用次数为： \" &lt;&lt; myPrint.count &lt;&lt; endl;} //3、函数对象可以作为参数传递void doPrint(MyPrint &amp;mp , string test){ mp(test);} void test03(){ MyPrint myPrint; doPrint(myPrint, \"Hello C++\");} int main() { //test01(); //test02(); test03(); system(\"pause\"); return 0;}总结：仿函数写法非常灵活，可以作为参数进行传递。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2 谓词4.2.1 谓词概念&nbsp;概念：返回bool类型的仿函数称为谓词如果operator()接受一个参数，那么叫做一元谓词如果operator()接受两个参数，那么叫做二元谓词&nbsp;&nbsp;4.2.2 一元谓词示例：xxxxxxxxxx#include &lt;vector&gt;#include &lt;algorithm&gt; //1.一元谓词struct GreaterFive{ bool operator()(int val) { return val &gt; 5; }}; void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) { cout &lt;&lt; \"没找到!\" &lt;&lt; endl; } else { cout &lt;&lt; \"找到:\" &lt;&lt; *it &lt;&lt; endl; } } int main() { test01(); system(\"pause\"); return 0;}总结：参数只有一个的谓词，称为一元谓词&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.3 二元谓词示例：xxxxxxxxxx#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare{public: bool operator()(int num1, int num2) { return num1 &gt; num2; }}; void test01(){ vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; cout &lt;&lt; \"----------------------------\" &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：参数只有两个的谓词，称为二元谓词&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3 内建函数对象4.3.1 内建函数对象意义概念：STL内建了一些函数对象&nbsp;分类:算术仿函数关系仿函数逻辑仿函数用法：这些仿函数所产生的对象，用法和一般函数完全相同使用内建函数对象，需要引入头文件 #include&lt;functional&gt;&nbsp;&nbsp;&nbsp;4.3.2 算术仿函数功能描述：实现四则运算其中negate是一元运算，其他都是二元运算&nbsp;仿函数原型：template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数template&lt;class T&gt; T minus&lt;T&gt; //减法仿函数template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数template&lt;class T&gt; T modulus&lt;T&gt; //取模仿函数template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数&nbsp;示例：xxxxxxxxxx#include &lt;functional&gt;//negatevoid test01(){ negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl;} //plusvoid test02(){ plus&lt;int&gt; p; cout &lt;&lt; p(10, 20) &lt;&lt; endl;} int main() { test01(); test02(); system(\"pause\"); return 0;}总结：使用内建函数对象时，需要引入头文件 #include &lt;functional&gt;&nbsp;&nbsp;&nbsp;&nbsp;4.3.3 关系仿函数功能描述：实现关系对比&nbsp;仿函数原型：template&lt;class T&gt; bool equal_to&lt;T&gt; //等于template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于template&lt;class T&gt; bool greater&lt;T&gt; //大于template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于template&lt;class T&gt; bool less&lt;T&gt; //小于template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于&nbsp;示例：xxxxxxxxxx#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; class MyCompare{public: bool operator()(int v1,int v2) { return v1 &gt; v2; }};void test01(){ vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数 大于仿函数 sort(v.begin(), v.end(), greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：关系仿函数中最常用的就是greater&lt;&gt;大于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3.4 逻辑仿函数功能描述：实现逻辑运算&nbsp;函数原型：template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与template&lt;class T&gt; bool logical_or&lt;T&gt; //逻辑或template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01(){ vector&lt;bool&gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; //逻辑非 将v容器搬运到v2中，并执行逻辑非运算 vector&lt;bool&gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), &nbsp;v2.begin(), logical_not&lt;bool&gt;()); for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：逻辑仿函数实际应用较少，了解即可&nbsp;&nbsp;&nbsp;5 STL- 常用算法&nbsp;概述:算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。&nbsp;&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等&lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数&lt;functional&gt;定义了一些模板类,用以声明函数对象。&nbsp;&nbsp;5.1 常用遍历算法学习目标：掌握常用的遍历算法&nbsp;算法简介：for_each //遍历容器transform //搬运容器到另一个容器中&nbsp;&nbsp;5.1.1 for_each功能描述：实现遍历容器函数原型：for_each(iterator beg, iterator end, _func);// 遍历算法 遍历容器元素// beg 开始迭代器// end 结束迭代器// _func 函数或者函数对象&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; //普通函数void print01(int val) { cout &lt;&lt; val &lt;&lt; \" \";}//函数对象class print02 { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; //for_each算法基本用法void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //遍历算法 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握&nbsp;&nbsp;&nbsp;&nbsp;5.1.2 transform功能描述：搬运容器到另一个容器中函数原型：transform(iterator beg1, iterator end1, iterator beg2, _func);//beg1 源容器开始迭代器//end1 源容器结束迭代器//beg2 目标容器开始迭代器//_func 函数或者函数对象&nbsp;示例：xxxxxxxxxx#include&lt;vector&gt;#include&lt;algorithm&gt; //常用遍历算法 搬运 transform class TransForm{public: int operator()(int val) { return val; } }; class MyPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } vector&lt;int&gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint());} int main() { test01(); system(\"pause\"); return 0;}总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运&nbsp;&nbsp;&nbsp;5.2 常用查找算法学习目标：掌握常用的查找算法&nbsp;&nbsp;算法简介：find //查找元素find_if //按条件查找元素adjacent_find //查找相邻重复元素binary_search //二分查找法count //统计元素个数count_if //按条件统计元素个数&nbsp;5.2.1 find功能描述：查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()&nbsp;函数原型：find(iterator beg, iterator end, value);// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置// beg 开始迭代器// end 结束迭代器// value 查找的元素&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i + 1); } //查找容器中是否有 5 这个元素 vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) { cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; } else { cout &lt;&lt; \"找到:\" &lt;&lt; *it &lt;&lt; endl; }} class Person {public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //重载== bool operator==(const Person&amp; p) { if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return true; } return false; } public: string m_Name; int m_Age;}; void test02() { vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) { cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; } else { cout &lt;&lt; \"找到姓名:\" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; }}总结： 利用find可以在容器中找指定的元素，返回值是迭代器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 find_if功能描述：按条件查找元素函数原型：find_if(iterator beg, iterator end, _Pred);// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置// beg 开始迭代器// end 结束迭代器// _Pred 函数或者谓词（返回bool类型的仿函数）&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt; //内置数据类型class GreaterFive{public: bool operator()(int val) { return val &gt; 5; }}; void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i + 1); } vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) { cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; } else { cout &lt;&lt; \"找到大于5的数字:\" &lt;&lt; *it &lt;&lt; endl; }} //自定义数据类型class Person {public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; }public: string m_Name; int m_Age;}; class Greater20{public: bool operator()(Person &amp;p) { return p.m_Age &gt; 20; } }; void test02() { vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) { cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; } else { cout &lt;&lt; \"找到姓名:\" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; }} int main() { //test01(); test02(); system(\"pause\"); return 0;}总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 adjacent_find功能描述：查找相邻重复元素&nbsp;函数原型：adjacent_find(iterator beg, iterator end);// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器// beg 开始迭代器// end 结束迭代器&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; void test01(){ vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) { cout &lt;&lt; \"找不到!\" &lt;&lt; endl; } else { cout &lt;&lt; \"找到相邻重复元素为:\" &lt;&lt; *it &lt;&lt; endl; }}总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法&nbsp;&nbsp;&nbsp;&nbsp;5.2.4 binary_search功能描述：查找指定元素是否存在&nbsp;函数原型：bool binary_search(iterator beg, iterator end, value);// 查找指定的元素，查到 返回true 否则false// 注意: 在无序序列中不可用// beg 开始迭代器// end 结束迭代器// value 查找的元素&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; void test01(){ vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) { cout &lt;&lt; \"找到了\" &lt;&lt; endl; } else { cout &lt;&lt; \"未找到\" &lt;&lt; endl; }} int main() { test01(); system(\"pause\"); return 0;}总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列&nbsp;&nbsp;&nbsp;&nbsp;5.2.5 count功能描述：统计元素个数&nbsp;函数原型：count(iterator beg, iterator end, value);// 统计元素出现次数// beg 开始迭代器// end 结束迭代器// value 统计的元素&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; //内置数据类型void test01(){ vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout &lt;&lt; \"4的个数为： \" &lt;&lt; num &lt;&lt; endl;} //自定义数据类型class Person{public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } bool operator==(const Person &amp; p) { if (this-&gt;m_Age == p.m_Age) { return true; } else { return false; } } string m_Name; int m_Age;}; void test02(){ vector&lt;Person&gt; v; Person p1(\"刘备\", 35); Person p2(\"关羽\", 35); Person p3(\"张飞\", 35); Person p4(\"赵云\", 30); Person p5(\"曹操\", 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); &nbsp; &nbsp; &nbsp; &nbsp;Person p(\"诸葛亮\",35); int num = count(v.begin(), v.end(), p); cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl;}int main() { //test01(); test02(); system(\"pause\"); return 0;}总结： 统计自定义数据类型时候，需要配合重载 operator==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.6 count_if功能描述：按条件统计元素个数函数原型：count_if(iterator beg, iterator end, _Pred);// 按条件统计元素出现次数// beg 开始迭代器// end 结束迭代器// _Pred 谓词&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; class Greater4{public: bool operator()(int val) { return val &gt;= 4; }}; //内置数据类型void test01(){ vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout &lt;&lt; \"大于4的个数为： \" &lt;&lt; num &lt;&lt; endl;} //自定义数据类型class Person{public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age;}; class AgeLess35{public: bool operator()(const Person &amp;p) { return p.m_Age &lt; 35; }};void test02(){ vector&lt;Person&gt; v; Person p1(\"刘备\", 35); Person p2(\"关羽\", 35); Person p3(\"张飞\", 35); Person p4(\"赵云\", 30); Person p5(\"曹操\", 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout &lt;&lt; \"小于35岁的个数：\" &lt;&lt; num &lt;&lt; endl;} int main() { //test01(); test02(); system(\"pause\"); return 0;}总结：按值统计用count，按条件统计用count_if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3 常用排序算法学习目标：掌握常用的排序算法算法简介：sort //对容器内元素进行排序random_shuffle //洗牌 指定范围内的元素随机调整次序merge // 容器元素合并，并存储到另一容器中reverse // 反转指定范围的元素&nbsp;&nbsp;5.3.1 sort功能描述：对容器内元素进行排序&nbsp;&nbsp;函数原型：sort(iterator beg, iterator end, _Pred);// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置// beg 开始迭代器// end 结束迭代器// _Pred 谓词&nbsp;&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; void myPrint(int val){ cout &lt;&lt; val &lt;&lt; \" \";} void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：sort属于开发中最常用的算法之一，需熟练掌握&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.2 random_shuffle功能描述：洗牌 指定范围内的元素随机调整次序&nbsp;函数原型：random_shuffle(iterator beg, iterator end);// 指定范围内的元素随机调整次序// beg 开始迭代器// end 结束迭代器&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ srand((unsigned int)time(NULL)); vector&lt;int&gt; v; for(int i = 0 ; i &lt; 10;i++) { v.push_back(i); } for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //打乱顺序 random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.3 merge功能描述：两个容器元素合并，并存储到另一容器中&nbsp;函数原型：merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);// 容器元素合并，并存储到另一容器中// 注意: 两个容器必须是有序的// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10 ; i++) &nbsp; { v1.push_back(i); v2.push_back(i + 1); } vector&lt;int&gt; vtarget; //目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并 需要两个有序序列 merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：merge合并的两个容器必须的有序序列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.4 reverse功能描述：将容器内元素进行反转&nbsp;函数原型：reverse(iterator beg, iterator end);// 反转指定范围的元素// beg 开始迭代器// end 结束迭代器&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout &lt;&lt; \"反转前： \" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; \"反转后： \" &lt;&lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：reverse反转区间内元素，面试题可能涉及到&nbsp;&nbsp;&nbsp;&nbsp;5.4 常用拷贝和替换算法学习目标：掌握常用的拷贝和替换算法算法简介：copy // 容器内指定范围的元素拷贝到另一容器中replace // 将容器内指定范围的旧元素修改为新元素replace_if // 容器内指定范围满足条件的元素替换为新元素swap // 互换两个容器的元素&nbsp;5.4.1 copy功能描述：容器内指定范围的元素拷贝到另一容器中&nbsp;函数原型：copy(iterator beg, iterator end, iterator dest);// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置// beg 开始迭代器// end 结束迭代器// dest 目标起始迭代器&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i + 1); } vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：利用copy算法在拷贝时，目标容器记得提前开辟空间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2 replace功能描述：将容器内指定范围的旧元素修改为新元素&nbsp;函数原型：replace(iterator beg, iterator end, oldvalue, newvalue);// 将区间内旧元素 替换成 新元素// beg 开始迭代器// end 结束迭代器// oldvalue 旧元素// newvalue 新元素&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; \"替换前：\" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中的20 替换成 2000 cout &lt;&lt; \"替换后：\" &lt;&lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：replace会替换区间内满足条件的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.3 replace_if功能描述: 将区间内满足条件的元素，替换成指定元素&nbsp;函数原型：replace_if(iterator beg, iterator end, _pred, newvalue);// 按条件替换元素，满足条件的替换成指定元素// beg 开始迭代器// end 结束迭代器// _pred 谓词// newvalue 替换的新元素&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; class ReplaceGreater30{public: bool operator()(int val) { return val &gt;= 30; } }; void test01(){ vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; \"替换前：\" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中大于等于的30 替换成 3000 cout &lt;&lt; \"替换后：\" &lt;&lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件&nbsp;&nbsp;&nbsp;5.4.4 swap功能描述：互换两个容器的元素&nbsp;函数原型：swap(container c1, container c2);// 互换两个容器的元素// c1容器1// c2容器2&nbsp;示例：xxxxxxxxxx#include &lt;algorithm&gt;#include &lt;vector&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i+100); } cout &lt;&lt; \"交换前： \" &lt;&lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; \"交换后： \" &lt;&lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：swap交换容器时，注意交换的容器要同种类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5 常用算术生成算法学习目标：掌握常用的算术生成算法&nbsp;注意：算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt;&nbsp;算法简介：accumulate // 计算容器元素累计总和fill // 向容器中添加元素&nbsp;5.5.1 accumulate功能描述：计算区间内 容器元素累计总和&nbsp;函数原型：accumulate(iterator beg, iterator end, value);// 计算容器元素累计总和// beg 开始迭代器// end 结束迭代器// value 起始值&nbsp;示例：xxxxxxxxxx#include &lt;numeric&gt;#include &lt;vector&gt;void test01(){ vector&lt;int&gt; v; for (int i = 0; i &lt;= 100; i++) { v.push_back(i); } int total = accumulate(v.begin(), v.end(), 0); cout &lt;&lt; \"total = \" &lt;&lt; total &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：accumulate使用时头文件注意是 numeric，这个算法很实用&nbsp;5.5.2 fill功能描述：向容器中填充指定的元素&nbsp;函数原型：fill(iterator beg, iterator end, value);// 向容器中填充元素// beg 开始迭代器// end 结束迭代器// value 填充的值&nbsp;示例：xxxxxxxxxx#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v; v.resize(10); //填充 fill(v.begin(), v.end(), 100); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结：利用fill可以将容器区间内元素填充为 指定的值&nbsp;&nbsp;5.6 常用集合算法学习目标：掌握常用的集合算法&nbsp;算法简介：set_intersection // 求两个容器的交集set_union // 求两个容器的并集set_difference // 求两个容器的差集&nbsp;&nbsp;5.6.1 set_intersection功能描述：求两个容器的交集&nbsp;函数原型：set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);// 求两个集合的交集// 注意:两个集合必须是有序序列// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt;#include &lt;algorithm&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &nbsp; { v1.push_back(i); v2.push_back(i+5); } vector&lt;int&gt; vTarget; //取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = &nbsp; &nbsp; &nbsp; &nbsp;set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结： 求交集的两个集合必须的有序序列目标容器开辟空间需要从两个容器中取小值set_intersection返回值既是交集中最后一个元素的位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.6.2 set_union功能描述：求两个集合的并集&nbsp;函数原型：set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);// 求两个集合的并集// 注意:两个集合必须是有序序列// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt;#include &lt;algorithm&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector&lt;int&gt; vTarget; //取两个容器的和给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = &nbsp; &nbsp; &nbsp; &nbsp;set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结： 求并集的两个集合必须的有序序列目标容器开辟空间需要两个容器相加set_union返回值既是并集中最后一个元素的位置&nbsp;&nbsp;&nbsp;5.6.3 set_difference功能描述：求两个集合的差集&nbsp;函数原型：set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);// 求两个集合的差集// 注意:两个集合必须是有序序列// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器&nbsp;示例：xxxxxxxxxx#include &lt;vector&gt;#include &lt;algorithm&gt; class myPrint{public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; \" \"; }}; void test01(){ vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector&lt;int&gt; vTarget; //取两个里面较大的值给目标容器开辟空间 vTarget.resize( max(v1.size() , v2.size())); //返回目标容器的最后一个元素的迭代器地址 cout &lt;&lt; \"v1与v2的差集为： \" &lt;&lt; endl; vector&lt;int&gt;::iterator itEnd = &nbsp; &nbsp; &nbsp; &nbsp;set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; cout &lt;&lt; \"v2与v1的差集为： \" &lt;&lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;} int main() { test01(); system(\"pause\"); return 0;}总结： 求差集的两个集合必须的有序序列目标容器开辟空间需要从两个容器取较大值set_difference返回值既是差集中最后一个元素的位置&nbsp; (function(){var e=document.body.parentElement,t=[],n=null,i=document.body.classList.contains(\"typora-export-collapse-outline\"),r=function(e,t,n){document.addEventListener(e,function(e){if(!e.defaultPrevented)for(var i=e.target;i&&i!=this;i=i.parentNode)if(i.matches(t)){!1===n.call(i,e)&&(e.preventDefault(),e.stopPropagation());break}},!1)};function o(){return e.scrollTop}r(\"click\",\".outline-expander\",function(e){var t=this.closest(\".outline-item-wrapper\").classList;return t.contains(\"outline-item-open\")?t.remove(\"outline-item-open\"):t.add(\"outline-item-open\"),d(),!1}),r(\"click\",\".outline-item\",function(e){var t=this.querySelector(\".outline-label\");if(location.hash=\"#\"+t.getAttribute(\"href\"),i){var n=this.closest(\".outline-item-wrapper\").classList;n.contains(\"outline-item-open\")||n.add(\"outline-item-open\"),c(),n.add(\"outline-item-active\")}});var a,s,l=function(){var e=o();n=null;for(var i=0;ie.classList.remove(\"outline-item-open\"))},d=function(){if(n){c();var e=document.querySelector('.outline-label[href=\"#'+(CSS.escape?CSS.escape(n[0]):n[0])+'\"]');if(e)if(i){var t=e.closest(\".outline-item-open>ul>.outline-item-wrapper\");if(t)t.classList.add(\"outline-item-active\");else{for(var r=(e=e.closest(\".outline-item-wrapper\")).parentElement.closest(\".outline-item-wrapper\");r;)r=(e=r).parentElement.closest(\".outline-item-wrapper\");e.classList.add(\"outline-item-active\")}}else e.closest(\".outline-item-wrapper\").classList.add(\"outline-item-active\")}};window.addEventListener(\"scroll\",function(e){a&&clearTimeout(a),a=setTimeout(function(){l(),d()},300)});var u=function(){s=setTimeout(function(){!function(){t=[];var e=o();document.querySelector(\"#write\").querySelectorAll(\"h1, h2, h3, h4, h5, h6\").forEach(n=>{var i=n.getAttribute(\"id\");t.push([i,e+n.getBoundingClientRect().y])})}(),l(),d()},300)};window.addEventListener(\"resize\",function(e){s&&clearTimeout(s),u()}),u()})();","link":"/upload/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8Bbase64.html"}],"posts":[{"title":"BusyBox自建根文件系统完善","text":"BusyBox自建根文件系统完善 添加根文件系统动态库123456789101112131415161718192021mkdir libcd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/libcp *so* *.a ~/rootfs/lib/ -drm ~/rootfs/lib/ld-linux-armhf.so.3cp ld-linux-armhf.so.3 ~/rootfs/lib/cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libcp *so* *.a ~/rootfs/lib/ -dmkdir ~/rootfs/usr/libcd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/libcp *so* *.a ~/rootfs/usr/lib/ -dcd ~/rootfsdu ./lib ./usr/lib/ -shmkdir devmkdir procmkdir mntmkdir sysmkdir tmpmkdir root uboot NFS挂载123root=/dev/nfs nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gwip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;:&lt;dns0-ip&gt;:&lt;dns1-ip&gt;root=/dev/nfs nfsroot=192.168.3.138:/home/xcc/nfs/rootfs,proto=tcp rw ip=192.168.3.110:192.168.3.138:192.168.3.1:255.255.255.0::eth0:offsetenv bootargs 'console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.3.138:/home/xcc/nfs/rootfs,proto=tcp rw ip=192.168.3.197:192.168.3.138:192.168.3.1:255.255.255.0::eth0:off' 123456789run loadfdtrun loadimagebootz 80800000 - 83000000mkdir -p etc/init.dnano etc/init.d/rcSchmod 777 etc/init.d/rcS 内容 12345678910111213141516171819#!/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/librunlevel=S umask 022export PATH LD_LIBRARY_PATH runlevel#网络开机自启动设置ifconfig eth0 up#udhcpc -i eth0 ifconfig eth0 192.168.1.251 netmask 255.255.255.0route add default gw 192.168.1.1mount -a mkdir /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -s nano etc/fstab 1234#&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; proc /proc proc defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 sysfs /sys sysfs defaults 0 0 nano etc/inittab 123456#etc/inittab::sysinit:/etc/init.d/rcSconsole::askfirst:-/bin/sh::restart:/sbin/init::ctrlaltdel:/sbin/reboot::shutdown:/bin/umount -a -r 7 ::shutdown:/sbin/swapoff -a nfs install123456789sudo apt-get install nfs-kernel-server rpcbindsudo vi /etc/exportsmkdir nfs &amp;&amp; chmod 777 nfs/home/xcc/nfs *(rw,sync,no_root_squash)sudo /etc/init.d/nfs-kernel-server restartsudo vim /etc/default/nfs-kernel-server降低nfs版本，不然内核不能使用挂载RPCNFSDCOUNT=&quot;-V 2 8&quot; tftp1234567891011121314151617181920212223sudo apt-get install xinetd -ysudo apt-get install tftp-hpa tftpd-hpa -ymkdir tftp &amp;&amp; chmod 777 tftpsudo vi /etc/default/tftpd-hpasudo vi /etc/xinetd.d/tftpserver tftp{ socket_type = dgram wait = yes disable = no user = root protocol = udp server = /usr/sbin/in.tftpd server_args = -s /home/xcc/tftp -c #log_on_success += PID HOST DURATION #log_on_failure += HOST per_source = 11 cps =100 2 flags =IPv4}sudo service tftpd-hpa restartsudo service xinetd restart 自建roofs打包12cd rootfs/tar -vcjf rootfs.tar.bz2 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#!/bin/bashbusybox_dir=$HOME/imx6ull/busyboxkernel_dir=$HOME/imx6ull/kernelgcc_lib_root=/opt/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihfshare_dir=$HOME/imx6ull/nfsrootfs_dir=$share_dir/rootfsdtb_file=imx6ull-alientek-emmc.dtbdevice_ip=192.168.3.109netmask=255.255.255.0gw=192.168.3.1nfs_server_ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d &quot;addr:&quot;`# envsudo apt updatesudo apt install cmake gcc wget lsb-core lib32stdc++6 libncurses5-dev build-essential lzop -yrm $share_dir/* -rfrm $busybox_dir -rfrm $kernel_dir -rfmkdir -p $busybox_dirmkdir -p $kernel_dirmkdir -p $rootfs_dirtar -xvf linux-imx-4.1.15-2.1.0-g3dc0a4b-v2.7.tar.bz2 -C $kernel_dirtar -xvf busybox-1.29.0.tar.bz2 -C $busybox_dirmv $busybox_dir/busybox-1.29.0/{.,}* $busybox_dir# buildcpu_logic_cnt=`cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l`cd $kernel_dirmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distcleanmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_alientek_emmc_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j$cpu_logic_cntif [ $? -ne 0 ]; then exit;ficd $busybox_dirmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distcleanwget http://chengs.run/upload/2023/09/busybox_config -O .configmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j$cpu_logic_cntif [ $? -ne 0 ]; then exit;fi# rootfscd $busybox_dirmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- CONFIG_PREFIX=$rootfs_dir installcd $rootfs_dirmkdir libmkdir -p usr/libmkdir devmkdir procmkdir mntmkdir sysmkdir tmpmkdir rootmkdir -p etc/init.decho &quot;#!/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/librunlevel=S umask 022export PATH LD_LIBRARY_PATH runlevel#网络开机自启动设置ifconfig eth0 up# udhcpc -i eth0 # ifconfig eth0 ${device_ip} netmask ${netmask}# route add default gw ${gw}mount -a mkdir /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -s&quot; &gt; etc/init.d/rcSchmod 777 etc/init.d/rcSecho &quot;#&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; proc /proc proc defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 sysfs /sys sysfs defaults 0 0&quot; &gt; etc/fstabecho &quot;#etc/inittab::sysinit:/etc/init.d/rcSconsole::askfirst:-/bin/sh::restart:/sbin/init::ctrlaltdel:/sbin/reboot::shutdown:/bin/umount -a -r 7 ::shutdown:/sbin/swapoff -a&quot; &gt; etc/inittabecho &quot;nameserver 8.8.8.8nameserver ${gw}&quot; &gt; etc/resolv.conf# rootfs libcd $gcc_lib_root/libc/libcp *so* *.a $rootfs_dir/lib/ -drm $rootfs_dir/lib/ld-linux-armhf.so.3cp ld-linux-armhf.so.3 $rootfs_dir/lib/cd $gcc_lib_root/libcp *so* *.a $rootfs_dir/lib/ -dcd $gcc_lib_root/libc/usr/libcp *so* *.a $rootfs_dir/usr/lib/ -dcd $rootfs_dirdu ./lib ./usr/lib/ -sh# lib testecho '''#include &lt;stdio.h&gt;int main(int argc, const char* argv[]){ printf(&quot;helloworld\\n&quot;); return 0;}''' &gt;&gt; main.carm-linux-gnueabihf-gcc -o main main.cmv main $rootfs_dir/rootrm main.c# zImage dtbcp $kernel_dir/arch/arm/boot/zImage $share_dircp $kernel_dir/arch/arm/boot/dts/$dtb_file $share_direcho &quot;# uboot settingsetenv bootcmd 'nfs 80800000 ${nfs_server_ip}:${share_dir}/zImage;nfs 83000000 ${nfs_server_ip}:${share_dir}/${dtb_file};setenv bootargs console=ttymxc0,115200 root=/dev/nfs nfsroot=${nfs_server_ip}:${rootfs_dir},proto=tcp rw ip=${device_ip}:${nfs_server_ip}:${gw}:${netmask}::eth0:off;bootz 80800000 - 83000000;'&quot;","link":"/2023/02/24/BusyBox%E8%87%AA%E5%BB%BA%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%96%84/"},{"title":"DDR SDRAM","text":"DDR SDRAM DDR SDRAM特性 SDRAM: synchronous dynamic random-access memor SRAM: Static random-access memor DRAM 存储采用单个电容比 SRAM采用晶体管面积更占优势（SRAM 1-4M） SRAM由于是芯片内部小电容掉电较快，需要cpu提供同步信号（synchronous）增加了控制器的复杂性 DDR ：Double Data Rate 提高内存速度 DRAM结构组成：Array、Bank、Memory Device、Rank、DIMM(Dual in-line memory module) Array Bank Memory Device、Rank、DIMM 多Bank目的是为了交叉充电 读写操作时序CAS/RAS参数意义 RAS: row address strobe CAS: column address strobe DQ：Data Bus数据线 DM：Data Mask 当写入操作时，在DM信号有效时写入DQ数据。 DRAM操作时许演变对比 FPAM：FAST Page Module 根据局部性原理，行地址不需要经常根本更换，速度翻倍 EDO：Extend Data Out 列地址和数据时间复用，速度翻倍 BEDO：Burst EDO 爆发时EDO模式，芯片内部添加累加器自动计算新地址，不需要每次都给列地址，节约了列地址解码时间，速度增长30% DLL：Delay Lock Loop 用于DDR外部引脚信号和内部信号不同步进行同步操作 DDR Read20世纪80年代，计算机发展迅速，出现内存和cpu速度不匹配情况，异步此时限制了内存速度的进一步提高，内存又重新回到了同步的通信方式,时钟信号的出现对速率并没有明显提升，但可以通过修改时钟频率提升了内存的适用性。 SDR：采用单个时钟信号传输数据 DDR：采用上升沿和下降沿传输数据，速度翻倍Dual/Duble CAS-2: CAS到RAS延迟两个周期 DQS：toggle 读数据的时候进行反转，作用不大，和数据线同步 DDR Write DQS：在DDR中通知芯片可以进行数据锁存，进行数据写操作，比数据线晚半个周期 DQS对应着DATA数据线，所以在芯片电路设计中，并不能复用 DQS 采用差分信号避免并行数据线中的干扰 CKE:时钟使能 nWE：读写操作标记 ODT：决定是否启动内部上下拉电阻降低频率高导致集电容效应影响信号质量 内存时序关键参数 Read四个阶段Precharge Access Sense Restore Trcd: Row to Col Delay Tras: Row access Stroke Trp: Row Precharge Write四个阶段Access Sense Restore Precharge Trcd：Row Column Delay Twr：Write Delay Trp: Row Precharge SDR和DDR对比DDR不断迭代过程频率不断提高，但其中控制逻辑的速度并没有提高（Trcd Tras没有显著改变），只是提高BANK读取的位数，拓展了带宽 读写操作时间参数read write refresh 此处的Trc和读写的Trc不同，refresh会同时刷新多个行 Trrd Tfaw 参数列表： Trefi = bank最低刷时间/刷新bank行次数","link":"/2023/07/02/DDR_SDRAM/"},{"title":"linux应用开发(2)","text":"Linux应用开发 Linux平台c语言应用开发1. linux文件底层系统调用 open 获取一个文件描述符 write read close 操作不区分文本，二进制 12345678910111213141516171819202122232425262728293031int main(int argc, char *argv[], char *envp[]){ /* int fd = open(&quot;file.txt&quot;, O_WRONLY | O_CREAT, 0600); assert( fd != -1); printf(&quot;fd=%d\\n&quot;, fd); write(fd,&quot;hello&quot;, 5); close(fd); int fd = open(&quot;file.txt&quot;, O_RDONLY); assert( fd != -1); char buff[128] = {0}; int n = read(fd, buff, 127); printf(&quot;n = %d,buff = %s\\n&quot;, n, buff); close(fd); */ int fdr = open(&quot;1.png&quot;, O_RDONLY); int fdw = open(&quot;2.png&quot;, O_WRONLY | O_CREAT, 0600); assert( fdr != -1 &amp;&amp; fdw != -1); char buff[256] = {0}; int num = 0; while( (num = read(fdr, buff, 256)) &gt; 0 ) { write(fdw, buff, num); } close(fdw); close(fdr); exit(0);} 2. 父子进程共享打开文件 父子进程共享文件偏移量 子进程可以访问父进程的文件 多个进程指向同一个struct file，需要在每个文件close 若先fork后打开文件，不会指向同一个struct file，每个进程有自己独立的struct file 123456789101112131415161718192021222324252627int main(int argc, char *argv[], char *envp[]){ int fd = open(&quot;file.txt&quot;, O_RDONLY); assert(fd != -1); pid_t pid = fork(); assert(pid != -1); if( pid == 0) { char buff[128] = {0}; int n = read(fd, buff, 1); printf(&quot;child %s\\n&quot;, buff); sleep(1); n = read(fd, buff, 1); printf(&quot;child %s\\n&quot;, buff); }else { char buff[128] = {0}; int n = read(fd, buff, 1); printf(&quot;parent %s\\n&quot;, buff); sleep(1); n = read(fd, buff, 1); printf(&quot;parent %s\\n&quot;, buff); } close(fd); exit(0);} 3. 系统调用和库函数区别 系统调用在内核中，属于内核空间；库函数的实现在库函数中，属于用户空间 某些库函数底层其实仍然是系统调用 4. 内存申请与释放 malloc()申请1G内存能否成功？ malloc(单位是b) malloc申请的内存是虚拟内存，在实际使用的时候才会划分物理空间 分配1G能分配成功，申请内存数量应该小于剩余内存（memory+swap） 申请的内存如果没有释放会怎么样？ 在程序退出时，内存依旧会被回收 5. exec进程替换 linux系统交互都是一个fork和一个exec execl(const char *path, const char arg, … / (char *) NULL */); 1234567891011121314int main(int argc, char *argv[], char *envp[]){ printf(&quot;main pid = %d ppid = %d\\n&quot;, getpid(), getppid()); pid_t pid = fork(); assert(pid != -1); if(pid == 0) { printf(&quot;child pid=%d ppid=%d\\n&quot;, getpid(), getppid()); execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-f&quot;, (char *)0); } wait(NULL); exit(0);} 6. 信号 信号是系统响应某个条件而产生的事件，进程接收到信号会执行相应的操作 通过signal()设置相应的响应方式，可以设置以下几种响应方式 默认SIG_DEF 忽略SIG_IGN 自定义 void fun_sig(int sig) 7. 实现自己的KILL命令 kill 默认信号量是15 9号信号是不允许忽略的终止信号 sscanf解析转化字符串 1234567#include &lt;stdio.h&gt;int sscanf(const char *str, const char *format, ...);//例程int year, month, day; int converted = sscanf(&quot;20191103&quot;, &quot;%04d%02d%02d&quot;, &amp;year, &amp;month, &amp;day);printf(&quot;converted=%d, year=%d, month=%d, day=%d/n&quot;, converted, year, month, day); 123456789101112131415int main(int argc, char *argv[]){ if (argc != 3) { printf(&quot;argc error\\n&quot;); exit(0); } int pid = 0; int s = 0; sscanf(argv[1], &quot;%d&quot;, &amp;pid); sscanf(argv[2], &quot;%d&quot;, &amp;s); printf(&quot;pid:%d signal:%d\\n&quot;, pid, s); kill(pid, s); exit(0);} 8. 有名管道和无名管道 进程间通信方式： 管道，半双工 有名管道 无名管道 信号量 共享内存 消息队列 套接字 有/无名管道区别： 有名管道在任意两个进程间通信 无名管道在父子进程间通信 有名管道创建使用 123chengs@ubuntu:~/test$ mkfifo fifochengs@ubuntu:~/test$ ls -lprw-rw-r-- 1 chengs chengs 0 Jun 18 04:00 fifo 管道只有O_RDONLY、O_WRONLY两种模式 管道文件只能两个进程同时打开，单个进程打开管道会阻塞 12345678910111213141516171819202122232425262728293031323334353637//writeint main(){ int fd = open(&quot;fifo&quot;, O_WRONLY); assert(fd != -1); printf(&quot;fd=%d\\n&quot;, fd); while(1) { printf(&quot;input:\\n&quot;); char buff[128] = {0}; fgets(buff,128, stdin); if ( strncmp(buff, &quot;end&quot;, 3 ) == 0 ) { break; } write(fd, buff, strlen(buff)); } close(fd);}//readint main(){ int fd = open(&quot;fifo&quot;, O_RDONLY); assert(fd != -1); printf(&quot;fd=%d\\n&quot;, fd); char buff[128] = {0}; while (1) { if (read(fd, buff, 127) == 0 ) { break; } printf(&quot;read: %s&quot;, buff); } close(fd);} 无名管道创建使用 1234567891011121314151617181920212223int main(){ int fd[2]; assert( pipe(fd) != -1); //fd[0] r, fd[1] w pid_t pid = fork(); assert( pid != -1); if(pid == 0) { close(fd[1]); char buff[128] = {0}; read(fd[0], buff, 127); printf(&quot;child read:%s\\n&quot;, buff); close(fd[0]); } else { close(fd[0]); printf(&quot;parent write:hello\\n&quot;); write(fd[1], &quot;hello&quot;, 5); close(fd[1]); } 9.信号量信号量值代表允许访问的资源数目 P 操作 V 操作 临界资源：同一时刻，只允许被一个进程或线程访问的资源 临界区：访问临界资源的代码段 ipcs/ipcrm命令查看和删除消息进程通信方式（消息队列、共享内存、信号量） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//函数int semget(key_t key, int nsems, int semflg);int semop(int semid, struct sembuf *sops, unsigned nsops);int semctl(int semid, int semnum, int cmd, ...);// sem.hunion semun{ int val;};void sem_init();void sem_p();void sem_v();void sem_destroy();// sem.c#include &quot;sem.h&quot;static int semid = -1;void sem_init(){ semid = semget((key_t)1234, 1, IPC_CREAT|IPC_EXCL|0600); if(semid == -1){ semid = semget((key_t)1234, 1, 0600); }else{ union semun a; a.val = 1;//信号量初始值 if( semctl(semid, 0, SETVAL, a) == -1 ){ perror(&quot;semctrl error&quot;); } }}void sem_p(){ struct sembuf buf; buf.sem_num = 0; buf.sem_op = -1; buf.sem_flg = SEM_UNDO; if( semop(semid, &amp;buf, 1) == -1 ){ perror(&quot;semop p error&quot;); }}void sem_v(){ struct sembuf buf; buf.sem_num = 0; buf.sem_op = 1; buf.sem_flg = SEM_UNDO; if( semop(semid, &amp;buf, 1) == -1 ){ perror(&quot;semop v error&quot;); }}void sem_destroy(){ if( semctl(semid, 0, IPC_RMID) == -1 ){ perror(&quot;semctrl del error&quot;); }}//a .c#include &quot;sem.h&quot;int main(){ sem_init(); for (size_t i = 0; i &lt; 10; i++) { sem_p(); printf(&quot;a&quot;); fflush(stdout); int n = rand()%3; sleep(n); printf(&quot;a&quot;); fflush(stdout); sem_v(); n = rand()%3; sleep(n); }}// b.c#include &quot;sem.h&quot;int main(){ sem_init(); for (size_t i = 0; i &lt; 10; i++) { sem_p(); printf(&quot;b&quot;); fflush(stdout); int n = rand()%3; sleep(n); printf(&quot;b&quot;); fflush(stdout); sem_v(); n = rand()%3; sleep(n); }} 10.共享内存 共享内存是先在物理内存上申请一块空间，多个进程可以将其映射到自己的虚拟地址空间中 并未提供同步机制，所以我们通常需要用其他的机制来同步对共享内存的访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137int shmget(key_t key, size_t size, int shmflg);void* shmat(int shmid, const void *shmaddr, int shmflg);int shmdt(const void *shmaddr);int shmctl(int shmid, int cmd, struct shmid_ds *buf);// sem.h #ifndef _SEM_H_#define _SEM_H_#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;sys/sem.h&gt;union semun{ int val;};int sem_init(int key, int semVal[], int nsems);void sem_p(int semid, int index);void sem_v(int semid, int index);void sem_destroy(int semid);#endif// sem.c#include &quot;sem.h&quot;int sem_init(int key, int semVal[], int nsems){ int semid = semget((key_t)key, nsems, IPC_CREAT|IPC_EXCL|0664); if(semid == -1){ semid = semget((key_t)key, nsems, 0664); }else{ union semun a; for (size_t i = 0; i &lt; nsems; i++) { a.val = semVal[i]; if( semctl(semid, i, SETVAL, a) == -1 ){ perror(&quot;semctrl error&quot;); } } } return semid;}void sem_p(int semid, int index){ struct sembuf buf; buf.sem_num = index; buf.sem_op = -1; buf.sem_flg = SEM_UNDO; if( semop(semid, &amp;buf, 1) == -1 ){ perror(&quot;semop p error&quot;); }}void sem_v(int semid, int index){ struct sembuf buf; buf.sem_num = index; buf.sem_op = 1; buf.sem_flg = SEM_UNDO; if( semop(semid, &amp;buf, 1) == -1 ){ perror(&quot;semop v error&quot;); }}void sem_destroy(int semid){ if( semctl(semid, 0, IPC_RMID) == -1 ){ perror(&quot;semctrl del error&quot;); }}// a.c#include &quot;sem.h&quot;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int main(){ int shmid = shmget((key_t)1234, 128, IPC_CREAT|0664); assert(shmid != -1); int sem[2] = {1, 0}; int semid = sem_init(1234, sem, 2); char *p = (char *)shmat(shmid, NULL, 0); assert(p != (char*)-1); while (1) { char buff[128] = {0}; printf(&quot;please input:&quot;); fgets(buff, 128, stdin); sem_p(semid, 0); strcpy(p, buff); sem_v(semid, 1); if(strncmp(buff, &quot;end&quot;, 3) == 0){ break; } } shmdt(p); shmctl(shmid, IPC_RMID, NULL); exit(0);}// b.c#include &quot;sem.h&quot;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int main(){ int shmid = shmget((key_t)1234, 128, IPC_CREAT|0664); assert(shmid != -1); int sem[2] = {1, 0}; int semid = sem_init(1234, sem, 2); char *p = (char *)shmat(shmid, NULL, 0); assert(p != (char*)-1); while (1) { char buff[128] = {0}; sem_p(semid, 1); strcpy(buff, p); if(strncmp(buff, &quot;end&quot;, 3) == 0){ break; } printf(&quot;sent:%s&quot;, buff); fflush(stdout); sem_v(semid, 0); } shmdt(p); shmctl(shmid, IPC_RMID, NULL); sem_destroy(semid); exit(0);} 11.消息队列12345678910111213141516171819202122232425262728293031323334353637383940414243int msgget(key_t key, int msqflg);int msgsnd(int msqid, const void *msqp, size_t msqsz, int msqflg);ssize_t msgrcv(int msqid, void *msgp, size_t msqsz, long msqtyp, int msqflg);int msgctl(int msqid, int cmd, struct msqid_ds *buf);// a.ctypedef struct msgdata{ long mtype; char mtext[128];}MsgData;int main(){ int msgid = msgget((key_t)1234, IPC_CREAT|0664); assert(msgid != -1); MsgData data; memset(&amp;data, 0, sizeof(data)); data.mtype = 1; strcpy(data.mtext, &quot;hello&quot;); msgsnd(msgid, &amp;data, 128, 0); exit(0);}// b.ctypedef struct msgdata{ long mtype; char mtext[128];}MsgData;int main(){ int msgid = msgget((key_t)1234, IPC_CREAT|0664); assert(msgid != -1); MsgData data; memset(&amp;data, 0, sizeof(data)); msgrcv(msgid, &amp;data, 128, 1, 0); printf(&quot;id:%d, text:%s&quot;, (int)data.mtype, data.mtext); msgctl(msgid, IPC_RMID, NULL); exit(0);} 12.线程 在操作系统中线程的实现有三种方式 内核级线程 用户级线程 组合级线程 进程与线程的区别 进程是资源分配的最小单位，线程是 CPU 调度的最小单位 进程有自己的独立地址空间，线程共享进程中的地址空间 进程的创建消耗资源大，线程的创建相对较小 进程的切换开销大，线程的切换开销相对较小 线程接口 pthread不是 Linux 系统默认的库，编译中要加 -lpthread参数 1234567891011121314151617181920212223242526int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);int pthread_exit(void *retval);int pthread_join(pthread_t thread, void **retval);// 例程void * fun(void * argv){ int *threadNum = (int*)argv; for (size_t i = 0; i &lt; 5; i++) { sleep(1); printf(&quot;this thread is %d\\n&quot;, *threadNum); } pthread_exit(threadNum);}int main(){ pthread_t t; int *ret = NULL; int a = 1; assert( pthread_create(&amp;t, NULL, fun, &amp;a) != -1 ); assert( pthread_join(t, (void **)&amp;ret) != -1 ); printf(&quot;return: %d\\n&quot;, *ret); exit(0);} 13.线程同步 互斥锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr);int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);int pthread_mutex_destroy(pthread_mutex_t *mutex);//例程pthread_mutex_t mutex;void random_sleep(){ int n = rand()%3; sleep(n);}void * fun(void * argv){ for (size_t i = 0; i &lt; 5; i++) { pthread_mutex_lock(&amp;mutex); printf(&quot;A&quot;); fflush(stdout); random_sleep(); printf(&quot;A\\n&quot;); pthread_mutex_unlock(&amp;mutex); random_sleep(); }}int main(){ pthread_t t; int *ret = NULL; int a = 1; pthread_mutex_init(&amp;mutex, NULL); assert( pthread_create(&amp;t, NULL, fun, &amp;a) != -1 ); for (size_t i = 0; i &lt; 5; i++) { pthread_mutex_lock(&amp;mutex); printf(&quot;B&quot;); fflush(stdout); random_sleep(); printf(&quot;B\\n&quot;); pthread_mutex_unlock(&amp;mutex); random_sleep(); } pthread_mutex_destroy(&amp;mutex); exit(0);} 信号量 1234int sem_init(sem_t *sem, int pshared, unsigned int value);int sem_wait(sem_t *sem);int sem_post(sem_t *sem);int sem_destroy(sem_t *sem); 条件变量 条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程 12345int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *attr);int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);int pthread_cond_signal(pthread_cond_t *cond); //唤醒单个线程int pthread_cond_broadcast(pthread_cond_t *cond); //唤醒所有等待的线程int pthread_cond_destroy(pthread_cond_t *cond); 读写锁 12345int pthread_rwlock_init(pthread_rwlock_t *rwlock, pthread_rwlockattr_t *attr);int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 14.线程安全 对线程同步，保证同一时刻只有一个线程访问临界资源。 在多线程中使用线程安全的函数（可重入函数），所谓线程安全的函数指的是：如果一个函数能被多个线程同时调用且不发生竟态条件，则我们称它是线程安全的。 char *strtok(char *str, const char *delim)//分割字符串 strtok就是线程不安全的，该函数内部存放一个指针静态变量，如果多线程同时使用该指针就会导致线程不安全 采用strok_r函数是线程安全的 15.线程fork 多线程种如果子线程fork，只会复制该子线程，其他子线程不会复制","link":"/2022/06/19/LINUX%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91(2)/"},{"title":"Linux基础命令","text":"Linux基础命令 ls -l 结果文件类型 | 权限 | 链接数 | 属主 | 属组 | 大小 | 修改时间 | 文件名其中文件类型中第一位有以下类型： 普通文件： - 目录文件： d 管道文件： p 链接文件： l 设备文件： 块设备b（比如硬盘）、字符设备c(比如键盘) 套接字文件： s 文件权限 属主user | 同组group | 其他人other r、w、x： 读、写、执行（chown u-x（700） 文件） vi、vim使用三种模式：命令模式、插入模式、末行模式 末行模式： ：w newfile 另存为 ：set nu/nonu 命令模式： n dd 删除n行 n yy 拷贝n行 p 粘贴 u 撤销上一次操作 ctrl +r 回复上一次撤销操作 r 替换一个字符 插入模式： a、A、i、I、o、O: 光标后 行末 当前光标 行头 下一行 上一行 常见几种查看命令 cat 查看较短的文件 合并文件 cat A B&gt; C 写入数据 cat &gt; B more分屏幕显示 使用回车或者空格切换 q退出 head -行号 文件： 显示文件头部几行 tail -行号 文件： 显示文件尾部几行，常用于显示日志 less 常见的几种搜索文件命令 find find 搜索路径 -name 文件名 find 搜索路径 -cmin -n ：n分钟内修改的文件 find 搜索路径 -ctime -n ： 天 grep grep (-i不区分大小写) (-c行数) (-n给出行号) (-v不含行字符串的) 字符串 文本文件 进程管理的几个命令 ps 显示但钱终端相关的进程信息 -e 显示系统所有进程信息 -f 显示更多进程属性（全格式） -L 显示进程的线程ID ps -ef | grep ‘name’ kill 结束或者挂起一个进程 -9 强制结束 （kill本身就是给进程一个信号，9代表着不可忽略的信号） stop 挂起进程 后台执行：在执行命令后加&amp; 查看后台执行命令： jobs （-l详细信息） 结束一类命令的所有进程：pkill sleep（命令名） 用户管理命令 /etc/passwd 用户基本信息 用户名: x:用户id:组id::用户目录:命令解释器 /etc/group 存储用户组的信息 用户名: x:组id /etc/shadow 存储密码 用户名、加密密码、过期时间 tar压缩文件、解压文件 z GNU版本新加的，使该命令具有压缩和解压功能 x 释放包文件 v 显示详细过程 f 指定目标是文件不是设备 c 创建包文件 其中的z其实将gzip(压缩)和gzip -d(解压)合并到该命令中","link":"/2022/06/17/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"title":"linux应用开发(1)","text":"Linux应用开发基础 由源文件到可执行文件分为四部分 预编译 gcc -E main.c -O main.i 编译 gcc -S main.i -O main.s 汇编 gcc -C main.s -O main.o 链接 gcc main.o -O main Makefile GDB调试程序 debug和release版本的区别 gcc -g 编译debug版本 通常使用gdb调试程序 l 显示代码 b 行号/函数名 加断点 info break 查看断点信息 r 运行程序 n 单布执行 p 打印内容 c 继续运行 s 进入函数 finish 退出函数 q 退出程序 bt 函数调用栈的关系 静态库和共享库 libxxx.a(静态库)、libxxx.so(共享库) 库文件默认在/lib、/usr/lib,头文件默认放在/usr/include下 静态库： ar crv libxx.a a.o b.o gcc -o main main.c -L路径 -l库名 共享库 gcc -shared -fPIC -o libfoo.so add.o max.o gcc -o main main.c -L路径 -l库名(在使用该命令时，默认优先使用共享库) 在运行共享库时默认再标准目录下找共享库，使用ldd命令查看库调用情况 主函数入口参数 argc：参数数量 grgv：参数内容 数组指针：int (*p)[] = NULL 指针数组：int *p[n] = {NULL} envp：环境变量,环境变量继承自父进程，在命令行中执行程序时，父进程就是bash命令行，可以使用export添加环境变量 输出缓冲区 在执行printf时，会将数据发送到数据缓冲区，数据缓冲区在积攒一定数据后，会将数据打印到窗口 使用\\n换行符会将数据立刻打印输出 使用fflush(stdout)刷新缓冲区 如果不刷新缓冲区，数据不会被打印，默认在exit函数中进行刷新，若使用_exit(1)可以观察到，无数据输出 fork复制进程 父进程的fork()结果不为0，子进程为0 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[], char *envp[]){ char *s = NULL; int n = 0; pid_t id = fork(); assert( id != -1); if(id == 0) { s = &quot;child&quot;; n = 3; } else { s = &quot;parent&quot;; n = 7; } int i = 0; for (; i &lt; n; i++) { printf(&quot;s=%s,pid=%d,ppid=%d\\n&quot;, s, getpid(), getppid()); sleep(1); } exit(0);} fork写时拷贝技术 物理内存、逻辑内存：程序内存在物理内存中空间是不连续的，在逻辑内存中不是连续的，一般采用页表进行映射，一般情况一页的大小为4K 页表：逻辑内存到物理内存的映射关系 由于两者采用页表进行映射，所以可以使不同进程的逻辑页映射到相同的物理页 在进行进程复制时，若对物理页完全复制，则在物理内存中会出现较多重复内容（有的页数据只读，并不修改），会浪费机器性能，所以采用写时拷贝技术 某页数据需要进行修改，则将该页复制到其他页上，修改逻辑页表，改变映射关系 逻辑地址与物理地址 程序中看到的地址一般为逻辑地址 在32位中最大内存4G 高位1G: 内核使用 低位3G: 用户使用 相同逻辑地址可能不是相同物理地址 僵死进程(defunct) 当子进程先于父进程结束，父进程没有获取子进程的退出码，此时子进程变成僵死进程 在lunix中子进程退出后，程序实体会被去除，但PCB会被保留，父进程从子进程的PCB中可以获取子进程的退出码 避免产生僵死进程 父进程调用wait()方法获取子进程的退出码，此时会阻塞 父进程先结束：在lunix中父进程结束后子进程如果没结束被称为孤儿进程，会被分配一个父进程（init进程），init进程会收养其他孤儿进程，在子进程结束后获取子进程退出码 退出码左移8位后的数据是wait返回数据 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char *argv[], char *envp[]){ char *s = NULL; int n = 0; pid_t id = fork(); assert( id != -1); if(id == 0) { s = &quot;child&quot;; n = 3; } else { s = &quot;parent&quot;; n = 5; int val = 0; printf(&quot;waid pid:%d\\n&quot;, wait(&amp;val)); if(WIFEXITED(val)) { printf(&quot;exitId is:%d\\n&quot;, WEXITSTATUS(val)); } } int i = 0; for (; i &lt; n; i++) { printf(&quot;s=%s,pid=%d,ppid=%d\\n&quot;, s, getpid(), getppid()); sleep(1); } exit(2);}","link":"/2022/06/18/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91(1)/"},{"title":"Makefile模板","text":"Makefile模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485CROSS_COMPILE ?= arm-linux-gnueabihf-CC := $(CROSS_COMPILE)gccCXX := $(CROSS_COMPILE)g++AR := $(CROSS_COMPILE)arLD := $(CROSS_COMPILE)ldOBJCOPY := $(CROSS_COMPILE)objcopyOBJDUMP := $(CROSS_COMPILE)objdumpARFLAGS := rcsDEBUG := -gFLAGS := -Wall -nostdlib -c -O2 -fno-builtinCFLAGS := $(FLAGS) -std=c99 CXXFLAGS := $(FLAGS) -std=c++11SFLAGS := $(FLAGS)LDFLAGS := -Timx6ul.ldsLIBS := -lgccLIB_PATH := -L /home/chengs/imx6ull/tool/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/lib/gcc/arm-linux-gnueabihf/4.9.4OUTPUT := /var/tmp/outputSOURCE_DIR += imx6ulSOURCE_DIR += projectSOURCE_DIR += bsp/clkSOURCE_DIR += bsp/delaySOURCE_DIR += bsp/ledSOURCE_DIR += bsp/beepSOURCE_DIR += bsp/gpioSOURCE_DIR += bsp/keySOURCE_DIR += bsp/intSOURCE_DIR += bsp/extiSOURCE_DIR += bsp/epittimerSOURCE_DIR += bsp/uartINCLUDES := $(patsubst %, -I %, $(SOURCE_DIR))SOURCES += $(foreach dir, $(SOURCE_DIR), $(wildcard $(dir)/*.S))SOURCES += $(foreach dir, $(SOURCE_DIR), $(wildcard $(dir)/*.c))SOURCES += $(foreach dir, $(SOURCE_DIR), $(wildcard $(dir)/*.cpp))OBJS := $(patsubst %.c, $(OUTPUT)/%.o, $(SOURCES))OBJS := $(patsubst %.cpp, $(OUTPUT)/%.o, $(OBJS))OBJS := $(patsubst %.S, $(OUTPUT)/%.o, $(OBJS))VERSION := 0.1PROJECT_NAME := appTARGET := $(OUTPUT)/$(PROJECT_NAME)STATIC_LIB := $(OUTPUT)/lib$(PROJECT_NAME).a.$(VERSION)SHARED_LIB := $(OUTPUT)/lib$(PROJECT_NAME).so.$(VERSION)all: clean $(TARGET) $(OBJCOPY) -O binary -S $(TARGET) $(TARGET).bin $(OBJDUMP) -D -m arm $(TARGET) &gt; project/app.dis imxdownload $(TARGET).bin /dev/usbSdCard @rm -rf $(TARGET).dis $(TARGET).bin load.imx$(TARGET): $(OBJS) $(LD) $(LDFLAGS) -o $(TARGET) $(OBJS) $(LIBS) $(LIB_PATH) $(STATIC_LIB): $(OBJS) $(AR) $(ARFLAGS) $(STATIC_LIB) $(OBJS)$(SHARED_LIB): $(OBJS) $(CC) -fPIC -shared -o $(SHARED_LIB) $(OBJS)$(OUTPUT)/%.o: %.c @echo $(CC) $&lt; @mkdir -p $(dir $@) @$(CC) $(CFLAGS) $(DEBUG) $(INCLUDES) -o $@ $&lt;$(OUTPUT)/%.o: %.cpp @echo $(CXX) $&lt; @mkdir -p $(dir $@) @$(CXX) $(CXXFLAGS) $(DEBUG) $(INCLUDES) -o $@ $&lt;$(OUTPUT)/%.o: %.S @echo $(CC) $&lt; @mkdir -p $(dir $@) @$(CC) $(SFLAGS) $(DEBUG) -o $@ $&lt;.PHONY: clean all printclean: rm -rf $(OUTPUT)print: @echo $(SOURCES) @echo $(OBJS) @echo $(CFLAGS)","link":"/2025/02/21/Makefile%E6%A8%A1%E6%9D%BF/"},{"title":"Markdown图片base64压缩","text":"Markdown图片压缩到文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding=utf-8import base64import timeimport osimport re name = 'hhh'filename = name + &quot;.md&quot;temfile = name + 'base64' + &quot;.md&quot;def create_file(path): picdir = path +'assets\\\\' ls = os.listdir(picdir) targetfile = path + temfile print(targetfile) for i in ls : mulu=str(picdir)+str(i) f=open(mulu,&quot;rb&quot;) #以二进制形式打开str(ls_f)[2:-1] ls_f = base64.b64encode(f.read()) link = 'assets/'+i link_str = '\\r\\n' + f&quot;[{link}]:data:image/png;base64,&quot; + str(ls_f)[2:-1] #print(link_str) with open(targetfile, 'a+', encoding='utf-8') as file: file.write(link_str)def change(path): tar = path + filename tars = path + temfile picdir = path +'assets\\\\' ls = os.listdir(picdir) with open(tar, 'r+', encoding='utf-8') as f: lines = f.readlines() for line in lines: for i in ls: if i in line: line = f&quot;![{i[0:-4]}][assets/{i}]&quot;+ '\\n' with open(tars, 'a+', encoding='utf-8') as file: file.write(line)if __name__ == '__main__': start=time.time() path=os.getcwd()+'\\\\' ls = os.listdir(path) for i in ls: res = re.findall(r'(.*?).md',i) if len(res): name = res[0] filename = name + &quot;.md&quot; temfile = name + 'base64' + &quot;.md&quot; break for i in ls: res = re.findall(r'(.*?)base64.md',i) if len(res): rmfile = path + temfile os.remove(rmfile) print(filename) change(path) create_file(path) print('post time:',time.time()-start)","link":"/2021/12/19/Markdown%E5%9B%BE%E7%89%87base64%E5%8E%8B%E7%BC%A9/"},{"title":"VPS探针","text":"vps状态实时监测 neko安装12345678docker run --restart=on-failure --name nekonekostatus -p 5555:5555 -v /root/.neko/database:/database -d nkeonkeo/nekonekostatus:v1.0key: 49b6c954-e5d5-4f72-a450-6af23f3fffd6wget https://chengs.run/upload/2021/12/neko_install-2b4de6ae89ab443384a0d69c411f7d45.sh -O neko.sh &amp;&amp; chmod +x neko.sh &amp;&amp; ./neko.sh &amp;&amp; rm -rf neko.sh# 查看探针状态pidof neko-statustop -p id","link":"/2021/12/19/VPS%E6%8E%A2%E9%92%88/"},{"title":"css样式笔记","text":"css样式笔记 css样式优先级!important &gt; 行内样式 &gt; 内部样式 &gt; 外部样式 常用计量单位 px % em 子元素字体相对于父元素字体的大小比例 rem 子元素字体相对于根元素（html）字体的大小比例 基础选择器优先级ID &gt; 类＞标签 文本样式 color 字体颜色颜色英文名称、#16进制RGB、rgb/rgba、hsl/hsla text-align 文本对齐方式left（默认）、center、right text-decoration 设置字体链接样式none、underline、overline、line-through text-transform 控制元素的字母none（默认）、capitalize、uppercase、lowercase、inherit text-indent 规定文本中首行缩进length、%、inherit letter-spacing 字体间距length、normal、inherit line-hight 行高 direction 文本方向ltr、rtl、inherit word-spacing 字间距（英文单词间距）length、normal、inherit white-space 控制元素中空白符的渲染方式normal、pre（保留空格）、nowrap（不换行）、pre-wrap、pre-line、inherit text-shadow 设置文本的阴影x偏移 y偏移 扩散 color word-break 文本换行方式normal、break-all（单词内部换行）、keep-all 字体相关样式 font-size 字体大小 font-style字体样式normal、italic/oblique（斜体） font-weight 字体粗细 font-family 设置字体样式","link":"/2024/11/24/css%E6%A0%B7%E5%BC%8F%E7%AC%94%E8%AE%B0/"},{"title":"docker创建镜像上传","text":"docker创建镜像上传 12345678docker logindocker build -t=&quot;ouruser/sinatra:v2&quot; .docker tag 5db5f8471261 ouruser/sinatra:develdocker push ouruser/sinatra容器备份docker commit -p containname ouruser/sinatradocker push ouruser/sinatra","link":"/2022/01/16/docker%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0/"},{"title":"github上传相关","text":"github上传 github上传相关1234567891011121314git initecho &quot;# ptf&quot; &gt;&gt; README.mdgit add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/xuchengcheng926/ptf.gitgit push origin mian 如果你是第一次用（git push -u origin master）git remote add origin https://github.com/xuchengcheng926/ptf.gitgit branch -M maingit push -u origin maingit config --global user.email &quot;邮箱&quot;git config --global user.name &quot;用户名&quot;","link":"/2022/01/16/github%E4%B8%8A%E4%BC%A0%E7%9B%B8%E5%85%B3/"},{"title":"imx6ull裸机开发(1)","text":"IO使用、时钟、Cortex-A7 ArmV7介绍 Cortex-A7 有 9 种运行模式 CPSR寄存器SPSR：当异常中断发生后将CPSR寄存器保存到SPSR寄存器中，在异常中断结束后，将SPSR寄存器恢复到CPSR寄存器中 其低5位可用于控制处理器模式 CCM_CCGRx 使能io始终 IO复用配置IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03第四位为5 配置电气属性配置IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03 配置io输入输出 GPIOx_GDIR 配置io电平 GPIOx_DR 时钟主要从24Mhz晶振分出来7路时钟信号见下图从七路时钟信号导向不同的外设 见下图时钟树 配置ARM主频为最大528MHz 配置CACRR[ARM_PODF]时钟，二分频 配置ARM_PODF为001 配置CCM_ANALOG_PLL_ARM[DIV_SELECT]时钟，输出为pll1_main_clk528 * 2 * 2 / 24 = 88 配置PLL1时钟在配置arm时钟前，需要通过GLITCHLESS MUX修改时钟为step_clk，通过CCSR: step_sel配置为0（24Mhz）晶振时钟 配置PLL2 528Mhz PFD0-3 PLL3 480Mhz PFD0-3 其他外设时钟源 查表可知三者的最大时钟 配置时钟代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 528Mhzvoid imx6u_clkinit(void){ // 切换系统时钟到24Mhz if (REG_BIT(CCM-&gt;CCSR, 2) == 0) { CCM-&gt;CCSR &amp;= ~BIT(8); CCM-&gt;CCSR |= BIT(2); }#if 1 // 使能PLL1 BIT(13) 配置PLL1 88分频系数 24 * 88 / 2 = 1056Mhz CCM_ANALOG-&gt;PLL_ARM = (BIT(13) | (88u &amp; 0x7fu)); // 配置CACRR二分频 1056Mhz / 2 = 528Mhz CCM-&gt;CACRR = 1;#else // 使能PLL1 BIT(13) 配置PLL1 88分频系数 24 * 58 / 2 = 696Mhz CCM_ANALOG-&gt;PLL_ARM = (BIT(13) | (58u &amp; 0x7fu)); // 配置CACRR1分频 696Mhz CCM-&gt;CACRR = 0;#endif // 切换时钟源为PLL1 CCM-&gt;CCSR &amp;= ~BIT(2); // PLL2 uint32_t reg = 0; reg |= 27u &lt;&lt; 0; // 528 * 18 / 27 = 352Mhz reg |= 16u &lt;&lt; 8; // 528 * 18 / 16 = 594Mhz reg |= 24u &lt;&lt; 16; // 528 * 18 / 24 = 396Mhz reg |= 32u &lt;&lt; 24; // 528 * 18 / 32 = 297Mhz CCM_ANALOG-&gt;PFD_528 = reg; // PLL3 reg = 0; reg |= 12u &lt;&lt; 0; // 480 * 18 / 12 = 720Mhz reg |= 16u &lt;&lt; 8; // 480 * 18 / 16 = 540Mhz reg |= 17u &lt;&lt; 16; // 480 * 18 / 17 = 508.2Mhz reg |= 19u &lt;&lt; 24; // 480 * 18 / 19 = 454.7Mhz CCM_ANALOG-&gt;PFD_480 = reg; // 设置AHB_CLK_ROOT // 选择PLL2 PFD0的时钟396MHZ // PRE_PERIPH_CLK_SEL CCM-&gt;CBCMR &amp;= ~(3 &lt;&lt; 18); CCM-&gt;CBCMR |= (1 &lt;&lt; 18); // PRE_PERIPH_CLK_SEL // PERIPH_CLK_SEL CCM-&gt;CBCDR &amp;= ~(1 &lt;&lt; 25); while ((CCM-&gt;CDHIPR &amp; BIT(5)));#if 0 // 不能用 仅供学习 // AHB_PODF 设置AHB_CLK_ROOT 3分频 396 / 3 = 132Mhz CCM-&gt;CBCDR &amp;= ~(7 &lt;&lt; 10); CCM-&gt;CBCDR |= (2 &lt;&lt; 10); while ((CCM-&gt;CDHIPR &amp; BIT(1)));#endif // 设置IPG_CLK_ROOT // IPG_PODF 2分频 132 / 2 = 66Mhz CCM-&gt;CBCDR &amp;= ~(3 &lt;&lt; 8); CCM-&gt;CBCDR |= (1 &lt;&lt; 8); // 设置PERCLK_CLK_ROOT // PERCLK_PODF PERCLK_CLK_SEL 都设置为0 CCM-&gt;CSCMR1 &amp;= ~(0x7f);}","link":"/2025/02/21/imx6ull%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91(1)/"},{"title":"grep的grouping","text":"grep的grouping 存在文本config.json 123456789101112131415{ &quot;port&quot;: 8000, &quot;userName&quot;: &quot;*****&quot;, &quot;password&quot;: &quot;*******&quot;, &quot;desDir&quot;: &quot;//192.168.1.54/share&quot;, &quot;tarDir&quot;: &quot;/share&quot;, &quot;copysrc&quot;: &quot;Z:\\\\sonia&quot;, &quot;copydst&quot;: &quot;D:\\\\share&quot;, &quot;WEB_SERVE&quot;: &quot;11.54.34.130:8000&quot;, &quot;GENUI_DIR&quot;: &quot;/home/*****/src&quot;, &quot;PACK_DIR&quot;: &quot;/home/*****/src&quot;} 使用grep匹配其中WEB_SERVE的值 12345cat config.json |grep WEB_SERVE | grep -oP '\\&quot;(\\d.*?)\\&quot;'# &quot;11.54.34.130:8000&quot;cat config.json |grep WEB_SERVE | grep -oP '(?&lt;=&quot;)\\d.*?(?=&quot;)'# 11.54.34.130:8000 通过本次测试发现，grep内的grouping命令并不都能像python re模块中直接匹配组的内容，想要直接获取文本匹配固定内容可通过断言获得 12以双引号开头：(?&lt;=&quot;) 以双引号结尾：(?=&quot;)","link":"/2022/09/24/grep%E7%9A%84grouping/"},{"title":"imx6ull裸机开发(2)","text":"GIC介绍、中断函数过程 中断Cortex-A7中断向量表 中断向量偏移GIC 控制器总览 SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有 Core 共享的中断，这个是最常见的，那些外部中断都属于 SPI 中断 。比如按键中断、串口中断等等，这些中断所有的 Core 都可以处理，不限定特定 Core。 PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。 SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存器GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信 中断 ID 对于imx6ull 可以在参考手册中查询其中断号，见下图 CP15协处理器 Reset_Handler函数工作 关闭中断 关闭I/D Cache MMU 分支预测 （控制SCTLR寄存器） 配置VBAR隔离指令配置VBAR 清除BSS段 设置对应中断模式的SP指针 开启中断 跳到main函数 IRQ_Handler函数工作 压栈 lr spsr 等 读取c15 CBAR寄存器 获取GIC控制器的基地址，访问GIC控制器的寄存器 获取到GIC控制器CPU端基地址 获取到CPU端的GICC_IAR寄存器 进入到svc模式（可以再次进入中断） 跳转到C语言的system_irqhandler函数，传入GIC控制器地址和GICC_IAR寄存器 ,通过低9位获取到中断ID 进入到IRQ模式 将GICC_IAR寄存器的值（对应的中断ID）写入到GICC_EOIR中 出栈lr spsr 恢复spsr 将lr-4赋给pc（ARM流水线） 配置imx6ull IO的中断寄存器 配置ICR寄存器 配置IMR寄存器 使能GIC控制器对应的中断号，配置其优先级，注册对应中断号的函数 中断发生后配置ISR寄存器写1","link":"/2025/02/22/imx6ull%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91(2)/"},{"title":"imx6ull裸机开发(3)","text":"EPIT、GPT、UART Enhanced Periodic Interrupt Timer (EPIT) 此部分结构较为简单，直接查看imx6ull参考手册即可，不做过多解释，只需要注意下图的操作顺序即可 General Purpose Timer (GPT) 两种工作模式 两路输入比较 三路输出捕获 UARTUARTx_UCR1寄存器 位名称 功能 配置值 UARTEN 总使能 1 ADBR 自动检测波特率使能 0 UARTx_UCR2寄存器 位名称 功能 配置值 SRST 软件复位 0 RXEN 接收使能 1 TXEN 发送使能 1 WS 设置数据位长度 1 STPB 停止位 0 PREN 校验使能 0 IRTS 忽略rts引脚 1 UARTx_UCR3寄存器 位名称 功能 配置值 RXDMUXSEL 必须位1 1 UARTx_UFCR 位名称 功能 配置值 RFDIV 时钟分频 - 注：配置CSCDR1[UART_CLK_SEL]为0，CSCDR1[UART_CLK_PODF]为1分频，选择PLL3 / 6 = 80Mhz时钟 配置波特率 UARTx_UBRC、UARTx_UBIR 这里有个坑 特别注意下 UARTx_USR2 位名称 功能 配置值 RDR 为1接受完成 - TXDC 为1发送完成 - 其他 编译选项-fno-builtin去除putc和getc函数的多定义问题 c语言编译选项添加-Wa,-mimplicit-it=thumb可支持除法运算","link":"/2025/02/23/imx6ull%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91(3)/"},{"title":"imx6ull裸机开发(4)","text":"MMDC、RTC、I2C、SPI Multi-Mode DDR Controller (MMDC)时钟 imx6ull时钟设置DDR为PFD2 400MHz（实际为396MHz） CBCMR[PRE_PERIPH2_CLK_SEL] CBCDR[PERIPH2_CLK_SEL] CBCDR[FABRIC_MMDC_PODF] DDR3L 型号NT5CC256M16EP-EK 512MB NXP DDR测试程序ddr_stress_tester LCD… RTCSecure Non-Volatile Storage(SNVS) SNVS_HPCOMR[NPSWA_EN] SNVS_LPCR[SRTC_ENV] 获取计数值SNVS_SRTCMR 和 SNVS_SRTCLR SRTC 计数器是 32 位的，不是 47 位！ SNVS_SRTCMR 的 bit14:0 这 15 位是 SRTC 计数器的高 15 位。 SNVS_SRTCLR 的 bit31:bit15 这 17 位是 SRTC 计数器的低 17 位。 I2CI2C协议介绍 起始位：SCL高电平的时候，SDA下降沿 停止位：SCL高电平的时候，SDA上升沿 数据传输：SCL低电平时SDA必须稳定 应答信号：主机提供时钟，将SDA拉低表示ACK，将SDA拉高表示NOACK I2C 写时序 I2C 读时序 imx6ull I2C Controler引脚复用 时钟 寄存器 I2Cx_IFDRIPG_CLK_ROOT时钟66MHz，如果实现100KHz的标准I2C速率，则分频系数位66Mhz / 100KHz = 660，查表可知，配置IC值为0x38或者0x15 I2Cx_I2CR 位名称 功能 配置值 IEN[7] I2C enable 1 IIEN[6] I2C interrupt enable 0 MSTA Master/Slave mode select bit. 1 MTX Transmit(1)/Receive(0) mode select bit. - TXAK Transmit acknowledge enable - RSTA Generates a Repeated Start condition 1有效 - I2Cx_I2SR 位名称 功能 配置值 ICF Data transferring bit. 1：complete 0： progress - IBB I2C bus busy bit. 1:Busy 0:idle - IAL Arbitration lost. 0：No arbitration lost 1：Arbitration is lost RXAK Received acknowledge. 0:Ack 1:noAck - I2Cx_I2DR SPISPI协议介绍 全双工，速度快（几十至上百兆） 一般情况下分为4条线，CS、SCLK、MOSI、MISO，CS拉低有效 工作模式：根据串行时钟极性(CPOL)和相位(CPHA)来配置 CPOL=0 CPOL=1 CPHA=0 时钟空闲状态为低、第一个跳变沿采集数据 时钟空闲状态为高、第一个跳变沿采集数据 CPHA=1 时钟空闲状态为低、第二个跳变沿采集数据 时钟空闲状态为高、第二个跳变沿采集数据 时序：以CPOL=0，CPHA=1工作模式为例，见下图 Enhanced Configurable SPI (ECSPI)时钟 pll3_sw_clk=480MHz 480 / 8 = 60Mhz CCM_CSCDR2[ECSPI_CLK_SEL] 配置为0 ECSPI_CLK_PODF[ECSPI_CLK_SEL] 配置为0 ，1分频 寄存器ECSPIx_RXDATA ECSPIx_TXDATA ECSPIx_CONREG 位名称 功能 配置值 EN[0] SPI Block Enable Control 1 HT[1] Hardware Trigger Enable. 0 XCH[2] SPI Exchange Bit. 0 SMC[3] Immediately starts a SPI burst when data is written in TXFIFO 1 CHANNEL_MODE[4:7] SPI CHANNEL MODE selects the mode for each SPI channel. 1 POST_DIVIDER[8:11] SPI Post Divider. - PRE_DIVIDER[12:15] SPI Pre Divider. - CHANNEL_SELECT[18:19] SPI CHANNEL SELECT bits b00 BURST_LENGTH[20:31] Burst Length.(设置8bit 一个字节) 7 ECSPIx_CONFIGREG 位名称 功能 配置值 SCLK_PHA[0:3] SPI Clock/Data Phase Control. 0 SCLK_PO[4:7] SPI Clock Polarity Control. 0 SS_CTL[8:11] SPI SS Wave Form Select. 0 SS_POL[12:15] SPI SS Polarity Select. 0 DATA_CTL[16:19] Controls inactive state of the data line for each SPI channel. 0 SCLK_CTL[20:23] Controls the inactive state of SCLK for each SPI channel. 0 ECSPIx_STATREG 位名称 功能 配置值 TE[0] TXFIFO Empty. - RR[3] RXFIFO Ready. - ECSPIx_PERIODREG 位名称 功能 配置值 SAMPLE_PERIOD[0:14] Sample Period Control.Control the number of wait states 0x2000 CSRC[15] Clock Source Control. 0 CSD_CTL[16:21] 片选延迟 - 各个协议中MSB、LSB传输顺序 总线类型 默认数据传输顺序 UART LSB 优先（低位先传） SPI 可配置（常见 MSB 优先） I²C MSB 优先（高位先传）","link":"/2025/02/28/imx6ull%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91(4)/"},{"title":"linux修改dns","text":"linux修改dns linux修改dnsifconfig -a一般来说，eth0就是第一块网卡了，而lo是localhost的缩写。 然后编辑 /etc/network/interfaces 添加下面的信息 12345auto eth0 // 开机自动挂载这张网卡iface eth0 inet static // 使用静态ipaddress 192.168.1.233netmask 255.255.255.0gateway 192.168.1.1 如果使用DHCP，将”iface eth0 inte static”改为”iface eth0 inet dhcp” 配置DNS服务器 编辑/etc/resolv.conf nameserver 114.114.114.114 然后重启机器或者重启网卡，附上重启网卡的指令: /etc/init.d/networking restart","link":"/2022/01/16/linux%E4%BF%AE%E6%94%B9dns/"},{"title":"linux驱动开发(1)","text":"字符设备驱动开发基础 字符设备驱动注册卸载12345module_init(XXX); // 注册模块加载函数module_exit(XXX); // 注册模块卸载函数static int __init XXX(void);static int __exit XXX(void); 加载卸载驱动1234567891011insmod xx.komodprobe xx.ko // more smart&lt;!-- 会自动从/lib/modules/内核版本 目录下寻找依赖驱动 直接调用会提示can't open 'modules.dep'输入depmod 若不存在该命令，则需busybox中加入 --&gt;&lt;!-- 创建节点文件 --&gt;mknod [-m MODE] NAME TYPE [MAJOR MINOR]mknod /dev/chrdevbase.ko c 200 0rmmod xx.komodeprobe -r xx.ko // not suggest 字符设备的注册与注销12static inline int register_chrdev(unsigned int major,const char *name, const struct file_oiperations *fops);static inline void unregister_chrdev(unsigned int major, const char* name); 可通过cat /proc/devices命令查看已经被用掉的设备号 添加LICENSE和作者信息12MODULE_LICENSE()MODULE_AUTHOR() 设备号dev_t 本质是一个32位的无符号整数，其中高12位为设备号，低20号为次设备号，so 主设备号max 4095。 123MAJOR(dev)MINOR(dev)MKDEV(ma, mi) dynamic dev num12int alloc_chrdev_region(dev_t* dev, unsigned baseminor, unsigned count, const char* name);void unregister_chrdev_region(dev_t from, unsigned count); printkprintk有八个打印等级，如果不指名，默认采用等级4 12345678910111213#inlcude/linux/kern_levels.h#define KERN_EMERG KERN_SOH &quot;0&quot; /* system is unusable */#define KERN_ALERT KERN_SOH &quot;1&quot; /* action must be taken immediately */#define KERN_CRIT KERN_SOH &quot;2&quot; /* critical conditions */#define KERN_ERR KERN_SOH &quot;3&quot; /* error conditions */#define KERN_WARNING KERN_SOH &quot;4&quot; /* warning conditions */#define KERN_NOTICE KERN_SOH &quot;5&quot; /* normal but significant condition */#define KERN_INFO KERN_SOH &quot;6&quot; /* informational */#define KERN_DEBUG KERN_SOH &quot;7&quot; /* debug-level messages */usage:printk(KERN_EMERG &quot;gsmi:Log Shutdown Reason\\n&quot;); 在printk.h中存在宏定义 CONSOLE_LOGLEVEL_DEFAULT 当打印等级比该值高，才会显示在终端上","link":"/2023/02/24/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(1)/"},{"title":"linux应用开发(3)","text":"Linux应用开发 Linux平台c语言应用开发1. socket 网络编程与TCP 主机字节序列和网络字节序列 大端：高字节在低位，低字节在高位 小端：高字节在高位，低字节在地位（x86架构多采用小端） 网络规定使用大端字节序，所以也把大端字节序成为网络字节序列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364uint32_t htonl(uint32_t hostlong); // 长整型的主机字节序转网络字节序uint32_t ntohl(uint32_t netlong); // 长整型的网络字节序转主机字节序uint16_t htons(uint16_t hostshort); // 短整形的主机字节序转网络字节序uint16_t ntohs(uint16_t netshort); // 短整型的网络字节序转主机字节序in_addr_t inet_addr(const char *cp); //字符串表示的 IPV4 地址转化为网络字节序char* inet_ntoa(struct in_addr in); // IPV4 地址的网络字节序转化为字符串表示//例程void * server(void *argv){ int fd = socket(AF_INET, SOCK_STREAM, 0); assert(fd != -1); struct sockaddr_in serverAddr, cilentAddr; serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(6000); serverAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); assert( bind(fd, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) != -1); assert( listen(fd, 5) != -1); int len = sizeof(cilentAddr); int res = accept(fd, (struct sockaddr *)&amp;cilentAddr, &amp;len); assert(res != -1); while (1) { char buff[128] = {0}; recv(res, buff, 127, 0); printf(&quot;server recv:%s&quot;, buff); if(strncmp(buff, &quot;end&quot;, 3) == 0){ break; } send(res, &quot;ok\\n&quot;, 4, 0); } close(fd); pthread_exit(NULL);}int main(){ pthread_t t; pthread_create(&amp;t, NULL, server, NULL); int fd = socket(AF_INET, SOCK_STREAM, 0); assert(fd != -1); struct sockaddr_in serverAddr; serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(6000); serverAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); int res = connect(fd, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)); assert(res != -1); while (1) { char buff[128] = {0}; printf(&quot;input:&quot;); fflush(stdout); fgets(buff, 127, stdin); send(fd, buff, strlen(buff), 0); if(strncmp(buff, &quot;end&quot;, 3) == 0){ break; } recv(fd, buff, 127, 0); printf(&quot;cilent recv:%s&quot;, buff); } close(fd); pthread_join(t, NULL); exit(0);} 类似于与print，在tcp传输中同样存在数据缓冲区，在应用层只有一次接收，多次发送，但在传输层，发送端会在接收多次数据后通过数据缓冲区一次发送，而在接收端，在接收多次数据后全部放在tcp数据缓冲区 由于数据缓冲区的存在，会产生粘包现象 netstat -natp 查看数据缓冲区 n 使用ip地址表示主机 a 显示结构包括监听socket t 仅显示tcp连接 r 显示路由信息 i 显示网卡接口数据流量 2. strlen和sizeofstrlen 测量的是字符的实际长度，以’\\0’ 结束（不包含’\\0’ ）。而sizeof 测量的是字符的分配大小，如果未分配大小，则遇到’\\0’ 结束（包含’\\0’ ，也就是strlen测量的长度加1），如果已经分配内存大小，返回的就是分配的内存大小。 3. UDP tcp：面向连接、可靠的、流式服务 udp：无连接、不可靠、数据报","link":"/2022/06/19/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91(3)/"},{"title":"linux驱动开发(2)","text":"字符设备驱动开发基础 物理内存：计算机底层的实际地址 虚拟地址：现代计算机利用虚拟地址技术实现的一种地址 MMU：Memory Manage Unit、1 完成虚拟空间到物理空间的映射。2 内存保护设置存储器的访问权限，设置虚拟存储空间的缓冲特性。 内存映射123456789#define ioremap(cookie, size) __arm_ioremap((cookie), (size), MT_DEVICE)void __iomem* __arm_ioremap(phys_addr_t phys_addr, size_t size, unsigned int mtype){ return arch_ioremap_caller(phys_addr, size, mtype, __builtin_return_address(0));} mtype: MT_DEVICE MT_DEVICE_NONSHARED MT_DEVICE_CACHED MT_DEVICE_WCvoid iounmap(volatile void __iomem* addr); I/O内存访问函数映射的虚拟地址，其实本质就可直接通过指针访问，但是Linux内核不推荐这样做，而是推荐一组操作函数来对映射后的内存进行读写操作(猜测是为了可追溯、安全检查等)。 1234567u8 readb(const volatile void __iomem* addr)u16 readw(const volatile void __iomem* addr)u32 readl(const volatile void __iomem* addr)void writeb(u8 value, volatile void __iomem* addr)void writew(u16 value, volatile void __iomem* addr)void writel(u32 value, volatile void __iomem* addr) Tip：vscode在查找一些系统头文件目录的时候会优先使用系统的头文件目录，所以需要在vscode设置中将系统头文件目录屏蔽 Makefile编译驱动1234567891011121314KERNELDIR := /home/chengs/imx6ull/linuxCURRENT_PATH := $(shell pwd)MODULE_NAME := chrdevbase ledobj-m := $(patsubst %, %.o, $(MODULE_NAME))DIRVERS := $(patsubst %, %.ko, $(MODULE_NAME))build: clean kernel_moduleskernel_modules: $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules cp $(DIRVERS) $(CURRENT_PATH)/../rootfs/lib/modules/4.1.15/clean: $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean","link":"/2023/02/24/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(2)/"},{"title":"linux驱动开发(3)","text":"新字符设备驱动 分配和释放设备号12345678910111213141516171819int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)int register_chrdev_region(dev_t from, unsigned count, const char *name)void unregister_chrdev_region(dev_t from, unsigned count)usage:int major;int minor;dev_t devid;if(major){ devid = MKDEV(major, minor); register_chrdev_region(devid, 1, &quot;test&quot;);}else{ alloc_chrdev_region(&amp;devid, 0, 1, &quot;test&quot;); major = MAJOR(devid); minor = MINOR(devid);}unregister_chrdev_region(devid, 1); 新字符设备注册方法1234# include/linux/cdev.hvoid cdev_init(struct *cdev, const struct file_operations *fops)int cdev_add(struct cdev *p, dev_t dev, unsigned count)void cdev_del(struct cdev *p) 自动创建设备节点不需要使用mknod命令udev: linux下一个应用程序，用于设备文件的创建和删除，使用busybox构建跟文件系统时，会创建一个简化版的udev—-&gt;mdev，所以在rcS文件中存在以下语句： 1echo /sbin/mdev &gt; /proc/sys/kernel/hotplug 自动创建设备节点需要一个class类 1234567891011# include/linux/device.h#define class_create(owner, name)({ static struct lock_class_ket __key; __class_create(owner, name, &amp;__key);})struct class *__class_create(struct module *owner, const char *name, struct lock_class_key *key)void class_destroy(struct class *cls); 创建设备 123456struct device *device_create(struct class *class struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)void device_destroy(struct class *class, dev_t devt)","link":"/2023/02/25/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(3)/"},{"title":"linux驱动开发(4)","text":"设备树基础 DTB DTS DTCDTB：编译的最终设备树文件 DTS：设备树描述文件，类似于C源码 DTC：设备树的编译器，类似于GCC DTSI: 设备树的头文件，类似于.H头文件 设备树编写文档推荐： 《Devicetree SpecificationV0.2.pdf》 《Power_ePAPR_APPROVED_v1.12.pdf》 正常情况不需要开发人员从零开始写一个设备树文件，大多数都是在处理器厂商提供的信息上进行增删即可，因此这方面不需要特地学习的非常精通 DTS语法规则 文件包含 节点命名格式为node-name@unit-address，unit-address可以省略 节点标签，label: node-name@unit-address DTS的信息以键值对的新式组织，值分为以下几类 字符串、字符串列表 32 位无符号整数、整数列表 标准属性 compatible属性，描述设备的匹配信息 model属性，描述设备模块信息，比如名称 status属性 值 描述 okay 表明设备是可操作的。 disabled 表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。至于 disabled 的具体含义还要看设备的绑定文档。 fail 表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。 fail-sss 含义和“fail”相同，后面的 sss 部分是检测到的错误内容。 #address-cells 和#size-cells属性，#address-cells用于描述reg子节点的“地址”的长度（32位），#size-cells用于描述reg子节点中“长度”的长度； reg属性，描述地址信息，数据形式为整数列表，一般是(address，length)对 ranges 属性，属性值可以为空（子地址空间和父地址空间完全相同）或者按照(child-bus-address,parent-bus-address,length)格式编写的数字列表，其中长度同样由**#address-cells 和#size-cells属性**决定 name 属性(已弃用)，用于记录节点名字 device_type 属性，用于记录节点FCode，只能用于 cpu 节点或者 memory 节点 向节点追加或修改内容 直接在特定节点中添加/修改新的子节点 使用&amp;引用特定节点进行追加/修改 将节点信息记录到设备树中 原理很简单，本质就是抽取驱动中的关键信息，放在设备树中，驱动利用特定的函数访问设备树中的地址信息，从而达到驱动代码的复用 可在/proc/device_tree 中观察驱动中的信息 特殊节点 aliases 子节点，定义别名 chosen 子节点，主要是为了 uboot 向 Linux 内核传递数据（uboot do_bootz调用函数 fdt_chosen 向 chosen 节点添加 bootargs 属性） Linux 源码目录/Documentation/devicetree/bindings中查询绑定信息的文档 常用of函数获取dts中的信息只列举常用的，全部的在of.h头文件中，使用方法不难，类似于cJson库 12345678910111213141516struct device_node* of_find_node_by_name(struct device_node *from const char *name)inline struct device_node *of_find_node_by_path(const char *path)static inline struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)static inline int of_property_read_string(struct device_node *np, const char *propname, const char **out_string)static inline int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz) of_iomap 函数功能类似于ioremap函数，但是兼容了设备树，可直接通过设备树节点访问其出错的地址信息，并进行一次内存映射 123# linux/of_address.hvoid __iomem *of_iomap(struct device_node *device, int index);","link":"/2023/02/27/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(4)/"},{"title":"nginx常用配置","text":"HTTPS、重定向、静态文件、分流 HTTPS1234567891011121314151617upstream halo { server 127.0.0.1:8090;}server { listen 443 ssl; server_name chengs.run; ssl_certificate cert/chengs.run.crt; ssl_certificate_key cert/chengs.run.key; client_max_body_size 1024m; location / { proxy_pass http://halo; proxy_set_header HOST $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }} 重定向12345server { listen 80; server_name *.chengs.run chengs.run; return 301 https://$host$request_uri;} 静态文件123456789server{ listen 443 ssl; server_name note.chengs.run; ssl_certificate cert/note.chengs.run.crt; ssl_certificate_key cert/note.chengs.run.key; root /www/notes; index index.html;} 分流123456789101112131415161718192021server{ listen 443 ssl; server_name api.chengs.run; ssl_certificate cert/api.chengs.run.crt; ssl_certificate_key cert/api.chengs.run.key; location /daxuexi { proxy_pass http://127.0.0.1:8000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host $host; } location /botmessage/ { proxy_pass http://127.0.0.1:5700/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host $host; }} 普通1234567891011server{ listen 80; server_name jd.chengs.run; location / { proxy_pass http://azure.opaw.tk:5700; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host $host; }}","link":"/2022/10/18/nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"service文件创建","text":"linux service文件创建 service 模板 1wget https://dl.halo.run/config/halo.service -O /etc/systemd/system/halo.service 重新加载 systemd 1systemctl daemon-reload 运行服务 1systemctl start halo 在系统启动时启动服务 1systemctl enable halo 您可以查看服务日志检查启动状态 1234567891011121314151617启动服务：systemctl start vsftpd.service关闭服务：systemctl stop vsftpd.service重启服务：systemctl restart vsftpd.service显示服务的状态：systemctl status vsftpd.service在开机时启用服务：systemctl enable vsftpd.service在开机时禁用服务：systemctl disable vsftpd.service查看服务是否开机启动：systemctl is-enabled vsftpd.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed","link":"/2021/12/01/service%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA/"},{"title":"shell参数解析","text":"shell参数解析 简单解析 参数 作用 $@ 全部参数 $* 全部参数 $# 参数个数 $n 第n个参数 1$@和$*存在一定区别，当两者在&quot;&quot;中充当参数时，$@不会对所有参数进行处理；$*会把所有参数合并成一个参数处理 getopt 短参数123456789101112131415161718192021#!/bin/bash# test.shwhile getopts &quot;:a:b&quot; optdo case $opt in a) a=$OPTARG echo &quot;a is $a&quot;;; b) echo &quot;b is set&quot;;; ?) echo &quot;getopts param error&quot; exit 1;; esacdone# ./test.sh -b -a 8&quot;:a:b&quot;最前面的引号：忽略执行错误a后面引号：表示该标志后有参数b无引号：表示该标志后无参数 getopts 长参数1234567891011121314151617#!/bin/bash# Setup getopt.long_opts=&quot;debug,arg:&quot;getopt_cmd=$(getopt -o da: --long &quot;$long_opts&quot; \\ -n $(basename $0) -- &quot;$@&quot;) || \\ { echo -e &quot;\\nERROR: Getopt failed. Extra args\\n&quot;; exit 1;}eval set -- &quot;$getopt_cmd&quot;while true; do case &quot;$1&quot; in -d|--debug) echo &quot;debug is true&quot;;; -a|--arg) echo &quot;arg is $2&quot;;; --) shift; break;; esac shiftdone","link":"/2022/09/24/shell%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"},{"title":"内存池","text":"内存池 头文件12345678910111213141516171819202122232425#ifndef __MEMPOOL_H__#define __MEMPOOL_H__#include &lt;stdio.h&gt;class MemPool{ class Impl; Impl *m_impl; MemPool(); ~MemPool();public: static MemPool &amp;instance(); void reset_buff(void *ptr, size_t size); void *alloc(size_t size); void dealloc(void *ptr);};#define malloc(a) MemPool::instance().alloc(a)#define free(a) MemPool::instance().dealloc(a)#endif 基于单向链表的内存池优点是不需要分配管理的内存，性能高，节省内存，缺点是业务的代码如果内存越界，可能会影响内存池的运行；如果业务释放的内存地址是申请内存对齐后的内存，无法正常释放 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;assert.h&gt;#include &lt;stdint.h&gt;#include &lt;mutex&gt;#include &quot;mempool.h&quot;#define MAGIC_NUMBER (0xafafafafu)struct Block{ Block* m_next; uint32_t m_size; uint32_t m_magic = MAGIC_NUMBER; Block(uint32_t size): m_size(size){}; Block(uint32_t size, Block* next): m_size(size), m_next(next){}; inline Block* splitBlock(uint32_t size, Block* next) { if (m_size &lt;= size + sizeof(Block)) return nullptr; Block* newBlock = new (reinterpret_cast&lt;uint8_t*&gt;(getDataStartPtr()) + size) Block(m_size - size - sizeof(Block), next); m_size = size; return newBlock; } inline bool verify() { return m_magic == MAGIC_NUMBER; } inline void* getDataStartPtr() { return this + 1; } inline void* getDataEndPtr() { return (uint8_t*)getDataStartPtr() + m_size; } static inline Block* ptr2Block(void* ptr) { return (Block*)ptr - 1; }};class MemPool::Impl{ Block* m_freeList; size_t m_size; void* m_poolData; std::mutex m_mtx; void mergeBlock(Block* current, Block* previous, Block* next) { if (previous &amp;&amp; (size_t)previous-&gt;getDataEndPtr() == (size_t)current) { previous-&gt;m_size += current-&gt;m_size + sizeof(Block); previous-&gt;m_next = next; current = previous; } if (next &amp;&amp; (size_t)current-&gt;getDataEndPtr() == (size_t)next) { current-&gt;m_size += next-&gt;m_size + sizeof(Block); current-&gt;m_next = next-&gt;m_next; } }public: Impl() { m_freeList = nullptr; m_poolData = nullptr; m_size = 0; }; void reset_buff(void *ptr, size_t size) { std::lock_guard&lt;std::mutex&gt; lock(m_mtx); m_poolData = ptr; m_size = size; m_freeList = new(m_poolData) Block(size - sizeof(Block), nullptr); } void *alloc(size_t size) { if (size == 0) return nullptr; std::lock_guard&lt;std::mutex&gt; lock(m_mtx); Block* current = m_freeList; Block* previous = nullptr; while (current) { if (current-&gt;m_size &gt;= size) { Block* newBlock = current-&gt;splitBlock(size, current-&gt;m_next); if (newBlock == NULL) { newBlock = current-&gt;m_next; } previous ? previous-&gt;m_next = newBlock : m_freeList = newBlock; return current-&gt;getDataStartPtr(); } previous = current; current = current-&gt;m_next; } return nullptr; } void dealloc(void *ptr) { if ((size_t)ptr &lt; (size_t)m_poolData || (size_t)ptr &gt;= (size_t)m_poolData + m_size) { assert(0); } Block* block = Block::ptr2Block(ptr); assert(block-&gt;verify()); std::lock_guard&lt;std::mutex&gt; lock(m_mtx); Block* current = m_freeList; Block* previous = nullptr; while (current &amp;&amp; (size_t)current &lt; (size_t)block) { previous = current; current = current-&gt;m_next; } block-&gt;m_next = current; previous ? previous-&gt;m_next = block : m_freeList = block; mergeBlock(block, previous, current); }};MemPool::MemPool(){ m_impl = new Impl();}MemPool::~MemPool(){ delete m_impl;}MemPool &amp;MemPool::instance(){ static MemPool obj; return obj;}void MemPool::reset_buff(void *ptr, size_t size){ m_impl-&gt;reset_buff(ptr, size);}void *MemPool::alloc(size_t size){ return m_impl-&gt;alloc(size);}void MemPool::dealloc(void *ptr){ m_impl-&gt;dealloc(ptr);} 基于std::list的内存池优点是管理信息的内存（std::list分配）和分配的内存(m_poolData)是分离的，如果业务的代码内存越界，大概率不会影响内存池的运行，可以正常释放内存地址对齐后的内存；缺点std::list需要消耗额外的内存维护内存信息的链表，性能上比单链表low那么一丢丢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;assert.h&gt;#include &lt;stdint.h&gt;#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;algorithm&gt;#include &quot;mempool.h&quot;struct Block{ void* m_data; size_t m_size; bool m_isFree; Block(void *data, size_t size): m_size(size), m_data(data){ m_isFree = true; };};class MemPool::Impl{ std::list&lt;Block&gt; m_memList; size_t m_size; void* m_poolData; std::mutex m_mtx; void mergeBlock(std::list&lt;Block&gt;::iterator&amp; it) { auto nextIt = std::next(it); if (nextIt != m_memList.end() &amp;&amp; nextIt-&gt;m_isFree) { it-&gt;m_size += nextIt-&gt;m_size; m_memList.erase(nextIt); } if (it != m_memList.begin()) { auto prevIt = std::prev(it); if (prevIt-&gt;m_isFree) { prevIt-&gt;m_size += it-&gt;m_size; it = m_memList.erase(it); } } } inline void splitBlock(std::list&lt;Block&gt;::iterator&amp; it, size_t size) { it-&gt;m_isFree = false; if (it-&gt;m_size &gt; size) { size_t freeSize = it-&gt;m_size - size; it-&gt;m_size = size; m_memList.emplace(std::next(it), (uint8_t*)it-&gt;m_data + size, freeSize); } }public: Impl() { m_poolData = nullptr; m_size = 0; }; void reset_buff(void *ptr, size_t size) { std::lock_guard&lt;std::mutex&gt; lock(m_mtx); m_poolData = ptr; m_size = size; m_memList.clear(); m_memList.emplace_back(ptr, size); } void *alloc(size_t size) { if (size == 0) return nullptr; std::lock_guard&lt;std::mutex&gt; lock(m_mtx); for (auto it = m_memList.begin(); it != m_memList.end(); it++) { if (it-&gt;m_isFree &amp;&amp; it-&gt;m_size &gt;= size) { splitBlock(it, size); return it-&gt;m_data; } } return nullptr; } void dealloc(void *ptr) { if ((size_t)ptr &lt; (size_t)m_poolData || (size_t)ptr &gt;= (size_t)m_poolData + m_size) { assert(0); } std::lock_guard&lt;std::mutex&gt; lock(m_mtx); auto it = std::find_if(m_memList.begin(), m_memList.end(), [ptr](const Block&amp; ele){ return !ele.m_isFree &amp;&amp; (size_t)ptr &gt;= (size_t)ele.m_data &amp;&amp; (size_t)ptr &lt; (size_t)ele.m_data + ele.m_size; }); if (it == m_memList.end()) { assert(0); } it-&gt;m_isFree = true; mergeBlock(it); }};MemPool::MemPool(){ m_impl = new Impl();}MemPool::~MemPool(){ delete m_impl;}MemPool &amp;MemPool::instance(){ static MemPool obj; return obj;}void MemPool::reset_buff(void *ptr, size_t size){ m_impl-&gt;reset_buff(ptr, size);}void *MemPool::alloc(size_t size){ return m_impl-&gt;alloc(size);}void MemPool::dealloc(void *ptr){ m_impl-&gt;dealloc(ptr);}","link":"/2025/03/09/%E5%86%85%E5%AD%98%E6%B1%A0/"},{"title":"常用docker容器命令","text":"常用docker容器命令 常用docker容器命令1234567891011121314151617181920212223242526curl -fsSL http://chengs.run/upload/2022/10/installJD.sh | bash docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer-test portainer/portainersudo docker run --name adguardhome -v /AdguardHome:/opt/adguardhome/work -v /AdguardHome:/opt/adguardhome/conf -d --network macnet adguard/adguardhome:arm64-edge docker run --name mysqlserver -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=***** -d -i -p 3306:3306 mysql:latestsudo docker run -d --name mongodb -v /mydata/mongodb/datadb:/data/db -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin --privileged=true mongo:4sudo docker run -itd -p 41020-41030:41020-41030 -p 41020-41030:41020-41030/udp -p 54321:54321 -v $PWD/db/:/etc/x-ui/ -v $PWD/cert/:/root/cert/ --name x-ui --restart=unless-stopped enwaiax/x-ui:latestdocker run --name myadmin -d -e PMA_ARBITRARY=1 -e PMA_ABSOLUTE_URI=https://myadmin.chengs.run/ -p 8080:80 phpmyadmin/phpmyadmindocker run --name myphp-fpm -v ~/.maccms/www:/www/html -p 9009:9000 -d php:7.1-fpmdocker run -dit --name jd -v /root/.jd/config:/jd/config -v /root/.jd/log:/jd/log -p 5677:5678 --restart always shuye72/jd-base:giteesudo docker run -d --name=genshin -v $PWD/genshin/config:/app/genshincheckinhelper/config -e TZ=&quot;Asia/Shanghai&quot; --restart always yindan/genshinhelperdocker run -d -v /media/wxedge_storage/:/home/ftpuser -e FTP_USER=ftpuser -e FTP_PASS=111111 -e PASV_ADDRESS=192.168.1.19 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 -p 20:20 -p 21:21 -p 21100-21110:21100-21110 --name vsftpd shourai/vsftpd-alpinesudo docker run -d --restart=always --name nps --net=host -v /home/admin/.nps:/conf -v /etc/localtime:/etc/localtime:ro yisier1/nps:latestsudo docker run -d -p 5032:5032 --log-driver json-file --log-opt max-file=1 --log-opt max-size=10m --restart always --name webssh -e TZ=Asia/Shanghai -e savePass=false jrohy/webssh","link":"/2022/01/16/%E5%B8%B8%E7%94%A8docker%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4/"},{"title":"广播数据扫描和发送","text":"广播数据扫描和发送 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/select.h&gt; #define ERRLOG(errmsg) do{\\ perror(errmsg);\\ printf(&quot;%s--%s(%d)\\n&quot;, __FILE__, __func__, __LINE__);\\ exit(-1);\\ }while(0) int scanMsg(const char* ip, const char* port, const char* groupNamePack, const char* masterIP){ int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if(-1 == sockfd){ ERRLOG(&quot;socket error&quot;); close(sockfd); return -1; } struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(atoi(port)); server_addr.sin_addr.s_addr = inet_addr(ip); socklen_t addrlen = sizeof(server_addr); if(-1 == bind(sockfd, (struct sockaddr *)&amp;server_addr, addrlen)){ ERRLOG(&quot;bind error&quot;); close(sockfd); return -1; } struct sockaddr_in client_addr; memset(&amp;server_addr, 0, sizeof(client_addr)); socklen_t clientaddrlen = sizeof(client_addr); char buff[128] = {0}; fd_set rset; FD_ZERO(&amp;rset); FD_SET(sockfd, &amp;rset); struct timeval tv; tv.tv_sec = 0; tv.tv_usec = 100*1000; int retsta = select(sockfd + 1, &amp;rset, NULL, NULL, &amp;tv); if(retsta &lt; 0){ ERRLOG(&quot;select error&quot;); close(sockfd); return -1; }else if (retsta &gt; 0 &amp;&amp; FD_ISSET(sockfd, &amp;rset)){ if(-1 == recvfrom(sockfd, buff, 128, 0, (struct sockaddr *)&amp;client_addr, &amp;clientaddrlen)){ ERRLOG(&quot;recvfrom error&quot;); close(sockfd); return -1; } printf(&quot;%s(%d):%s\\n&quot;, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), buff); if(strcmp(buff, groupNamePack) == 0){ //发送应答信息 if(-1 == sendto(sockfd, masterIP, strlen(masterIP), 0, (struct sockaddr *)&amp;client_addr, clientaddrlen)){ ERRLOG(&quot;sendto error&quot;); close(sockfd); return -1; } } }else{ printf(&quot;scanMsg don't receive mess\\n&quot;); } close(sockfd); return 0;} int sendMsg(const char* ip, const char* port, const char* groupNamePack, char* masterIP, size_t len){ int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if(-1 == sockfd){ ERRLOG(&quot;socket error&quot;); close(sockfd); return -1; } //设置套接字允许发送广播 int on = 1; if(-1 == setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;on, sizeof(on))){ ERRLOG(&quot;setsockopt error&quot;); close(sockfd); return -1; } struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(atoi(port)); server_addr.sin_addr.s_addr = inet_addr(ip); socklen_t addrlen = sizeof(server_addr); if(-1 == sendto(sockfd, groupNamePack, strlen(groupNamePack), 0, (struct sockaddr *)&amp;server_addr, addrlen)){ ERRLOG(&quot;sendto error&quot;); close(sockfd); return -1; } struct timeval tv; tv.tv_sec = 0; tv.tv_usec = 1000*100; fd_set rset; FD_ZERO(&amp;rset); FD_SET(sockfd, &amp;rset); int retsta = select(sockfd + 1, &amp;rset, NULL, NULL, &amp;tv); if(retsta &lt; 0){ ERRLOG(&quot;select error&quot;); close(sockfd); return -1; }else if (retsta &gt; 0 &amp;&amp; FD_ISSET(sockfd, &amp;rset)){ if(-1 == recvfrom(sockfd, masterIP, len, 0, NULL, NULL)){ ERRLOG(&quot;recvfrom error&quot;); close(sockfd); return -1; } }else{ printf(&quot;sendMsg don't receive\\n&quot;); } close(sockfd); return 0;}void* run(void* arg){ while(true){ scanMsg(&quot;192.168.1.255&quot;, &quot;4000&quot;, &quot;sjhdhasdhjshj&quot;, &quot;this is my ip&quot;); usleep(1000); } return NULL;}int main(int argc, char const *argv[]){ pthread_t tid; pthread_create(&amp;tid, NULL, run, NULL); // pthread_join(tid, NULL); char msIP[128] = {0}; sendMsg(&quot;192.168.1.255&quot;, &quot;4000&quot;, &quot;sjhdhasdhjshj&quot;, msIP, 128); if(strlen(msIP)){ printf(&quot;msIP:%s\\n&quot;, msIP); } usleep(1000); return 0;}","link":"/2022/08/31/%E5%B9%BF%E6%92%AD%E6%95%B0%E6%8D%AE%E6%89%AB%E6%8F%8F%E5%92%8C%E5%8F%91%E9%80%81/"},{"title":"抄作业！！！","text":"… docker and docker-compose12345678910111213141516# 安装dockercurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun# 安装docker-composesudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composesudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-composedocker-compose --version# docker-compose操作docker-compose up -d --no-recreatedocker-compose ps -adocker-compose logs packstream &amp;&amp; peer2profit提前声明环境变量:export COMPOSE_HTTP_TIMEOUT=500 packstream docker-compose.yml1234567891011121314151617181920212223242526272829https://github.com/xuchengcheng926/packetstream/raw/main/docker-compose.yamltest 2MyD 大号 2LTgexport COMPOSE_HTTP_TIMEOUT=500 &amp;&amp; mkdir packstream &amp;&amp; cd packstream &amp;&amp; nano docker-compose.ymlversion: '3.8'services: packetstream: deploy: mode: replicated replicas: 350 restart_policy: condition: on-failure max_attempts: 2 resources: limits: cpus: &quot;0.1&quot; memory: '30M' image: packetstream/psclient:latest environment: - CID=2MyD - http_proxy=http://194.226.139.221:8458 - https_proxy=http://194.226.139.221:8458 logging: driver: json-file options: max-size: &quot;10m&quot; max-file: &quot;1&quot; peer2profit docker-compose.yml1234567891011121314151617181920212223https://github.com/Chasing66/peer2profit/blob/main/docker-compose.ymlexport COMPOSE_HTTP_TIMEOUT=500 &amp;&amp; mkdir peer2profit&amp;&amp; cd peer2profit &amp;&amp; nano docker-compose.ymlversion: '3.8'services: p2p: deploy: replicas: 10 restart_policy: condition: on-failure max_attempts: 2 resources: limits: cpus: &quot;0.15&quot; memory: '35M' image: enwaiax/peer2profit:latest environment: - email=xuchengscc@gmail.com logging: driver: json-file options: max-size: &quot;10m&quot; max-file: &quot;1&quot;","link":"/2021/09/08/%E6%8A%84%E4%BD%9C%E4%B8%9A%EF%BC%81%EF%BC%81%EF%BC%81/"},{"title":"树莓派挂swap、允许docker限制内存","text":"树莓派挂swap、允许docker限制内存 修改sudo nano /etc/dphys-swapfile docker提示系统不支持cgroup内存限制，需要手动开启。解决方案是在/boot/cmdline.txt尾部加入 cgroup_enable=memory cgroup_memory=1后重启 docker run -d –name nginx2 –memory 1G –memory-swap 1G nginxdocker update ubuntu:16.04 –memory-swap -1 -m 512M sudo docker run -d –name=wxedge –restart=always –privileged –network=macnet –memory-swap -1 -m 1638M –tmpfs /run –tmpfs /tmp -v /media/wxedge_storage:/storage:rw onething1/wxedge 挂载普通swap 1234dd if=/dev/zero of=/swapfile bs=1M count=4096mkswap /swapfileswapon /swapfileecho &quot;/swapfile swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab","link":"/2022/06/27/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82swap%E3%80%81%E5%85%81%E8%AE%B8docker%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98/"},{"title":"自建KMS服务器","text":"window激活 KMS密钥以下key来源于微软官网：https://technet.microsoft.com/en-us/library/jj612867.aspx操作系统 KMS激活序列号 操作系统 KMS激活序列号 Windows11专业版 W269N-WFGWX-YVC9B-4J6C9-T83GX Windows Server 2016 Datacenter CB7KF-BWN84-R7R2Y-793K2-8XDDG Windows Server 2016 Standard WC2BQ-8NRM3-FDDYY-2BFGV-KHKQY Windows Server 2016 Essentials JCKRF-N37P4-C2D82-9YXRT-4M63B Windows 10 Professional W269N-WFGWX-YVC9B-4J6C9-T83GX Windows 10 Professional N MH37W-N47XK-V7XM9-C7227-GCQG9 Windows 10 Enterprise NPPR9-FWDCX-D2C8J-H872K-2YT43 Windows 10 Enterprise N DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4 Windows 10 Education NW6C2-QMPVW-D7KKK-3GKT6-VCFB2 Windows 10 Education N 2WH4N-8QGBV-H22JP-CT43Q-MDWWJ Windows 10 Enterprise 2015 LTSB WNMTR-4C88C-JK8YV-HQ7T2-76DF9 Windows 10 Enterprise 2015 LTSB N 2F77B-TNFGY-69QQF-B8YKP-D69TJ Windows 10 Enterprise 2016 LTSB DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ Windows 10 Enterprise 2016 LTSB N QFFDN-GRT3P-VKWWX-X7T3R-8B639 Windows 8.1 Professional GCRJD-8NW9H-F2CDX-CCM8D-9D6T9 Windows 8.1 Professional N HMCNV-VVBFX-7HMBH-CTY9B-B4FXY Windows 8.1 Enterprise MHF9N-XY6XB-WVXMC-BTDCT-MKKG7 Windows 8.1 Enterprise N TT4HM-HN7YT-62K67-RGRQJ-JFFXW Windows Server 2012 R2 Server Standard D2N9P-3P6X9-2R39C-7RTCD-MDVJX Windows Server 2012 R2 Datacenter W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9 Windows Server 2012 R2 Essentials KNC87-3J2TX-XB4WP-VCPJV-M4FWM Windows 8 Professional NG4HW-VH26C-733KW-K6F98-J8CK4 Windows 8 Professional N XCVCF-2NXM9-723PB-MHCB7-2RYQQ Windows 8 Enterprise 32JNW-9KQ84-P47T8-D8GGY-CWCK7 Windows 8 Enterprise N JMNMF-RHW7P-DMY6X-RF3DR-X2BQT Windows Server 2012 BN3D2-R7TKB-3YPBD-8DRP2-27GG4 Windows Server 2012 N 8N2M2-HWPGY-7PGT9-HGDD8-GVGGY Windows Server 2012 Single Language 2WN2H-YGCQR-KFX6K-CD6TF-84YXQ Windows Server 2012 Country Specific 4K36P-JN4VD-GDC6V-KDT89-DYFKP Windows Server 2012 Server Standard XC9B7-NBPP2-83J2H-RHMBY-92BT4 Windows Server 2012 MultiPoint Standard HM7DN-YVMH3-46JC3-XYTG7-CYQJJ Windows Server 2012 MultiPoint Premium XNH6W-2V9GX-RGJ4K-Y8X6F-QGJ2G Windows Server 2012 Datacenter 48HP8-DN98B-MYWDG-T2DCC-8W83P Windows 7 Professional FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4 Windows 7 Professional N MRPKT-YTG23-K7D7T-X2JMM-QY7MG Windows 7 Professional E W82YF-2Q76Y-63HXB-FGJG9-GF7QX Windows 7 Enterprise 33PXH-7Y6KF-2VJC9-XBBR8-HVTHH Windows 7 Enterprise N YDRBP-3D83W-TY26F-D46B2-XCKRJ Windows 7 Enterprise E C29WB-22CC8-VJ326-GHFJW-H9DH4 Windows Server 2008 R2 Web 6TPJF-RBVHG-WBW2R-86QPH-6RTM4 Windows Server 2008 R2 HPC edition TT8MH-CG224-D3D7Q-498W2-9QCTX Windows Server 2008 R2 Standard YC6KT-GKW9T-YTKYR-T4X34-R7VHC Windows Server 2008 R2 Enterprise 489J6-VHDMP-X63PK-3K798-CPX3Y Windows Server 2008 R2 Datacenter 74YFP-3QFB3-KQT8W-PMXWJ-7M648 Windows Server 2008 R2 for Itanium-based Systems GT63C-RJFQ3-4GMB6-BRFB9-CB83V Windows Vista Business YFKBB-PQJJV-G996G-VWGXY-2V3X8 Windows Vista Business N HMBQG-8H2RH-C77VX-27R82-VMQBT Windows Vista Enterprise VKK3X-68KWM-X2YGT-QR4M6-4BWMV Windows Vista Enterprise N VTC42-BM838-43QHV-84HX6-XJXKV Windows Web Server 2008 WYR28-R7TFJ-3X2YQ-YCY4H-M249D Windows Server 2008 Standard TM24T-X9RMF-VWXK6-X8JC9-BFGM2 Windows Server 2008 Standard without Hyper-V W7VD6-7JFBR-RX26B-YKQ3Y-6FFFJ Windows Server 2008 Enterprise YQGMW-MPWTJ-34KDK-48M3W-X4Q6V Windows Server 2008 Enterprise without Hyper-V 39BXF-X8Q23-P2WWT-38T2F-G3FPG Windows Server 2008 HPC RCTX3-KWVHP-BR6TB-RB6DM-6X7HP Windows Server 2008 Datacenter 7M67G-PC374-GR742-YH8V4-TCBY3 Windows Server 2008 Datacenter without Hyper-V 22XQ2-VRXRG-P8D42-K34TD-G3QQC Windows Server 2008 for Itanium-Based Systems 4DWFP-JF3DJ-B7DTH-78FJB-PDRHK 激活命令12345@echo offslmgr /skms chengs.runslmgr /ipk KMS激活序列号slmgr /atoslmgr /xpr KMS服务器搭建1docker run -itd -p 1688:1688 luodaoyi/kms-server","link":"/2022/10/22/%E8%87%AA%E5%BB%BAKMS%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"酒厂大尺度合集","text":"照片 小黄人和他的朋友们","link":"/2021/09/08/%E9%85%92%E5%8E%82%E5%A4%A7%E5%B0%BA%E5%BA%A6%E5%90%88%E9%9B%86/"},{"title":"附件库","text":"stm32的四轴无人机 Your browser does not support the video tag.","link":"/2022/05/24/%E9%99%84%E4%BB%B6%E5%BA%93/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"linux应用开发","slug":"linux应用开发","link":"/tags/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"skr！skr","slug":"skr！skr","link":"/tags/skr%EF%BC%81skr/"},{"name":"imx6ull","slug":"imx6ull","link":"/tags/imx6ull/"},{"name":"linux驱动开发","slug":"linux驱动开发","link":"/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c/c++","slug":"c-c","link":"/tags/c-c/"},{"name":"附件","slug":"附件","link":"/tags/%E9%99%84%E4%BB%B6/"}],"categories":[{"name":"web","slug":"web","link":"/categories/web/"},{"name":"linux","slug":"linux","link":"/categories/linux/"}]}