{"title":"linux应用开发(1)","date":"2022-06-18T03:27:28.596Z","source":"_posts/Linux应用开发(1).md","raw":"---\ntitle: linux应用开发(1)\ndate: 2022-06-18 11:27:28.596\nupdated: 2022-06-18 14:33:27.311\ncategories: \ntags: \n- linux应用开发\n- linux\n---\nLinux应用开发基础\n<!-- more -->\n1. 由源文件到可执行文件分为四部分\n   - 预编译 gcc -E main.c -O main.i\n   - 编译 gcc -S main.i -O main.s\n   - 汇编 gcc -C main.s -O main.o\n   - 链接 gcc main.o -O main\n2. Makefile\n3. GDB调试程序\n   - debug和release版本的区别\n   - gcc -g 编译debug版本\n   - 通常使用gdb调试程序\n     - l 显示代码\n     - b 行号/函数名 加断点\n     - info break 查看断点信息\n     - r 运行程序\n     - n 单布执行\n     - p 打印内容\n     - c 继续运行\n     - s 进入函数\n     - finish 退出函数\n     - q 退出程序\n     - bt 函数调用栈的关系\n4. 静态库和共享库\n   - libxxx.a(静态库)、libxxx.so(共享库)\n   - 库文件默认在/lib、/usr/lib,头文件默认放在/usr/include下\n   - 静态库：\n     - ar crv libxx.a a.o b.o\n     - gcc -o main main.c -L路径 -l库名\n   - 共享库\n     - gcc -shared -fPIC -o libfoo.so add.o max.o\n     - gcc -o main main.c -L路径 -l库名(在使用该命令时，默认优先使用共享库)\n     - 在运行共享库时默认再标准目录下找共享库，使用ldd命令查看库调用情况\n5. 主函数入口参数\n   - argc：参数数量\n   - grgv：参数内容\n     - 数组指针：int (*p)[] = NULL\n     - 指针数组：int *p[n] = {NULL}\n   - envp：环境变量,环境变量继承自父进程，在命令行中执行程序时，父进程就是bash命令行，可以使用export添加环境变量\n6. 输出缓冲区\n   - 在执行printf时，会将数据发送到数据缓冲区，数据缓冲区在积攒一定数据后，会将数据打印到窗口\n   - 使用\\n换行符会将数据立刻打印输出\n   - 使用fflush(stdout)刷新缓冲区\n   - 如果不刷新缓冲区，数据不会被打印，默认在exit函数中进行刷新，若使用_exit(1)可以观察到，无数据输出\n7. fork复制进程\n   - 父进程的fork()结果不为0，子进程为0\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[], char *envp[])\n{\n    char *s = NULL;\n    int n = 0;\n\n    pid_t id = fork();\n    assert( id != -1);\n    if(id == 0)\n    {\n        s = \"child\";\n        n = 3;\n    }\n    else\n    {\n        s = \"parent\";\n        n = 7;\n    }\n    int i = 0;\n    for (; i < n; i++)\n    {\n        printf(\"s=%s,pid=%d,ppid=%d\\n\", s, getpid(), getppid());\n        sleep(1);\n    }\n    exit(0);\n}\n```\n8. fork写时拷贝技术\n   - 物理内存、逻辑内存：程序内存在物理内存中空间是不连续的，在逻辑内存中不是连续的，一般采用页表进行映射，一般情况一页的大小为4K\n   - 页表：逻辑内存到物理内存的映射关系\n   - 由于两者采用页表进行映射，所以可以使不同进程的逻辑页映射到相同的物理页\n      - 在进行进程复制时，若对物理页完全复制，则在物理内存中会出现较多重复内容（有的页数据只读，并不修改），会浪费机器性能，所以采用写时拷贝技术\n      - 某页数据需要进行修改，则将该页复制到其他页上，修改逻辑页表，改变映射关系\n9.  逻辑地址与物理地址\n    - 程序中看到的地址一般为逻辑地址\n    - 在32位中最大内存4G\n      - 高位1G: 内核使用\n      - 低位3G: 用户使用\n    - 相同逻辑地址可能不是相同物理地址\n10. 僵死进程(defunct)\n    - 当子进程先于父进程结束，父进程没有获取子进程的退出码，此时子进程变成僵死进程\n    - 在lunix中子进程退出后，程序实体会被去除，但PCB会被保留，父进程从子进程的PCB中可以获取子进程的退出码\n    - 避免产生僵死进程\n      - 父进程调用wait()方法获取子进程的退出码，此时会阻塞\n      - 父进程先结束：在lunix中父进程结束后子进程如果没结束被称为孤儿进程，会被分配一个父进程（init进程），init进程会收养其他孤儿进程，在子进程结束后获取子进程退出码\n      - 退出码左移8位后的数据是wait返回数据\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[], char *envp[])\n{\n    char *s = NULL;\n    int n = 0;\n\n    pid_t id = fork();\n    assert( id != -1);\n    if(id == 0)\n    {\n        s = \"child\";\n        n = 3;\n    }\n    else\n    {\n        s = \"parent\";\n        n = 5;\n        int val = 0;\n        printf(\"waid pid:%d\\n\", wait(&val));\n        if(WIFEXITED(val))\n        {\n            printf(\"exitId is:%d\\n\", WEXITSTATUS(val)); \n        }\n    }\n    int i = 0;\n    for (; i < n; i++)\n    {\n        printf(\"s=%s,pid=%d,ppid=%d\\n\", s, getpid(), getppid());\n        sleep(1);\n    }\n    exit(2);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   ","slug":"Linux应用开发(1)","published":true,"updated":"2022-06-18T06:33:27.311Z","_id":"cm833960f0005i0q6gefvaaci","comments":true,"layout":"post","photos":[],"html":"<p>Linux应用开发基础</p>\n<span id=\"more\"></span>\n<ol>\n<li>由源文件到可执行文件分为四部分<ul>\n<li>预编译 gcc -E main.c -O main.i</li>\n<li>编译 gcc -S main.i -O main.s</li>\n<li>汇编 gcc -C main.s -O main.o</li>\n<li>链接 gcc main.o -O main</li>\n</ul>\n</li>\n<li>Makefile</li>\n<li>GDB调试程序<ul>\n<li>debug和release版本的区别</li>\n<li>gcc -g 编译debug版本</li>\n<li>通常使用gdb调试程序<ul>\n<li>l 显示代码</li>\n<li>b 行号&#x2F;函数名 加断点</li>\n<li>info break 查看断点信息</li>\n<li>r 运行程序</li>\n<li>n 单布执行</li>\n<li>p 打印内容</li>\n<li>c 继续运行</li>\n<li>s 进入函数</li>\n<li>finish 退出函数</li>\n<li>q 退出程序</li>\n<li>bt 函数调用栈的关系</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>静态库和共享库<ul>\n<li>libxxx.a(静态库)、libxxx.so(共享库)</li>\n<li>库文件默认在&#x2F;lib、&#x2F;usr&#x2F;lib,头文件默认放在&#x2F;usr&#x2F;include下</li>\n<li>静态库：<ul>\n<li>ar crv libxx.a a.o b.o</li>\n<li>gcc -o main main.c -L路径 -l库名</li>\n</ul>\n</li>\n<li>共享库<ul>\n<li>gcc -shared -fPIC -o libfoo.so add.o max.o</li>\n<li>gcc -o main main.c -L路径 -l库名(在使用该命令时，默认优先使用共享库)</li>\n<li>在运行共享库时默认再标准目录下找共享库，使用ldd命令查看库调用情况</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>主函数入口参数<ul>\n<li>argc：参数数量</li>\n<li>grgv：参数内容<ul>\n<li>数组指针：int (*p)[] &#x3D; NULL</li>\n<li>指针数组：int *p[n] &#x3D; {NULL}</li>\n</ul>\n</li>\n<li>envp：环境变量,环境变量继承自父进程，在命令行中执行程序时，父进程就是bash命令行，可以使用export添加环境变量</li>\n</ul>\n</li>\n<li>输出缓冲区<ul>\n<li>在执行printf时，会将数据发送到数据缓冲区，数据缓冲区在积攒一定数据后，会将数据打印到窗口</li>\n<li>使用\\n换行符会将数据立刻打印输出</li>\n<li>使用fflush(stdout)刷新缓冲区</li>\n<li>如果不刷新缓冲区，数据不会被打印，默认在exit函数中进行刷新，若使用_exit(1)可以观察到，无数据输出</li>\n</ul>\n</li>\n<li>fork复制进程<ul>\n<li>父进程的fork()结果不为0，子进程为0</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[], <span class=\"type\">char</span> *envp[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *s = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    assert( id != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = <span class=\"string\">&quot;child&quot;</span>;</span><br><span class=\"line\">        n = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = <span class=\"string\">&quot;parent&quot;</span>;</span><br><span class=\"line\">        n = <span class=\"number\">7</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;s=%s,pid=%d,ppid=%d\\n&quot;</span>, s, getpid(), getppid());</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>fork写时拷贝技术<ul>\n<li>物理内存、逻辑内存：程序内存在物理内存中空间是不连续的，在逻辑内存中不是连续的，一般采用页表进行映射，一般情况一页的大小为4K</li>\n<li>页表：逻辑内存到物理内存的映射关系</li>\n<li>由于两者采用页表进行映射，所以可以使不同进程的逻辑页映射到相同的物理页<ul>\n<li>在进行进程复制时，若对物理页完全复制，则在物理内存中会出现较多重复内容（有的页数据只读，并不修改），会浪费机器性能，所以采用写时拷贝技术</li>\n<li>某页数据需要进行修改，则将该页复制到其他页上，修改逻辑页表，改变映射关系</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>逻辑地址与物理地址<ul>\n<li>程序中看到的地址一般为逻辑地址</li>\n<li>在32位中最大内存4G<ul>\n<li>高位1G: 内核使用</li>\n<li>低位3G: 用户使用</li>\n</ul>\n</li>\n<li>相同逻辑地址可能不是相同物理地址</li>\n</ul>\n</li>\n<li>僵死进程(defunct)<ul>\n<li>当子进程先于父进程结束，父进程没有获取子进程的退出码，此时子进程变成僵死进程</li>\n<li>在lunix中子进程退出后，程序实体会被去除，但PCB会被保留，父进程从子进程的PCB中可以获取子进程的退出码</li>\n<li>避免产生僵死进程<ul>\n<li>父进程调用wait()方法获取子进程的退出码，此时会阻塞</li>\n<li>父进程先结束：在lunix中父进程结束后子进程如果没结束被称为孤儿进程，会被分配一个父进程（init进程），init进程会收养其他孤儿进程，在子进程结束后获取子进程退出码</li>\n<li>退出码左移8位后的数据是wait返回数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[], <span class=\"type\">char</span> *envp[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *s = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    assert( id != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = <span class=\"string\">&quot;child&quot;</span>;</span><br><span class=\"line\">        n = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = <span class=\"string\">&quot;parent&quot;</span>;</span><br><span class=\"line\">        n = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;waid pid:%d\\n&quot;</span>, wait(&amp;val));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(WIFEXITED(val))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exitId is:%d\\n&quot;</span>, WEXITSTATUS(val)); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;s=%s,pid=%d,ppid=%d\\n&quot;</span>, s, getpid(), getppid());</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"<p>Linux应用开发基础</p>","more":"<ol>\n<li>由源文件到可执行文件分为四部分<ul>\n<li>预编译 gcc -E main.c -O main.i</li>\n<li>编译 gcc -S main.i -O main.s</li>\n<li>汇编 gcc -C main.s -O main.o</li>\n<li>链接 gcc main.o -O main</li>\n</ul>\n</li>\n<li>Makefile</li>\n<li>GDB调试程序<ul>\n<li>debug和release版本的区别</li>\n<li>gcc -g 编译debug版本</li>\n<li>通常使用gdb调试程序<ul>\n<li>l 显示代码</li>\n<li>b 行号&#x2F;函数名 加断点</li>\n<li>info break 查看断点信息</li>\n<li>r 运行程序</li>\n<li>n 单布执行</li>\n<li>p 打印内容</li>\n<li>c 继续运行</li>\n<li>s 进入函数</li>\n<li>finish 退出函数</li>\n<li>q 退出程序</li>\n<li>bt 函数调用栈的关系</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>静态库和共享库<ul>\n<li>libxxx.a(静态库)、libxxx.so(共享库)</li>\n<li>库文件默认在&#x2F;lib、&#x2F;usr&#x2F;lib,头文件默认放在&#x2F;usr&#x2F;include下</li>\n<li>静态库：<ul>\n<li>ar crv libxx.a a.o b.o</li>\n<li>gcc -o main main.c -L路径 -l库名</li>\n</ul>\n</li>\n<li>共享库<ul>\n<li>gcc -shared -fPIC -o libfoo.so add.o max.o</li>\n<li>gcc -o main main.c -L路径 -l库名(在使用该命令时，默认优先使用共享库)</li>\n<li>在运行共享库时默认再标准目录下找共享库，使用ldd命令查看库调用情况</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>主函数入口参数<ul>\n<li>argc：参数数量</li>\n<li>grgv：参数内容<ul>\n<li>数组指针：int (*p)[] &#x3D; NULL</li>\n<li>指针数组：int *p[n] &#x3D; {NULL}</li>\n</ul>\n</li>\n<li>envp：环境变量,环境变量继承自父进程，在命令行中执行程序时，父进程就是bash命令行，可以使用export添加环境变量</li>\n</ul>\n</li>\n<li>输出缓冲区<ul>\n<li>在执行printf时，会将数据发送到数据缓冲区，数据缓冲区在积攒一定数据后，会将数据打印到窗口</li>\n<li>使用\\n换行符会将数据立刻打印输出</li>\n<li>使用fflush(stdout)刷新缓冲区</li>\n<li>如果不刷新缓冲区，数据不会被打印，默认在exit函数中进行刷新，若使用_exit(1)可以观察到，无数据输出</li>\n</ul>\n</li>\n<li>fork复制进程<ul>\n<li>父进程的fork()结果不为0，子进程为0</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[], <span class=\"type\">char</span> *envp[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *s = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    assert( id != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = <span class=\"string\">&quot;child&quot;</span>;</span><br><span class=\"line\">        n = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = <span class=\"string\">&quot;parent&quot;</span>;</span><br><span class=\"line\">        n = <span class=\"number\">7</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;s=%s,pid=%d,ppid=%d\\n&quot;</span>, s, getpid(), getppid());</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>fork写时拷贝技术<ul>\n<li>物理内存、逻辑内存：程序内存在物理内存中空间是不连续的，在逻辑内存中不是连续的，一般采用页表进行映射，一般情况一页的大小为4K</li>\n<li>页表：逻辑内存到物理内存的映射关系</li>\n<li>由于两者采用页表进行映射，所以可以使不同进程的逻辑页映射到相同的物理页<ul>\n<li>在进行进程复制时，若对物理页完全复制，则在物理内存中会出现较多重复内容（有的页数据只读，并不修改），会浪费机器性能，所以采用写时拷贝技术</li>\n<li>某页数据需要进行修改，则将该页复制到其他页上，修改逻辑页表，改变映射关系</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>逻辑地址与物理地址<ul>\n<li>程序中看到的地址一般为逻辑地址</li>\n<li>在32位中最大内存4G<ul>\n<li>高位1G: 内核使用</li>\n<li>低位3G: 用户使用</li>\n</ul>\n</li>\n<li>相同逻辑地址可能不是相同物理地址</li>\n</ul>\n</li>\n<li>僵死进程(defunct)<ul>\n<li>当子进程先于父进程结束，父进程没有获取子进程的退出码，此时子进程变成僵死进程</li>\n<li>在lunix中子进程退出后，程序实体会被去除，但PCB会被保留，父进程从子进程的PCB中可以获取子进程的退出码</li>\n<li>避免产生僵死进程<ul>\n<li>父进程调用wait()方法获取子进程的退出码，此时会阻塞</li>\n<li>父进程先结束：在lunix中父进程结束后子进程如果没结束被称为孤儿进程，会被分配一个父进程（init进程），init进程会收养其他孤儿进程，在子进程结束后获取子进程退出码</li>\n<li>退出码左移8位后的数据是wait返回数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[], <span class=\"type\">char</span> *envp[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *s = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    assert( id != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = <span class=\"string\">&quot;child&quot;</span>;</span><br><span class=\"line\">        n = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = <span class=\"string\">&quot;parent&quot;</span>;</span><br><span class=\"line\">        n = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;waid pid:%d\\n&quot;</span>, wait(&amp;val));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(WIFEXITED(val))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exitId is:%d\\n&quot;</span>, WEXITSTATUS(val)); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;s=%s,pid=%d,ppid=%d\\n&quot;</span>, s, getpid(), getppid());</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","path":"2022/06/18/Linux应用开发(1)/","permalink":"http://chengs.run/2022/06/18/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91(1)/","tags":[{"name":"linux","_id":"cm833960c0002i0q66dwgd8wg","slug":"linux","path":"tags/linux/","permalink":"http://chengs.run/tags/linux/","length":13},{"name":"linux应用开发","_id":"cm833960i000bi0q6eki8aqst","slug":"linux应用开发","path":"tags/linux应用开发/","permalink":"http://chengs.run/tags/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/","length":4}],"categories":[],"prev":{"title":"linux应用开发(2)","date":"2022-06-19T11:36:06.277Z","slug":"LINUX应用开发(2)","published":true,"updated":"2022-06-19T11:37:02.018Z","_id":"cm833960d0003i0q6h1vo40ub","layout":"post","photos":[],"excerpt":"<p>Linux应用开发</p>","path":"2022/06/19/LINUX应用开发(2)/","permalink":"http://chengs.run/2022/06/19/LINUX%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91(2)/","__post":true},"next":{"title":"Linux基础命令","date":"2022-06-17T13:53:53.953Z","slug":"Linux基础命令","published":true,"updated":"2022-06-17T13:55:16.619Z","_id":"cm833960e0004i0q65czm0cdw","layout":"post","photos":[],"excerpt":"<p>Linux基础命令</p>","path":"2022/06/17/Linux基础命令/","permalink":"http://chengs.run/2022/06/17/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","__post":true},"__post":true}