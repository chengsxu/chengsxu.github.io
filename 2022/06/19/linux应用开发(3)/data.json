{"title":"linux应用开发(3)","date":"2022-06-19T14:32:09.995Z","source":"_posts/linux应用开发(3).md","raw":"---\ntitle: linux应用开发(3)\ndate: 2022-06-19 22:32:09.995\nupdated: 2022-06-19 22:32:27.126\ncategories: \ntags: \n- linux应用开发\n- linux\n---\nLinux应用开发\n<!-- more -->\n# Linux平台c语言应用开发\n## 1. socket 网络编程与TCP\n- 主机字节序列和网络字节序列\n  - 大端：高字节在低位，低字节在高位\n  - 小端：高字节在高位，低字节在地位（x86架构多采用小端）\n- 网络规定使用大端字节序，所以也把大端字节序成为网络字节序列\n```c\nuint32_t htonl(uint32_t hostlong); // 长整型的主机字节序转网络字节序\nuint32_t ntohl(uint32_t netlong); // 长整型的网络字节序转主机字节序\nuint16_t htons(uint16_t hostshort); // 短整形的主机字节序转网络字节序\nuint16_t ntohs(uint16_t netshort); // 短整型的网络字节序转主机字节序\n\nin_addr_t inet_addr(const char *cp); //字符串表示的 IPV4 地址转化为网络字节序\nchar* inet_ntoa(struct in_addr in); // IPV4 地址的网络字节序转化为字符串表示\n\n//例程\nvoid * server(void *argv){\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    assert(fd != -1);\n    struct sockaddr_in serverAddr, cilentAddr;\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(6000);\n    serverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    assert( bind(fd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) != -1);\n    assert( listen(fd, 5) != -1);\n    int len = sizeof(cilentAddr);\n    int res = accept(fd, (struct sockaddr *)&cilentAddr, &len);\n    assert(res != -1);\n    while (1)\n    {\n        char buff[128] = {0};\n        recv(res, buff, 127, 0);\n        printf(\"server recv:%s\", buff);\n        if(strncmp(buff, \"end\", 3) == 0){\n            break;\n        }\n        send(res, \"ok\\n\", 4, 0);        \n    }\n    close(fd);\n    pthread_exit(NULL);\n}\nint main(){\n    pthread_t t;\n    pthread_create(&t, NULL, server, NULL);\n    \n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    assert(fd != -1);\n    struct sockaddr_in serverAddr;\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(6000);\n    serverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    int res = connect(fd, (struct sockaddr *)&serverAddr, sizeof(serverAddr));\n    assert(res != -1);\n    while (1)\n    {\n        char buff[128] = {0};\n        printf(\"input:\");\n        fflush(stdout);\n        fgets(buff, 127, stdin);\n        send(fd, buff, strlen(buff), 0);\n        if(strncmp(buff, \"end\", 3) == 0){\n            break;\n        }\n        recv(fd, buff, 127, 0);\n        printf(\"cilent recv:%s\", buff);\n    }\n    close(fd);\n    pthread_join(t, NULL);\n    exit(0);\n}\n```\n- 类似于与print，在tcp传输中同样存在数据缓冲区，在应用层只有一次接收，多次发送，但在传输层，发送端会在接收多次数据后通过数据缓冲区一次发送，而在接收端，在接收多次数据后全部放在tcp数据缓冲区\n- 由于数据缓冲区的存在，会产生粘包现象\n- netstat -natp 查看数据缓冲区 \n  - n 使用ip地址表示主机 \n  - a 显示结构包括监听socket\n  - t 仅显示tcp连接\n  - r 显示路由信息\n  - i 显示网卡接口数据流量\n## 2. strlen和sizeof\nstrlen 测量的是字符的实际长度，以'\\0' 结束（不包含'\\0' ）。而sizeof 测量的是字符的分配大小，如果未分配大小，则遇到'\\0' 结束（包含'\\0' ，也就是strlen测量的长度加1），如果已经分配内存大小，返回的就是分配的内存大小。\n## 3. UDP\n- tcp：面向连接、可靠的、流式服务\n- udp：无连接、不可靠、数据报","slug":"linux应用开发(3)","published":true,"updated":"2022-06-19T14:32:27.126Z","_id":"cm833960u0014i0q68psr57r7","comments":true,"layout":"post","photos":[],"html":"<p>Linux应用开发</p>\n<span id=\"more\"></span>\n<h1 id=\"Linux平台c语言应用开发\"><a href=\"#Linux平台c语言应用开发\" class=\"headerlink\" title=\"Linux平台c语言应用开发\"></a>Linux平台c语言应用开发</h1><h2 id=\"1-socket-网络编程与TCP\"><a href=\"#1-socket-网络编程与TCP\" class=\"headerlink\" title=\"1. socket 网络编程与TCP\"></a>1. socket 网络编程与TCP</h2><ul>\n<li>主机字节序列和网络字节序列<ul>\n<li>大端：高字节在低位，低字节在高位</li>\n<li>小端：高字节在高位，低字节在地位（x86架构多采用小端）</li>\n</ul>\n</li>\n<li>网络规定使用大端字节序，所以也把大端字节序成为网络字节序列</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">htonl</span><span class=\"params\">(<span class=\"type\">uint32_t</span> hostlong)</span>; <span class=\"comment\">// 长整型的主机字节序转网络字节序</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">ntohl</span><span class=\"params\">(<span class=\"type\">uint32_t</span> netlong)</span>; <span class=\"comment\">// 长整型的网络字节序转主机字节序</span></span><br><span class=\"line\"><span class=\"type\">uint16_t</span> <span class=\"title function_\">htons</span><span class=\"params\">(<span class=\"type\">uint16_t</span> hostshort)</span>; <span class=\"comment\">// 短整形的主机字节序转网络字节序</span></span><br><span class=\"line\"><span class=\"type\">uint16_t</span> <span class=\"title function_\">ntohs</span><span class=\"params\">(<span class=\"type\">uint16_t</span> netshort)</span>; <span class=\"comment\">// 短整型的网络字节序转主机字节序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">in_addr_t</span> <span class=\"title function_\">inet_addr</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *cp)</span>; <span class=\"comment\">//字符串表示的 IPV4 地址转化为网络字节序</span></span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">inet_ntoa</span><span class=\"params\">(<span class=\"keyword\">struct</span> in_addr in)</span>; <span class=\"comment\">// IPV4 地址的网络字节序转化为字符串表示</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例程</span></span><br><span class=\"line\"><span class=\"type\">void</span> * <span class=\"title function_\">server</span><span class=\"params\">(<span class=\"type\">void</span> *argv)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(fd != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>, <span class=\"title\">cilentAddr</span>;</span></span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(<span class=\"number\">6000</span>);</span><br><span class=\"line\">    serverAddr.sin_addr.s_addr = inet_addr(<span class=\"string\">&quot;127.0.0.1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    assert( bind(fd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    assert( listen(fd, <span class=\"number\">5</span>) != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"keyword\">sizeof</span>(cilentAddr);</span><br><span class=\"line\">    <span class=\"type\">int</span> res = accept(fd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;cilentAddr, &amp;len);</span><br><span class=\"line\">    assert(res != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buff[<span class=\"number\">128</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        recv(res, buff, <span class=\"number\">127</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;server recv:%s&quot;</span>, buff);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strncmp</span>(buff, <span class=\"string\">&quot;end&quot;</span>, <span class=\"number\">3</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        send(res, <span class=\"string\">&quot;ok\\n&quot;</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>);        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> t;</span><br><span class=\"line\">    pthread_create(&amp;t, <span class=\"literal\">NULL</span>, server, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(fd != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span></span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(<span class=\"number\">6000</span>);</span><br><span class=\"line\">    serverAddr.sin_addr.s_addr = inet_addr(<span class=\"string\">&quot;127.0.0.1&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> res = connect(fd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    assert(res != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buff[<span class=\"number\">128</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;input:&quot;</span>);</span><br><span class=\"line\">        fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">        fgets(buff, <span class=\"number\">127</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">        send(fd, buff, <span class=\"built_in\">strlen</span>(buff), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strncmp</span>(buff, <span class=\"string\">&quot;end&quot;</span>, <span class=\"number\">3</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        recv(fd, buff, <span class=\"number\">127</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;cilent recv:%s&quot;</span>, buff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    pthread_join(t, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类似于与print，在tcp传输中同样存在数据缓冲区，在应用层只有一次接收，多次发送，但在传输层，发送端会在接收多次数据后通过数据缓冲区一次发送，而在接收端，在接收多次数据后全部放在tcp数据缓冲区</li>\n<li>由于数据缓冲区的存在，会产生粘包现象</li>\n<li>netstat -natp 查看数据缓冲区 <ul>\n<li>n 使用ip地址表示主机 </li>\n<li>a 显示结构包括监听socket</li>\n<li>t 仅显示tcp连接</li>\n<li>r 显示路由信息</li>\n<li>i 显示网卡接口数据流量</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-strlen和sizeof\"><a href=\"#2-strlen和sizeof\" class=\"headerlink\" title=\"2. strlen和sizeof\"></a>2. strlen和sizeof</h2><p>strlen 测量的是字符的实际长度，以’\\0’ 结束（不包含’\\0’ ）。而sizeof 测量的是字符的分配大小，如果未分配大小，则遇到’\\0’ 结束（包含’\\0’ ，也就是strlen测量的长度加1），如果已经分配内存大小，返回的就是分配的内存大小。</p>\n<h2 id=\"3-UDP\"><a href=\"#3-UDP\" class=\"headerlink\" title=\"3. UDP\"></a>3. UDP</h2><ul>\n<li>tcp：面向连接、可靠的、流式服务</li>\n<li>udp：无连接、不可靠、数据报</li>\n</ul>\n","excerpt":"<p>Linux应用开发</p>","more":"<h1 id=\"Linux平台c语言应用开发\"><a href=\"#Linux平台c语言应用开发\" class=\"headerlink\" title=\"Linux平台c语言应用开发\"></a>Linux平台c语言应用开发</h1><h2 id=\"1-socket-网络编程与TCP\"><a href=\"#1-socket-网络编程与TCP\" class=\"headerlink\" title=\"1. socket 网络编程与TCP\"></a>1. socket 网络编程与TCP</h2><ul>\n<li>主机字节序列和网络字节序列<ul>\n<li>大端：高字节在低位，低字节在高位</li>\n<li>小端：高字节在高位，低字节在地位（x86架构多采用小端）</li>\n</ul>\n</li>\n<li>网络规定使用大端字节序，所以也把大端字节序成为网络字节序列</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">htonl</span><span class=\"params\">(<span class=\"type\">uint32_t</span> hostlong)</span>; <span class=\"comment\">// 长整型的主机字节序转网络字节序</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">ntohl</span><span class=\"params\">(<span class=\"type\">uint32_t</span> netlong)</span>; <span class=\"comment\">// 长整型的网络字节序转主机字节序</span></span><br><span class=\"line\"><span class=\"type\">uint16_t</span> <span class=\"title function_\">htons</span><span class=\"params\">(<span class=\"type\">uint16_t</span> hostshort)</span>; <span class=\"comment\">// 短整形的主机字节序转网络字节序</span></span><br><span class=\"line\"><span class=\"type\">uint16_t</span> <span class=\"title function_\">ntohs</span><span class=\"params\">(<span class=\"type\">uint16_t</span> netshort)</span>; <span class=\"comment\">// 短整型的网络字节序转主机字节序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">in_addr_t</span> <span class=\"title function_\">inet_addr</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *cp)</span>; <span class=\"comment\">//字符串表示的 IPV4 地址转化为网络字节序</span></span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">inet_ntoa</span><span class=\"params\">(<span class=\"keyword\">struct</span> in_addr in)</span>; <span class=\"comment\">// IPV4 地址的网络字节序转化为字符串表示</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例程</span></span><br><span class=\"line\"><span class=\"type\">void</span> * <span class=\"title function_\">server</span><span class=\"params\">(<span class=\"type\">void</span> *argv)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(fd != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>, <span class=\"title\">cilentAddr</span>;</span></span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(<span class=\"number\">6000</span>);</span><br><span class=\"line\">    serverAddr.sin_addr.s_addr = inet_addr(<span class=\"string\">&quot;127.0.0.1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    assert( bind(fd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    assert( listen(fd, <span class=\"number\">5</span>) != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"keyword\">sizeof</span>(cilentAddr);</span><br><span class=\"line\">    <span class=\"type\">int</span> res = accept(fd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;cilentAddr, &amp;len);</span><br><span class=\"line\">    assert(res != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buff[<span class=\"number\">128</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        recv(res, buff, <span class=\"number\">127</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;server recv:%s&quot;</span>, buff);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strncmp</span>(buff, <span class=\"string\">&quot;end&quot;</span>, <span class=\"number\">3</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        send(res, <span class=\"string\">&quot;ok\\n&quot;</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>);        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> t;</span><br><span class=\"line\">    pthread_create(&amp;t, <span class=\"literal\">NULL</span>, server, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(fd != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span></span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(<span class=\"number\">6000</span>);</span><br><span class=\"line\">    serverAddr.sin_addr.s_addr = inet_addr(<span class=\"string\">&quot;127.0.0.1&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> res = connect(fd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    assert(res != <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buff[<span class=\"number\">128</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;input:&quot;</span>);</span><br><span class=\"line\">        fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">        fgets(buff, <span class=\"number\">127</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">        send(fd, buff, <span class=\"built_in\">strlen</span>(buff), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strncmp</span>(buff, <span class=\"string\">&quot;end&quot;</span>, <span class=\"number\">3</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        recv(fd, buff, <span class=\"number\">127</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;cilent recv:%s&quot;</span>, buff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    pthread_join(t, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类似于与print，在tcp传输中同样存在数据缓冲区，在应用层只有一次接收，多次发送，但在传输层，发送端会在接收多次数据后通过数据缓冲区一次发送，而在接收端，在接收多次数据后全部放在tcp数据缓冲区</li>\n<li>由于数据缓冲区的存在，会产生粘包现象</li>\n<li>netstat -natp 查看数据缓冲区 <ul>\n<li>n 使用ip地址表示主机 </li>\n<li>a 显示结构包括监听socket</li>\n<li>t 仅显示tcp连接</li>\n<li>r 显示路由信息</li>\n<li>i 显示网卡接口数据流量</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-strlen和sizeof\"><a href=\"#2-strlen和sizeof\" class=\"headerlink\" title=\"2. strlen和sizeof\"></a>2. strlen和sizeof</h2><p>strlen 测量的是字符的实际长度，以’\\0’ 结束（不包含’\\0’ ）。而sizeof 测量的是字符的分配大小，如果未分配大小，则遇到’\\0’ 结束（包含’\\0’ ，也就是strlen测量的长度加1），如果已经分配内存大小，返回的就是分配的内存大小。</p>\n<h2 id=\"3-UDP\"><a href=\"#3-UDP\" class=\"headerlink\" title=\"3. UDP\"></a>3. UDP</h2><ul>\n<li>tcp：面向连接、可靠的、流式服务</li>\n<li>udp：无连接、不可靠、数据报</li>\n</ul>","path":"2022/06/19/linux应用开发(3)/","permalink":"http://chengs.run/2022/06/19/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91(3)/","tags":[{"name":"linux","_id":"cm833960c0002i0q66dwgd8wg","slug":"linux","path":"tags/linux/","permalink":"http://chengs.run/tags/linux/","length":13},{"name":"linux应用开发","_id":"cm833960i000bi0q6eki8aqst","slug":"linux应用开发","path":"tags/linux应用开发/","permalink":"http://chengs.run/tags/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/","length":4}],"categories":[],"prev":{"title":"树莓派挂swap、允许docker限制内存","date":"2022-06-27T13:44:28.622Z","slug":"树莓派挂swap、允许docker限制内存","published":true,"updated":"2022-10-19T12:10:35.712Z","_id":"cm8339612001wi0q60opa0tp9","layout":"post","photos":[],"excerpt":"<p>树莓派挂swap、允许docker限制内存</p>","path":"2022/06/27/树莓派挂swap、允许docker限制内存/","permalink":"http://chengs.run/2022/06/27/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8C%82swap%E3%80%81%E5%85%81%E8%AE%B8docker%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98/","__post":true},"next":{"title":"linux应用开发(2)","date":"2022-06-19T11:36:06.277Z","slug":"LINUX应用开发(2)","published":true,"updated":"2022-06-19T11:37:02.018Z","_id":"cm833960d0003i0q6h1vo40ub","layout":"post","photos":[],"excerpt":"<p>Linux应用开发</p>","path":"2022/06/19/LINUX应用开发(2)/","permalink":"http://chengs.run/2022/06/19/LINUX%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91(2)/","__post":true},"__post":true}